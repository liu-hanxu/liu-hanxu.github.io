<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vim速查图_中英文版</title>
      <link href="/posts/6c0adc53.html"/>
      <url>/posts/6c0adc53.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="中文翻译版"><a href="#中文翻译版" class="headerlink" title="中文翻译版"></a>中文翻译版</h2><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202203181645094.jpg" alt="vim速查图_中文版"></p><h2 id="英文原版"><a href="#英文原版" class="headerlink" title="英文原版"></a>英文原版</h2><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202203181645480.jpg" alt="vim速查图_英文版"></p>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>添加有趣的自定义HTML页面</title>
      <link href="/posts/b668aba.html"/>
      <url>/posts/b668aba.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>网上有很多有趣的 html 特效网页，一般由index.html+js+css组成，且只能本地预览，下面介绍一种方法将html源码整合后添加到博客里面。</p><h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><h3 id="1-新建HTML文件夹"><a href="#1-新建HTML文件夹" class="headerlink" title="1. 新建HTML文件夹"></a>1. 新建HTML文件夹</h3><p>首先在博客根目录的 source 文件夹下，新建一个文件夹用于存放要部署的 HTML 文件。</p><p>我这里建了一个叫HTML的文件夹，里面的子文件夹可以存放各个HTML文件，当然也可以只创建一个主文件夹，直接在里面放 HTML 文件。</p><h3 id="2-跳过hexo渲染"><a href="#2-跳过hexo渲染" class="headerlink" title="2. 跳过hexo渲染"></a>2. 跳过hexo渲染</h3><p>然后在博客根目录的配置文件_config.yml 文件里，设置跳过渲染：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 跳过渲染</span><br><span class="line">skip_render: </span><br><span class="line">  - &quot;xxxx.html&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 跳过文件夹下所有文件</span><br><span class="line">skip_render: </span><br><span class="line">  - &quot;文件夹名/*&quot;</span><br><span class="line">如果父文件夹下还有子文件夹，就写：</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 跳过子文件夹</span><br><span class="line">skip_render: </span><br><span class="line">  - &quot;文件夹名/子文件夹名/*&quot;</span><br><span class="line">或更简单粗暴的方式：</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 跳过文件夹下所有子文件夹和文件</span><br><span class="line">skip_render: </span><br><span class="line">  - &quot;文件夹名/**&quot;   </span><br></pre></td></tr></table></figure><h3 id="3-整合css、js文件"><a href="#3-整合css、js文件" class="headerlink" title="3. 整合css、js文件"></a>3. 整合css、js文件</h3><p>因为 hexo 部署的是静态文件，所有文章的 md 文件会被渲染成 html 文件，<br>hexo 会帮我们把所有 css、js 文件都加到文章里，我们之前跳过了渲染，所以就需要手动把 css、js 整合到 html 文件里</p><p>下面处理分两部分：</p><p>css：找到 index.html 文件里的语句，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/xxx.css&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>然后在 css 文件夹中找到对应的文件 xxx.css，复制文件内容，把上面的代码改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt; css代码内容 &lt;/style&gt;</span><br></pre></td></tr></table></figure><p>js：找到 index.html 文件里的语句，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/xxx.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><br> 然后在 js 文件夹中找到对应的文件 xxx.js，复制文件内容，把上面的代码改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt; js代码内容 &lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="4-验证效果"><a href="#4-验证效果" class="headerlink" title="4. 验证效果"></a>4. 验证效果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>部署后来到 <a href="https://xxxxx.github.io/">https://xxxxx.github.io/</a> 存放 html 文件的文件夹 /xxx.html</p><p>即可查看到你的自定义 html 页面了！</p><p>建议在部署前先试试在本地能否打开，如果不行再按上文修改一次。</p><h3 id="5-添加到导航菜单栏"><a href="#5-添加到导航菜单栏" class="headerlink" title="5. 添加到导航菜单栏"></a>5. 添加到导航菜单栏</h3><p>如果想将这些 html 的界面放到导航菜单栏上，修改主题配置文件_config.butterfly.yml 对应的导航菜单栏代码即可，这里将我的代码放出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">   主页: / || fas fa-home</span><br><span class="line">   时间轴: /archives/ || fas fa-archive</span><br><span class="line">   标签: /tags/ || fas fa-tags</span><br><span class="line">   分类: /categories/ || fas fa-folder-open</span><br><span class="line">   Demo||fas fa-file-code:</span><br><span class="line">     - all html demo || /Demo/ || far fa-file-code</span><br><span class="line">     - 圈小猫 || /HTML/圈小猫.html || fas fa-code</span><br><span class="line">     - 撕渔网 || /HTML/撕渔网.html || fas fa-code</span><br><span class="line">     - 纸飞机 || /HTML/纸飞机.html || fas fa-code</span><br><span class="line">     - 彩虹雨 || /HTML/彩虹雨.html || fas fa-code</span><br><span class="line">     - 方块穿梭 || /HTML/方块穿梭.html || fas fa-code</span><br><span class="line">     - 碰撞小球 || /HTML/碰撞小球.html || fas fa-code</span><br><span class="line">     - 烟花效果 || /HTML/烟花效果.html || fas fa-code</span><br><span class="line">     - 骇客帝国 || /HTML/骇客帝国.html || fas fa-code</span><br><span class="line">   娱乐||fas fa-list:</span><br><span class="line">     - 音乐 || /music/ || fas fa-music</span><br><span class="line">     - 电影 || /movies/ || fas fa-video</span><br><span class="line">   友链: /link/ || fas fa-link</span><br><span class="line">   关于: /about/ || fas fa-heart</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将git信息编译进可执行程序</title>
      <link href="/posts/50c08953.html"/>
      <url>/posts/50c08953.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="脚本build-sh"><a href="#脚本build-sh" class="headerlink" title="脚本build.sh"></a>脚本build.sh</h2><p>运行build.sh 脚本会生成最新的头文件，其包含git信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">commit_ts=`git log -1 --format=&quot;%ct&quot;`</span><br><span class="line">commit_time=`date -d@$commit_ts +&quot;%Y-%m-%d %H:%M:%S&quot;`</span><br><span class="line">current_time=`date +&quot;%Y-%m-%d %H:%M:%S&quot;`</span><br><span class="line">git_version=`git log -1 --format=&quot;%h&quot;`</span><br><span class="line">sed  s/MYVERSION/&quot;version: $git_version commit: $commit_time build: $current_time&quot;/g version.h.tmp &gt; version.h</span><br><span class="line">make clean</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>将脚本内容保存为 build.sh 每次提交源码之后，直接运行build.sh 脚本即会生成最新的头文件，该头文件被编译到程序中，可以看到版本信息包含了最新的版本号，提交时间，编译时间。</p><h2 id="模版文件version-h-tmp"><a href="#模版文件version-h-tmp" class="headerlink" title="模版文件version.h.tmp"></a>模版文件version.h.tmp</h2><p>其中有一个模版文件version.h.tmp，其内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _VERSION_</span><br><span class="line">#define _VERSION_ &quot;MYVERSION&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h2 id="头文件version-h"><a href="#头文件version-h" class="headerlink" title="头文件version.h"></a>头文件version.h</h2><p>运行build.sh之后生成的version.h文件类似如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _VERSION_</span><br><span class="line">#define _VERSION_ &quot;version: 082472d commit: 2017-07-06 16:35:42 build: 2017-07-11 21:01:31&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>在源文件中直接使用 <em>VERSION</em> 宏就可以啦，在git提交版本的时候应该将version.h.tmp模版文件添加到版本控制系统中，而脚本生成的version.h由于每次build都会变化，可以忽略掉。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v2ray多用户配置</title>
      <link href="/posts/21a98812.html"/>
      <url>/posts/21a98812.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="v2ray多用户配置"><a href="#v2ray多用户配置" class="headerlink" title="v2ray多用户配置"></a>v2ray多用户配置</h1><blockquote><p>本文转载自：<a href="https://v2raytech.com/v2ray-multiple-users/，如文中内容有错误请到原文查看原始版(最新版">https://v2raytech.com/v2ray-multiple-users/，如文中内容有错误请到原文查看原始版(最新版</a>)</p><p>如有问题，欢迎到 <a href="https://hijk.club/">网络跳越论坛</a> 或 TG群组 <a href="https://t.me/hijkclub">https://t.me/hijkclub</a> 交流</p></blockquote><p>部分网友自行搭建好v2ray科学上网环境后，不好意思拒绝朋友的分享请求，所以想设置一个不同的端口或者id再分享。类似的需求v2ray都是支持的，配置起来也不算麻烦。本文就v2ray普通版、伪装版分别介绍v2ray多用户配置。</p><p>注意：自行更改配置文件需要用到 vi/vim/nano 等编辑器，或者把配置文件下载到本地修改，修改完再上传到服务端。下载和上传教程请参考：<a href="https://v2xtls.org/bitvise连接linux服务器教程/">Bitvise连接Linux服务器教程</a>(Windows用户)、<a href="https://v2xtls.org/mac电脑连接linux教程/">Mac电脑连接Linux教程</a>(Mac用户)。</p><h2 id="普通版多用户配置"><a href="#普通版多用户配置" class="headerlink" title="普通版多用户配置"></a>普通版多用户配置</h2><p><a href="https://v2xtls.org/v2ray一键脚本/">v2ray一键脚本</a> 运行完后，会输出配置文件路径，默认是 <code>/etc/v2ray/config.json</code>，其内容类似这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;log&quot;: &#123;</span><br><span class="line">    &quot;loglevel&quot;: &quot;info&quot;,</span><br><span class="line">    &quot;access&quot;: &quot;/var/log/v2ray/access.log&quot;,</span><br><span class="line">    &quot;error&quot;: &quot;/var/log/v2ray/error.log&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;inbounds&quot;: [&#123;</span><br><span class="line">    &quot;port&quot;: 12345,</span><br><span class="line">    &quot;protocol&quot;: &quot;vmess&quot;,</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">      &quot;clients&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;id&quot;: &quot;6be0aa25-09c1-4d8b-a96f-75cd3485021f&quot;,</span><br><span class="line">          &quot;level&quot;: 1,</span><br><span class="line">          &quot;alterId&quot;: 53</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  &quot;outbounds&quot;: [&#123;</span><br><span class="line">    &quot;protocol&quot;: &quot;freedom&quot;,</span><br><span class="line">    &quot;settings&quot;: &#123;&#125;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    &quot;protocol&quot;: &quot;blackhole&quot;,</span><br><span class="line">    &quot;settings&quot;: &#123;&#125;,</span><br><span class="line">    &quot;tag&quot;: &quot;blocked&quot;</span><br><span class="line">  &#125;],</span><br><span class="line">  &quot;routing&quot;: &#123;</span><br><span class="line">    &quot;rules&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot;: &quot;field&quot;,</span><br><span class="line">        &quot;ip&quot;: [&quot;geoip:private&quot;],</span><br><span class="line">        &quot;outboundTag&quot;: &quot;blocked&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下文教程的修改都是参考这个文件，如果出现问题，请注意与原来文件的差异。</p><p>v2ray多用户分成两种：同端口不同id，不同端口不同id。v2ray两种类型都支持，接下来分别做介绍。</p><h3 id="同端口不同id"><a href="#同端口不同id" class="headerlink" title="同端口不同id"></a>同端口不同id</h3><p>这是最简单的配置多用户方式。方法是编辑 <code>/etc/v2ray/config.json</code> 文件，在”<strong>clients</strong>“一节中增加新增用户配置。例如在上面配置基础上增加一个用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;log&quot;: &#123;</span><br><span class="line">    &quot;loglevel&quot;: &quot;info&quot;,</span><br><span class="line">    &quot;access&quot;: &quot;/var/log/v2ray/access.log&quot;,</span><br><span class="line">    &quot;error&quot;: &quot;/var/log/v2ray/error.log&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;inbounds&quot;: [&#123;</span><br><span class="line">    &quot;port&quot;: 12345,</span><br><span class="line">    &quot;protocol&quot;: &quot;vmess&quot;,</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">      &quot;clients&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;id&quot;: &quot;6be0aa25-09c1-4d8b-a96f-75cd3485021f&quot;,</span><br><span class="line">          &quot;level&quot;: 1,</span><br><span class="line">          &quot;alterId&quot;: 53</span><br><span class="line">        &#125;, # 逗号不能少</span><br><span class="line">        # 下面是新增的内容</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;id&quot;: &quot;2a1292fd-07be-37e7-af20-57668b4a546a&quot;,  # id可以用 /usr/bin/v2ray/v2ctl uuid生成</span><br><span class="line">          &quot;level&quot;: 1, # 这个不用改</span><br><span class="line">          &quot;alterId&quot;: 63 # 建议50-150之间的一个整数</span><br><span class="line">        &#125;</span><br><span class="line">        # 新增内容结束</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  # 下面的内容保持不变</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>“#”和后面的东西都不能出现在配置文件中，上面只是为了解释说明。</p><p>编辑好文件后，重启 v2ray：<code>systemctl restart v2ray</code>。如果命令失败，或者 <code>netstat -nltp | grep v2ray</code> 输出为空，说明配置文件有错误，请仔细检查，改好后再重启。</p><p>接下来就可以用新的id和alterId配置客户端，其余信息保持不变。</p><h3 id="不同端口不同id"><a href="#不同端口不同id" class="headerlink" title="不同端口不同id"></a>不同端口不同id</h3><p>如果希望端口也不一样，请按照如下步骤做：</p><p>\1. 首先编辑 <code>/etc/v2ray/config.json</code> 文件，按照”<strong>inbounds</strong>“格式新增入口和用户。例如新增一个端口和用户后，配置文件变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;log&quot;: &#123;</span><br><span class="line">    &quot;loglevel&quot;: &quot;info&quot;,</span><br><span class="line">    &quot;access&quot;: &quot;/var/log/v2ray/access.log&quot;,</span><br><span class="line">    &quot;error&quot;: &quot;/var/log/v2ray/error.log&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;inbounds&quot;: [&#123;</span><br><span class="line">    &quot;port&quot;: 12345,</span><br><span class="line">    &quot;protocol&quot;: &quot;vmess&quot;,</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">      &quot;clients&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;id&quot;: &quot;6be0aa25-09c1-4d8b-a96f-75cd3485021f&quot;,</span><br><span class="line">          &quot;level&quot;: 1,</span><br><span class="line">          &quot;alterId&quot;: 53</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, # 逗号不能省，原来这里是&quot;&#125;],&quot;</span><br><span class="line">  # 以下是新增的配置</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;port&quot;: 54321, # 端口是1000-65535之间的一个整数</span><br><span class="line">    &quot;protocol&quot;: &quot;vmess&quot;, # 也可以改成其他协议，如果你知道怎么配置的话</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">      &quot;clients&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;id&quot;: &quot;24813255-228d-b0e0-c3fa-e5d4c9defda1&quot;, # id可以用 /usr/bin/v2ray/v2ctl uuid生成</span><br><span class="line">          &quot;level&quot;: 1, # 0或1都可以</span><br><span class="line">          &quot;alterId&quot;: 57 # 建议50-150之间的一个整数</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  # 新增内容结束</span><br><span class="line">  # 下面的内容保持不变</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>“#”和后面的东西都不能出现在配置文件中，上面只是为了解释说明。</p><p>编辑好文件后，重启 v2ray：<code>systemctl restart v2ray</code>。如果命令失败，或者 <code>netstat -nltp | grep v2ray</code> 输出为空，说明配置文件有错误，请仔细检查，改好后再重启。</p><p>\2. 设置防火墙放行新增的端口。CentOS系统命令是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=54321/tcp # 注意：54321要改成你的端口号</span><br><span class="line">firewall-cmd --permanent --add-port=54321/udp # 注意：54321要改成你的端口号</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>Ubuntu系统命令是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ufw allow 54321/tcp # 注意：54321要改成你的端口</span><br><span class="line">ufw allow 54321/udp # 注意：54321要改成你的端口</span><br></pre></td></tr></table></figure><p>接下来用新的端口、id和alterId配置客户端，其余信息保持不变。</p><h2 id="带伪装多用户配置"><a href="#带伪装多用户配置" class="headerlink" title="带伪装多用户配置"></a>带伪装多用户配置</h2><p><strong>同端口不同id的配置和普通版操作方法一样</strong>，配置好后重启v2ray就行了，这里不再重复。</p><p>接下来说说不同端口不同id的情形。伪装有了Nginx的介入，所以有多种情况，这里只介绍最简单的一种实现方式。</p><ol><li><p>编辑 <code>/etc/v2ray/config.json</code> 文件，按照 <a href="https://v2xtls.org/v2ray多用户配置/#single_port">普通版同端口不同id</a> 中的方法添加用户；</p></li><li><p>编辑 <code>/etc/nginx/conf.d/你的域名.conf</code> 文件，找到 “<strong>listen 443 ssl http2;</strong>” 这一行，在这行下面添加“listen 新的端口号 ssl http2;”一行（新的端口号要改成整数，例如8443，不能是443）。然后保存文件， <code>nginx -t</code> 检查配置有没有错误，没有错误的话重启Nginx：<code>systemctl restart nginx</code>；</p></li><li><p>设置防火墙放行端口，请参考 <a href="https://v2xtls.org/v2ray多用户配置/#set_firewall">普通版设置防火墙</a> 中的命令。</p></li></ol><p>接下来用新的端口、id和alterId配置客户端，其余信息保持不变。</p><p>如果你想添加多个端口或多个用户，重复上面的过程就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> V2Ray </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在Ubuntu20.04上安装和配置Nextcloud</title>
      <link href="/posts/b53da12e.html"/>
      <url>/posts/b53da12e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ol><li>具有sudo权限的用户</li><li>具有example.com域名，并成功解析到当前ip（可选）</li></ol><h2 id="安装Nextcloud"><a href="#安装Nextcloud" class="headerlink" title="安装Nextcloud"></a>安装Nextcloud</h2><p>这里使用<code>snap</code>包管理工具安装Nextcloud，该打包系统可以安装自动处理底层系统的<code>snap</code>包，而不是安装和配置Web和数据库服务器，然后配置Nextcloud应用程序在其上运行，非常方便，适合不爱折腾的小白。</p><h3 id="通过snap-install安装"><a href="#通过snap-install安装" class="headerlink" title="通过snap install安装"></a>通过<code>snap install</code>安装</h3><p>输入命令：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo snap install nextcloud</span><br></pre></td></tr></table></figure><p>将下载Nextcloud  snap 包并将其安装在系统上。</p><h3 id="通过snap-changes查看"><a href="#通过snap-changes查看" class="headerlink" title="通过snap changes查看"></a>通过<code>snap changes</code>查看</h3><p>Nextcloud软件包安装到服务器后，可以通过列出与<code>snap</code>关联的更改来确认安装过程是否成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snap changes nextcloud</span><br></pre></td></tr></table></figure><h3 id="获取snap其他信息"><a href="#获取snap其他信息" class="headerlink" title="获取snap其他信息"></a>获取<code>snap</code>其他信息</h3><p><code>snap info</code>命令可以显示描述，可用的Nextcloud管理命令，以及正在跟踪的已安装版本和快照通道：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snap info nextcloud</span><br></pre></td></tr></table></figure><h2 id="使用SSL保护Nextcloud-Web界面"><a href="#使用SSL保护Nextcloud-Web界面" class="headerlink" title="使用SSL保护Nextcloud Web界面"></a>使用SSL保护Nextcloud Web界面</h2><p>在我们开始使用Nextcloud之前，我们需要保护Web界面。</p><p>如果您的域名与Nextcloud服务器关联，则Nextcloud snap可以帮助您从<a href="https://letsencrypt.org/">Let的加密中</a>获取和配置受信任的SSL证书。 如果您的Nextcloud服务器<em>没有</em>域名，则Nextcloud可以配置自签名证书，该证书将加密您的Web流量，但无法验证您的服务器的身份。</p><h3 id="选项1：使用Let的加密设置SSL"><a href="#选项1：使用Let的加密设置SSL" class="headerlink" title="选项1：使用Let的加密设置SSL"></a>选项1：使用Let的加密设置SSL</h3><p>如果域名与Nextcloud服务器相关联，则保护Web界面的最佳选择是获取Let的加密SSL证书。</p><p>首先打开防火墙中允许加密用于验证域所有权的端口，将Nextcloud登录页面可公开访问，但由于已经配置了管理员帐户，因此没有人能够劫持安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 80,443/tcp</span><br></pre></td></tr></table></figure><p>接下来，输入以下内容来请求Let’s Encrypt证书：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nextcloud.enable-https lets-encrypt</span><br></pre></td></tr></table></figure><p>首先会询问服务器是否满足从Let’s Encrypt服务请求证书所需的条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">OutputIn order for Let&#x27;s Encrypt to verify that you actually own the</span><br><span class="line">domain(s) for which you&#x27;re requesting a certificate, there are a</span><br><span class="line">number of requirements of which you need to be aware:</span><br><span class="line"></span><br><span class="line">1. In order to register with the Let&#x27;s Encrypt ACME server, you must</span><br><span class="line">   agree to the currently-in-effect Subscriber Agreement located</span><br><span class="line">   here:</span><br><span class="line"></span><br><span class="line">       https://letsencrypt.org/repository/</span><br><span class="line"></span><br><span class="line">   By continuing to use this tool you agree to these terms. Please</span><br><span class="line">   cancel now if otherwise.</span><br><span class="line"></span><br><span class="line">2. You must have the domain name(s) for which you want certificates</span><br><span class="line">   pointing at the external IP address of this machine.</span><br><span class="line"></span><br><span class="line">3. Both ports 80 and 443 on the external IP address of this machine</span><br><span class="line">   must point to this machine (e.g. port forwarding might need to be</span><br><span class="line">   setup on your router).</span><br><span class="line"></span><br><span class="line">Have you met these requirements? (y/n)</span><br></pre></td></tr></table></figure><p>输入<strong>y</strong>继续。</p><p>接下来，系统会要求提供用于恢复操作的电子邮件地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutputPlease enter an email address (for urgent notices or key recovery): your_email@domain.com</span><br></pre></td></tr></table></figure><p>最后，输入与Nextcloud服务器关联的域名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutputPlease enter your domain name(s) (space-separated): example.com</span><br></pre></td></tr></table></figure><p>您的Let’s Encrypt证书将被请求，并且如果一切顺利，将重新启动内部Apache实例以立即实施SSL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutputAttempting to obtain certificates... done</span><br><span class="line">Restarting apache... done</span><br></pre></td></tr></table></figure><p>到这里就说明设置成功 。</p><h3 id="选项2：使用自签名证书设置SSL"><a href="#选项2：使用自签名证书设置SSL" class="headerlink" title="选项2：使用自签名证书设置SSL"></a>选项2：使用自签名证书设置SSL</h3><p>如果您的Nextcloud服务器<em>没有</em>域名，您仍然可以通过生成自签名SSL证书来保护Web界面。 此证书将允许通过加密连接访问Web界面，但无法验证服务器的身份，因此您的浏览器可能会显示警告。</p><p>要生成自签名证书并配置Nextcloud以使用它，请键入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo nextcloud.enable-https self-signed</span><br><span class="line">OutputGenerating key and self-signed certificate... done</span><br><span class="line">Restarting apache... done</span><br></pre></td></tr></table></figure><p>以上输出表明Nextcloud生成并启用了自签名证书。</p><p>现在接口是安全的，打开防火墙中的Web端口以允许访问Web界面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 80,443/tcp</span><br></pre></td></tr></table></figure><p>您现在已准备好第一次登录Nextcloud。</p><h2 id="登录Nextcloud-Web界面"><a href="#登录Nextcloud-Web界面" class="headerlink" title="登录Nextcloud Web界面"></a>登录Nextcloud Web界面</h2><p>现在已配置Nextcloud，请在Web浏览器中访问服务器的域名或IP地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://example.com</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>如果设置自签名SSL证书，则浏览器可能会显示连接不安全的警告，因为服务器的证书未由可识别的证书颁发机构签名。 这适用于自签名证书，因此请随意点击警告以继续访问该站点。输入管理员帐户后将进入Nextcloud页面。 </p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nextcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通过WebDAV将Nextcloud挂载到本地</title>
      <link href="/posts/121d06ee.html"/>
      <url>/posts/121d06ee.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="添加网络位置"><a href="#添加网络位置" class="headerlink" title="添加网络位置"></a>添加网络位置</h2><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202201181736445.png" alt="01"></p><h2 id="输入WebDAV地址"><a href="#输入WebDAV地址" class="headerlink" title="输入WebDAV地址"></a>输入WebDAV地址</h2><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202201181737498.png" alt="02"></p><p>WebDAV的地址从网页登录获取</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202201181738898.png" alt="06"></p><h2 id="输入Nextcloud账号和密码"><a href="#输入Nextcloud账号和密码" class="headerlink" title="输入Nextcloud账号和密码"></a>输入Nextcloud账号和密码</h2><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202201181738403.png" alt="03"></p><p>这里可以将网络位置重命名为Nextcloud</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202201181738541.png" alt="04"></p><p>接下来就能看到我的电脑里面多了一个盘，进去后就能看到Nextcloud网盘里的文件了。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202201181738555.png" alt="05"></p><h2 id="修复bug"><a href="#修复bug" class="headerlink" title="修复bug"></a>修复bug</h2><p>通过常规方法将Nextcloud挂载到本地后，重启电脑后会失效，进不去映射盘了，会报错“你可能没有权限使用网络资源……”，换下面的方法重新映射即可。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use N: https://liupaopao.xyz/remote.php/dav/files/xx/  /user:liupaopao /persistent:YES password</span><br></pre></td></tr></table></figure></p><ul><li><code>N</code>：自定义的盘符</li><li><code>liupaopao</code>：用户名</li><li><code>password</code>： 密码</li></ul><p>/persistent 表示保存映射，下次开机还在。执行完，打开资源管理器，可以看到磁盘映射了。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nextcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim中统计字符串出现的次数</title>
      <link href="/posts/dcedac78.html"/>
      <url>/posts/dcedac78.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>vim中统计字符串出现的次数</p><p><strong>关键命令：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/pattern//gn</span><br></pre></td></tr></table></figure><p>参数说明：</p><p> % ：指明操作区间，%表示全文本；可以使用1,$或者行区间代替</p><p> s：substitute，表示替换</p><p> pattern：要查找的字符串</p><p> //：替代文本应该放在这里，两个斜杠中间没有任何字符表示无替代文本</p><p> g：替换该行所有出现的字符串，如果没有该参数则只替换该行第一次出现的地方</p><p> n：表示匹配的行数</p><p><strong>进一步扩展：</strong></p><p>统计k行到l行出现pattern的次数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:k,ls/pattern//gn</span><br></pre></td></tr></table></figure><p>统计在当前编辑文本出现的次数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/pattern//gn</span><br></pre></td></tr></table></figure><p>统计在文件中出现的行数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file|greg –i pattern |wc –l</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决vim中鼠标选中不能复制</title>
      <link href="/posts/bc41595b.html"/>
      <url>/posts/bc41595b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>vim中鼠标选中不能复制并进入可视模式，习惯了在vim中鼠标选中即复制的效果，对此问题从网上查了下发现是vim的默认配置导致的。</p><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><ol><li>修改 vim 的默认配置文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/share/vim/vim81/defaults.vim</span><br></pre></td></tr></table></figure></li><li><p>输入 <code>/mouse</code> 搜索关键词 <code>mouse</code> ，定位到下面位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if has(&#x27;mouse&#x27;)</span><br><span class="line">set mouse=a</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>将 <code>set mouse=a</code> 改为 <code>set mouse-=a</code>（在等号前面加上一个减号）</p></li><li><p>输入 <code>:wq!</code> 保存即可解决问题。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim中同一窗口操作多个文件</title>
      <link href="/posts/f3677974.html"/>
      <url>/posts/f3677974.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1、vim-同时打开两个文件并分割窗口"><a href="#1、vim-同时打开两个文件并分割窗口" class="headerlink" title="1、vim 同时打开两个文件并分割窗口"></a>1、vim 同时打开两个文件并分割窗口</h2><p>上下分割：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim -o filename1 filename2  </span><br></pre></td></tr></table></figure><br>左右分割：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim -O filename1 filename2</span><br></pre></td></tr></table></figure></p><h2 id="2、vim-已打开一个文件，同时再打开另一个文件"><a href="#2、vim-已打开一个文件，同时再打开另一个文件" class="headerlink" title="2、vim 已打开一个文件，同时再打开另一个文件"></a>2、vim 已打开一个文件，同时再打开另一个文件</h2><p>上下分割：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:vs filename</span><br></pre></td></tr></table></figure><br>左右分割：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:sp filename</span><br></pre></td></tr></table></figure></p><blockquote><p>其中，vs可以用vsplit替换，sp可以用split替换。<br>如果finename不存在，则会新建该文件并打开。</p></blockquote><h2 id="3、vim-切换窗口"><a href="#3、vim-切换窗口" class="headerlink" title="3、vim 切换窗口"></a>3、vim 切换窗口</h2><p>先<code>ctrl + w</code>开启窗口切换后，再选择按上下左右键进行跳转：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + w w  // 即按住ctrl键，再按两下w键。或者ctrl + w &lt;h|j|k|l&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>即按住ctrl键，按一次w键，再按一次表示方向的h或j或k或l，则光标会切换到当前窗口的 左｜下｜上｜右 侧的窗口。</p></blockquote><h2 id="4、关闭-vim-窗口"><a href="#4、关闭-vim-窗口" class="headerlink" title="4、关闭 vim 窗口"></a>4、关闭 vim 窗口</h2><p>关闭光标所在的窗口：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q</span><br></pre></td></tr></table></figure><br>关闭所有窗口：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:qa</span><br></pre></td></tr></table></figure><br>关闭除光标所在的窗口之外的其他窗口：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:only</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-《编码：隐匿在计算机软硬件背后的语言》</title>
      <link href="/posts/36fffd2c.html"/>
      <url>/posts/36fffd2c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202112161937656.jpg" alt="书封面"></p><h3 id="第1章-至密亲友"><a href="#第1章-至密亲友" class="headerlink" title="第1章 至密亲友"></a>第1章 至密亲友</h3><p>编码：一种用来在机器和人之间传递信息的方式，编码就是交流。可以通过不同事物的组合表示出特定的信息，最常见的是通过两种事物的组合，如：</p><ul><li>手电筒的<strong>快闪</strong>和<strong>慢闪</strong>组合</li><li>摩尔斯电码的<strong>点</strong>和<strong>划</strong>组合</li></ul><h3 id="第2章-编码与组合"><a href="#第2章-编码与组合" class="headerlink" title="第2章 编码与组合"></a>第2章 编码与组合</h3><p>通过<strong>点</strong>和<strong>划</strong>组合而成的摩尔斯电码表：<br><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202112161954230.png" alt="image-20211216195448024"><br>这样就可以表示不同的字母，达到信息传递的作用。摩尔斯码又称作二进制码，因为其组合方式</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建个人博客或网站</title>
      <link href="/posts/423ac30d.html"/>
      <url>/posts/423ac30d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="从零开始搭建个人博客或网站"><a href="#从零开始搭建个人博客或网站" class="headerlink" title="从零开始搭建个人博客或网站"></a>从零开始搭建个人博客或网站</h1><h2 id="一、安装git和node环境"><a href="#一、安装git和node环境" class="headerlink" title="一、安装git和node环境"></a>一、安装git和node环境</h2><p>1、下载版本管理工具git（官网下载地址<a href="https://git-scm.com/download/），安装时直接点击下一步，根据默认勾选进行安装即可。">https://git-scm.com/download/），安装时直接点击下一步，根据默认勾选进行安装即可。</a></p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311026983.jpg" alt="img"></p><p>2、安装完 Git 后还需要进行全局配置。Git中必须配置全局用户名和邮箱后才能用。鼠标右击，选择Git Bash Here，输入下面两条命令（其中name填你的用户名，email填你的邮箱）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><br>3、下载nodejs（官网下载地址<a href="https://nodejs.org/en/），下载LTS版本即可（长期支持版），默认点击下一步安装即可。">https://nodejs.org/en/），下载LTS版本即可（长期支持版），默认点击下一步安装即可。</a></p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311026472.jpg" alt="img"></p><p>4、打开cmd或powershell命令终端，分别输入git —version和node —version检查下是否安装成功，如果显示版本信息则说明安装成功。最后再查看下 npm 包管理器的版本（npm是随NodeJS一起安装的包管理器），以后主要通过npm来安装各种软件包。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311026196.jpg" alt="img"></p><h2 id="二、安装Hexo博客框架"><a href="#二、安装Hexo博客框架" class="headerlink" title="二、安装Hexo博客框架"></a>二、安装Hexo博客框架</h2><p>1、使用 npm 安装 Hexo，输入下面命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><br>2、输入hexo —version查看版本信息，若显示如下图，则说明hexo环境安装成功。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311025996.jpg" alt="img"></p><h2 id="三、开始搭建Hexo博客"><a href="#三、开始搭建Hexo博客" class="headerlink" title="三、开始搭建Hexo博客"></a>三、开始搭建Hexo博客</h2><p>1、 首先新建一个目录myblog，然后进入到该目录，以后的所有操作都是在该目录下进行。命令如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir myblog</span><br><span class="line">$ cd myblog</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311025003.jpg" alt="img"></p><p>2、对博客进行初始化并生成静态文件，命令如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br><span class="line">$ hexo generate（该命令可以简写为$ hexo g）</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311026495.jpg" alt="img"></p><p>3、输入命令hexo server启动博客服务器，默认情况下，访问网址为： <a href="http://localhost:4000/。">http://localhost:4000/。</a></p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311026008.jpeg" alt="img"></p><p>4、输入网址后，可以看到一个简单的网站雏形，到此Hexo个人博客或网站搭建完毕。另外，官网给出了很多炫丽花哨的博客主题模板，大家可以根据个人喜好换个主题，瞬间就高大上起来了。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311028644.jpg" alt="img"></p><p>官网提供了各种各样的主题模板，什么类型的都有，颜值质量都很高。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311025177.jpg" alt="img"></p><p>这是我的博客美化后的效果，欢迎大家访问我的小站<a href="https://liupaopao.top/。">https://liupaopao.top/。</a></p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311025912.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311025976.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311025288.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311025107.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人免费稳定图床GitHub+jsDelivr+PicGo+Typora</title>
      <link href="/posts/4169710f.html"/>
      <url>/posts/4169710f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="搭建个人免费稳定图床GitHub-jsDelivr-PicGo-Typora"><a href="#搭建个人免费稳定图床GitHub-jsDelivr-PicGo-Typora" class="headerlink" title="搭建个人免费稳定图床GitHub+jsDelivr+PicGo+Typora"></a>搭建个人免费稳定图床GitHub+jsDelivr+PicGo+Typora</h1><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104520.gif" alt="IMG_256"></p><p>搭建完个人博客以后，写文章的时候就不可避免需要插入图片，于是就需要使用图床工具把本地图片转换成网络图片再把图片链接分享出来。市面上的图床工具非常多，但很多都需要收费，有些免费的也存在着不稳定的风险。现在有一种基于GitHub和jsDelivr加速的免费图床。PicGo是一个用于快速上传图片并获取图片 URL 链接的工具，支持多个图床进行使用，其中当然包括我们现在使用的GitHub图床了，它同时支持Windows、macOS、Linux平台。GitHub和jsDelivr都是大厂，不用担心跑路问题，也不用担心速度和容量问题，而且完全开源免费，再结合Typora编辑器，书写markdown格式文章，简直效率神器，快来根据下面教程搭建个人的免费稳定图床吧！ </p><h2 id="一、新建GitHub图床仓库"><a href="#一、新建GitHub图床仓库" class="headerlink" title="一、新建GitHub图床仓库"></a>一、新建GitHub图床仓库</h2><ol><li>登录GitHub账户，没有的话就注册下，然后新建GitHub仓库。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104523.jpg" alt="img"></p><p>2、填写仓库名【CDN1】，勾选上【Public】和【Add a README file】，最后点击创建。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311107307.jpg" alt="Snipaste_2021-10-24_15-30-47"></p><p>3、创建GitHub中的Token(令牌)</p><p>点击右上角头像，选中头像列表中的【Settings】，进入【Settings】，点击【Developer Settings】，再点击【<a href="https://github.com/settings/tokens">Personal access tokens</a>】，接着点击【Generate new token】。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311107067.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311107725.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311107888.jpg" alt="img"></p><p>在Note中取一个名字，选中repo这个框过后直接点击完成（Generate token）</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311107110.jpg" alt="img"></p><p>最后生成token，记住这个令牌一定要复制保存，建议保存到记事本里，如果没有保存的需要删除重来一遍。</p><h2 id="二、配置PicGo"><a href="#二、配置PicGo" class="headerlink" title="二、配置PicGo"></a>二、配置PicGo</h2><p>1、安装PicGo</p><p>下载地址 <a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a> ，选择下载与系统匹配的安装包，根据默认勾选安装即可。</p><p>2、打开PicGo，配置图床</p><p>设定仓库名：按照【GitHub用户名/图床仓库名】的格式填写</p><p>设定分支名：【main】</p><p>设定Token：粘贴GitHub生成的【Token】</p><p>指定存储路径：默认路径为【img/】，图片将会储存在此文件夹中，而我改成了img/2021/。</p><p>设定自定义域名：它的的作用是，在图片上传后，PicGo会按照【自定义域名+上传的图片名】的方式生成访问链接，放到粘贴板上，因为我们要使用jsDelivr加速访问，所以可以设置为【<a href="https://cdn.jsdelivr.net/gh/用户名/图床仓库名】">https://cdn.jsdelivr.net/gh/用户名/图床仓库名】</a></p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104577.jpg" alt="2"></p><p>3、进入PicGo设置，打开时间戳重命名，避免因图片重名而导致上传失败。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311345102.jpg" alt="3"></p><p>4、可以打开上传区测试一下，选择URL的图片链接格式，上传完图片后复制链接，直接再浏览器打开就能看到了。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104927.jpg" alt="4"></p><h2 id="三、配置typora"><a href="#三、配置typora" class="headerlink" title="三、配置typora"></a>三、配置typora</h2><p>1、下载typora：<a href="https://typora.io/">https://typora.io/</a></p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104776.jpeg" alt="111"></p><p>2、打开【文件】中【偏好设置】，选择【图像】，根据图片中配置进行勾选。最后再找到PicGo软件的安装位置，可以上传验证测试下，默认会上传typora图标。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104208.jpg" alt="01"></p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104756.jpg" alt="02"><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104944.jpg" alt="03"></p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110311104504.jpg" alt="04"></p>]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>龙芯服务器重装UOS系统+搭建本地仓库源</title>
      <link href="/posts/e8c622c9.html"/>
      <url>/posts/e8c622c9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="龙芯服务器重装UOS系统-搭建本地仓库源"><a href="#龙芯服务器重装UOS系统-搭建本地仓库源" class="headerlink" title="龙芯服务器重装UOS系统+搭建本地仓库源"></a>龙芯服务器重装UOS系统+搭建本地仓库源</h1><h2 id="一、安装mips64el架构UOS系统"><a href="#一、安装mips64el架构UOS系统" class="headerlink" title="一、安装mips64el架构UOS系统"></a>一、安装mips64el架构UOS系统</h2><p>1、进入统信UOS官网—&gt; 生态社区—&gt;资源中心—&gt;镜像下载页面，选择服务器版，下载MIPS64镜像（直达网址：<a href="https://www.chinauos.com/resource/download-server）。">https://www.chinauos.com/resource/download-server）。</a></p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/2021/202110260942455.png" alt="img"></p><p>2、通过UltraISO软件将下载的ISO刻录到U盘里，制作一个U盘启动盘。</p><p>3、修改龙芯服务器BIOS启动项，把U盘启动改成第一启动项就进入了系统安装环境，大约要等半小时才能安装成功。</p><h2 id="二、配置本地仓库源"><a href="#二、配置本地仓库源" class="headerlink" title="二、配置本地仓库源"></a>二、配置本地仓库源</h2><p>如何使用统信UOS镜像搭建本地源？（直达网址：<a href="https://www.xtuos.com/817.html）">https://www.xtuos.com/817.html）</a></p><p>1、将对应版本的server iso镜像挂在到/mnt目录下</p><p><code>sudo mount uniontechos-server-20-1040d-mips64el.iso /mnt</code></p><p>2、修改源地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/source.list</span><br><span class="line"></span><br><span class="line">deb [trusted=yes] file:///mnt eagle main</span><br></pre></td></tr></table></figure><p>（我这里根据镜像信息，把eagle对应改成了fou：deb [trusted=yes] file:///mnt fou main）</p><p>3、更新源。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update //注意如果宿主机是桌面版需要关闭商店源和打印机源，不然update会报错</span><br></pre></td></tr></table></figure><br>（我这里服务器版也必须关闭商店源和打印机源：进入/etc/apt/source.list.d，打开appstore.list和printer.list两个文件，注释掉里面的在线仓库网址）</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>份子钱清单</title>
      <link href="/posts/63534.html"/>
      <url>/posts/63534.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="2d3af23e10944da092de61b201fb37ec172d4f5859aad6353c2078dde230a693">b74c372b77015f4e57de3c2b37100bc1e73ca956030c5d616d6a12bd7040994f1f5bbd0d6759e4ed4b1c806369c5969d327939ba6ee889289292206ecdedb2a44a151fb69104de75578889d03c3c2e262f261c3053dd407008b65404400c3c32725e0eaa9c2a17a96a477edfa9e01d0c0e35810b3fbd0d01c2f9637b0a4c14dd39bdbc471e7ec1a9a54b5a345065d38761f61753141bd7abe3ca82a17c8f636eb99522e8a8304e9d97deed106d289e87d44f206f1892da53b9b61f6acc9ecfaf5e3bea26130f13047c114fd7dfddb855da5102a54244aa4615bda50107e1b5699726c53e2ee168504a10e3669f9e522a8277651a49a00b40592de9f234e047ee6caff5580f10eded0cfb7d5daa91e38012394ec4865225642f91d470d6b1b6bc352814c6f6fee8261636e4ac7e2ad2becfdf77d28ef3fc80eac8bf8d3ef99593bf760c0ee4a53ba61a82ebfc142c883d89a9598461ce81a8f0d7c714a0749a52a2af564edc75ce17079d423fe6a6f62978107d7dcd57bd65e6c48cfdf4c055df06ba2785ac4fa24b550e395767049efc80fe73b6068e4b346e940cf913300cd2906c9eb3ea4820536e35ed6275282a809e7fd8599862e0f91adc9615cd484e52fa6e55c471d57f2179be801a7e04b7619616f003fd82b7f5abf7fe9e307e34d8ba1c91b35edeea4c8bcaff4ae0c9173948e688fb1579cdcca8b44b797d2f9f1cfa5c760e5f72e9868710e865e9d4ea3f150d0383d03118f297ea49bee3f03ab5a8db3330236b2a47d7525e37558b96cbcef02b2c98660a791ad8ee6c00618f46deab2810d93e658125fa5868f39f7380902ef4d8e6b216b43898ccc917206fbb8908cf7825983a4fe6fbc391bb1d6172bbca90af6f48ccb1c570ffc7f23b9bc0e9e1992e803872b236da8eb23aa8d48e2b1ee90e40612972545a4acdd18021853e423d2bc4e997c639d2b49d17422ed15e0c4b32bd9d058760b34a518dce643aae55125f77d6454b4ff93dcf6a07e093548f0b48d7201f32045ec2c95c26a6aee916548a1eb6d8d22d257b778483802301038bf0bbe814cd1868741b862440cc6c34a9ada4d92c5669d743974df9f49e8870971d0f157e40e1254ddb3a018ca6ae23ad7e761c41db1e09258eb0665132cf8034bca4c450384963990825c04062ae353bbd5ab63a370871440659adec1927850c477016cf357edfc7f6b6584d021b18f969dfe37e51247ee9d3e281b583f1b450149f0f2dab8f0024ed4f47c9fbcb10e3e5879761d81448855c41cbdc6fbd57feaa54fa86d372a5e636fe3d42d3cb5cfbbdbf5fe36c931877bd2973ce549fbb0e4640970e7c8c55c947bbd51c814d0ceecaa826d3bec57a1c0840952478b2e0a0c2b70b822b8f5497d156ed81f15c78aa01a74a71cdeb50cbe10b5572d3fa6988568b77b2828a54ba27f855de94d5601886d6c2ebe104106173ab9bcebabdcca15d5ca388b6dd128a3c59902f5469bda51f93f29b213b8c1ee3bfade2e2ea0d0aca1e2200a90e68b849054775f9fa4a9ebff16a44487e59d8aec134c2da46bb0d4dc527dec546aabc6a38cb62c36ec2b825095b0192d4e130000c85afc73d1bdbd3c940ff977e2c80768e56992bb7c6e6c2ed4b2152b77021394f48eb17d72f6132aa11bbd56bd8dfc34d4a02da77d9444124598f8d747ef0aa1a388b98cd296d591713e36a833dbae5e3e7b8f855aa5b3cb60ef0798809a7c1e2827cdb02eb67481306b044fe7855f949b55fa12807605e1dc438a2228e1da4ca373422e7d65cf5b22914b43b83160b5f89ab84780223034eaf290e3d4cc87649e00fb4c32ff80c4ef24c1c90c5a3418474849e43b4f51a5cf8dc6e0734bb8bb5de3099b1549683ee8f3cf56ec3e3cf3d2c0bf7441827bf9a27409e86a028b045a63fd6c27e95d9f11e494ec68b8b673a17bdab20c5067d5c4bfa9138d00321c972dabd4cc31c44c49f1dfb39dba13a732a9fcb6079c8a9697da8808ba122aaf5b23fe09c2eefb2f511fb38bbe42dc73d577a8c082684f691c023a4cee07281e6fe55790cb1e7da8b151227b463fafdb401d760bfcd0c3d6c2afd63fd2f1cfb7f61d3dc27fac83731cf14ba6473d2e20b76c248ded626dd611d67cb3b3a5c3c343462f2dd58d6429632b94dfd654eb644c8e1b43df5de94234f6d077d63507e661ef84773b214aa0f05821c975f9761ec1fbbc839a8a8d4b0304b70ed430fe50232d00110bc51b066284c29130385e70b6450798d6c58b39018d0bca87433741b024d1822c98aa752cc2a80680956a67052ecead0bd4fe8b540fdfaa95d8e75afc958999ec18c0cd7a09582a4cc58492c76903719ee0cd6695d47a284b1e416026377c7b5a09a7dc854fb0aff3bdd934e3775dc14fbdd8392ebf45f3d0532c3a54e1faad47bb4c3176b0cb9d25d1cee81c1859aa82bf2496195afb855d069c05fb95cbf3134a82ad24f8b55ca4ad697b635da0f2b5849361960d6904d05d42eaaff0a00f1ede37a6a4a99de3feef247f6d1c8d088675e7e738483847e3c6be1ae9f5b932a7dbfed017ecd28064570d0dc7ccdff980d5b4517fcf282b64729c29726dddc8d57fcdfb689d58a127464431a229506b490ee3f0b96955a8146895b5a791b8cdbfbdc91087b98191a1cffbf6cf2588848379ec1460fa2b694bc0e2e5204b5a11ed975447f11ef1131197a53a4c25402b958477243ec755dd5b2639bb176dd6254e20d3c0e5db369e0df112671c00dce41bdd0a5385119a4f2f825a94f4ebe5ee0b2eee7d454d977cd75e738e2492886d914b8ff6fa6567a7ac703156a9ebe85abcd85e6bbb39b49d91ec07798b8100115a88b4214452071bcb99bc9f407bc5c1f76ab3e0dcb8983c1df0352dd8347ada8c5b9cd09a5ae28addc7d1022df7d976dc9d271f1041afbcfed69c9dd88f9e4d79865ddec97486288fcaf7300a33995e8801a275a894a4e5e36ed587e34b1c26a0d4fda7ca0cdb4a83408f2b9fcd6d3ac3b5f7ce9aaae01b58e371aa24f90f8324aef8072904a2483396906b486facd73a4ed2696ca28d70286cfec88ecea422bee8ce566df9068171b80c0aadf61b0466c9a797503cd169e5fa28112fdd3c995310d1950b66b0856dcedb446ca3e47922b2d18028a6030abe6ea0da4d6b620a48ebf2b9d029ba1add7db8373faab87a4447b979185c30579cc1dddfa39e1a7fb0d3b186fedae9bdf71243c04f03f37b346dc74d172e0908cd21adee8f519772cfa9b8e2866487fc282754fab2d9317449d04af98f4865faee0e7eeee9d1212c2d0bd647cc77f42a6868ea5d78c560651294b3df1835fa2a46ce0d992b58e08d10e824493cfca0fc8cc94e4629191911413ae69e7a45cbe6bb3585923205fe5088b9cd447cc49548626b9c80c77b13197ffcecf00b70ddfd70b436578c1b632f9aea49f7e7a7ebe27a1dfe14fa0624dcfcd19a22182a64970a9d637d25b828cd254ee04f1f082bcbe266814e8ac20940287d51b2f7fff9fb5ad656c6b747eb51614a25a76fac164d302f740c111dcd29d12a11b0fbb23822ada3d87e889fa3e733f064600f4fe511bb16e6fc82f6513601dc763ef8412a7f2c556b68b93cae1e86011a0f2989ab01c32962ce5cb945cf27affef339af2d6d81083893cf3b165f0320db85f6b17328f6dd79de5682280e8df93748168bd5a43d7ee9c1d8c6a10e0dcf9a236c4c7abcbb4fa0a760ef3a098a5b6a1c83c7d9278e1793e79f3a3c115203d12d355590b0a086c19e59b857918a2504c137029b19d9e52d57674af6b92d4192b43d987bf6339039b4b044c5650abf804bae9427dd34860a24f4675e8697f62067e27847827dca2b3f35dee0b7d2c04dcbee3cbf15cae3d118fe53569b1675ca6477882cc57b68ca6eb660b3fa14c4a5f861bbd9f8296f09766a168dc0dba3a9424e37b95c81cccbf31099e91b167512ef660597f00480c2b344b1c675490d25a600a4ed4efb024d441cc843b0f98485a783ba5e707aee43fc4ee2818db690c90bc7eed019785d0b91180a027d70ea0b94ad6844f4830e4ccc5b04316f7b3c899266f6957f92bab2b924d6dbd60cb0d4376c0b57bb78f4a67d2cca2b95bc94a7bc519fb2596305f8fd97ddb9886af434362928fa6eb109298b49b92886fbf91229256ab47ea24b191090af4fd6422c0b396f4350ea42f1a8a5f0e7d73746f35ca9a256850eba0ade16de02f244ad6cb14cba549883c39bb9e3bfde263c73e773a166726241a826c38b67364af43a6bc11104b1ca44dca40b8bdd9875670bcfbe5b87979d1c55d5fd8755401d93ed44ac3ba9caaa8690d3ea986572660f971defa1d0b7222934175202bf4bd7529b12e75e156f3bb20c1a5ae214ea17919d594181b8ef97e0371abe661215c94319696474ae08e5cf3b54f3649caedc45b0cdbb8b750ce95fa16f51d95dcee74634c0bfb1e493a94b2bcdd5aee4dd4e30a97a5b499bb6dd7f9dc0c79250e14cb890dfe9fefcc138991ed1da54760f8bcd807ed7bf32365d4cb859cb4360af313faaaa8ca14dc11110d6a90118b765ce874dbb22a0a339eecba7585926125afc870c43f07eacd72ad123fc527425f75b3e1057df573c13c0becf83076aaa108448faa17b496273adb3cc9c428a6515c60339ecac0b102f2a03ee9b953f478c34ba1f64a265b43a2f21604ae5280f442f878404cfec53bd32bf66a966c989608be998dfcf5337a46f90ecdf3547f6b6c729a186dfba80ce768c796bc6356b841be68239801e2442286aac79a5e88f4989f2fb74e1f9b9dca26b92727e4e2894904c299ae4cc278f5a674354fe247ec7a08c298d82611c067aaccd162b702ce81934d5f3f517dbaa3864f21100c002dcec0fc6543f1261b18a49c068ae36700ac2232a43f846c02ef7a85481dfdf6ef503c7e9914c065fd6d8f8e48a35639bc3f0756bc9d83cae20cc8748ccf39ca0437137aff314723a86423f5f18c865593ea8d9f7ae86e18092216c30de9e385f22f3b099e09cddffe9e09a6d10dc6738578c6b2c86062229853d0e563bc0df87b324b21ed7ac3d4b207d961919d09f0e0c96b67d7f5f7459e5717ae6264387d7a8a1acbd715487c789c07cdc1211d3394a1cc217b92c3456d64ddc1545f8c78d5ed0b1abd65f010e2a061b3c054d8c6b0d60cd80f9da974ece2390e5d3f92a108cd76579a520cfc3862abfd1fccdda5afaed58d258832a7c9a3526b934c89d22f2eb4e9fa94e47bc5972dd9dfb0943e4b65eb3663afe2736c0914e17b07ee960bd6f13fcc496ee2df3345494809f8e4b1b7dda1452155b5c627e59a78345d994f6e744b4586346479b023449750fbc2dd99447cfc0c5fe86be77fcc17375990c870375c1aa8f49583dff2d7825bc9d915958beae33187e38b3dc29e869076383f66d6f9a31f87d27a796e47955f779fb0e429afec617f0dae36c91eae4ed3bbcc7179fe5dff1c3499b32a7b325e411f8a808bac1639b635a2ea0b1a7cf4a940ac01bb0fa3fe9cf7b87ae01c30aa1635b83a6bbcc9bcbd245848c9478e8a3c6977866fe07382f2299fd8af9389cf40dd243c6427c4bd753048115083ae190b3475db03a9485deb9aa9c4de6ec337e09c0e8529110983c7ccad3ed3e7758724701cbe1bf5b021e40c4616b66758c552f2f5601782a6e7f48dfa740ed8210fbc9e640bb54b2c77f9c00c92b5cd2248ba806cca140134609764b21167c76d617d5f91fcf09d0efc82080bfa49c2df1a9f8dabaa2dcbca25b1a85aea208792fcf62b5a752161dc01b7dbdad1a4a1f67393273fa5e1bb416b8c5e7c7cfe32b0c064c79c22b352ce889df2657cb4399d3aef4e228bc6041bf7cc451dd0c520fe3c5572cffe0fb46b860ee618a791d9e34673b84b810ccbfc6a64848972b47fcad9d228ff873bfdf4106b76227e69899d8809fbcf87ce55bd669bc57168c6a48dcd565f2b0fc067c18da79580c91551dd025c49a3b017be399150c7d4d06088816c79801b0541f166112e80a43903dd7bc5ecb21202ffc5c6de1e58faf2bf86b3dbe9f788e67d7441cf5d6364373e1b44bd9de472adbd0f93fc006520a506e935a3a7e9cc3458f90611ad4932545735025bdaef304fa0c89e6d6136e74920d7f35960ee5576eaea6c9d32cc0910329cc36890589354b7b0e1f78c84ebbe2ab2d8aa84ee33b21230a4b46d42e46cd20f5e21d4df1eed6a8a89147650446c1079aac333cefcfe6a8f11b49c90acba7c9f05e94973f37b3c73739b408e596e0110dfb1f494567a00ed497a83c99a1a28382d59d01b6c20ac212d7e9383dfec32c19135ac68fbe537098fc1635762a3dda5c600683f584b410f9d066dcb4a0abd03d83945fb15fdea7b567af47efc41f773698dfaf76fcb97ed740c56e9b610750a62546c281fa0b7ced4bead153c8726d49656cfa188db2f75c18156224e9eb9cf47a91e3bd69593a9bab2028bc3e17781c35dd31c7f2783107025a157a20e6e9b5683feccd83065c0ddd2173e085ec2b33ed3165533e7cc0e2efb6306f45760b2bb33c1d2ae02fb51b982eac02a186f08a7a84f2b0260871473d82f57071ac3a4f9a5a0f6ad5d75271b692833e28c3e484af7462dd394e20029b4719330626a2af47a2687d273834a5a2e145a2e6158839ff67b0f5f38afb22959170c42d7e7a9a1b7b64930c9add422f30f49934a847da4151eb735476d8e4571b2e6e419cfa75ba4048e32b488d0841b4313bd83afeec04b75096ebac255b809cabeeb96abcbf4c22f82c794198cdcb9f852d367ecd7a92153735501e7611558c18a88ea00a127c88c06dcb18fe65ed8bdf5edd5900d112015acb7d46ff8fde7392a861b6be782e200f2c4df6e4bb34196e965c4ac80c185a0325887206709a7478f34b302aedad12fe29d5a4139ededd01eb4bdaf4c06a0311f8911159c0bc10304b5b3d2dda3bd96247d93265acbff502f762ebe46b66d209b5c8e58f1df69b16dd83d3e5d85fe5ff8d20262d91581ef8fa2a12f7d294f9cbce9be5d65cac4d58cde9d9ff1fe489966e4d6ab0bf59c6858667e42533378ae54f12a0b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">请输入密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPM介绍</title>
      <link href="/posts/22588541.html"/>
      <url>/posts/22588541.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="RPM-命令"><a href="#RPM-命令" class="headerlink" title="RPM 命令"></a>RPM 命令</h1><p><strong>一、RPM 介绍</strong></p><p>1.什么是 rpm ？</p><p>rpm 即 RedHat Package Management，是 RedHat 的发明之一</p><p>2.为什么需要 rpm ？</p><p>在一个操作系统下，需要安装实现各种功能的软件包。这些软件包一般都有各自的程序，<br>但是同时也有错综复杂的依赖关系。同时还需要 解决软件包的版本，以及安装，配置，<br>卸载的自动化问题。为了解决 这些问题，RedHat 针对自己的系统提出了一个较好的办法<br>来管理成千 上百的软件。这就是 RPM 管理系统。在系统中安装了 rpm 管理系统以后，<br>只要是符合 rpm 文件标准的打包程序都可以方便地安装、升级、卸载。</p><p>3.是不是所有的 linux 都使用 rpm ？</p><p>任何系统都需要包管理系统，因此很多 linux 都使用 rpm 系统。 rpm 系统是 Redhat Linux 和<br>Fedora Core 的软件包管理器，但是 Mandriva、SuSE 等 Linux 发行版也都使用 rpm。由于 rpm<br>的源程序可以在别的系统上进行编译，所以有可能在别的系统上也使用 rpm。除了 rpm，<br>其他一些系统也有自己的软件包管理程序， 例如 debian 的 deb 包。</p><p>4.rpm 包的文件名为什么那么长 ？</p><p>rpm 包的文件名中包含了这个软件包的版本信息，操作系统信息，硬件要求等等。<br>比如 mypackage-1.1-2RH.i386.rpm，其中 mypackage 是在系统中登记的软件包的名字 1.1<br>是软件的版本号，2 是发行号，RH 表示用于 RH 操作系统。i386 表示用于 intel x86 平台。</p><p>5.软件包文件名中的 i386,i686 是什么意思</p><p>rpm 软件包的文件名中，不仅包含了软件名称，版本信息，还包括了适用的硬件架构的信息。</p><p>i386 指这个软件包适用于 intel 80386 以上的 x86 架构的计算机(AI32)<br>i686 指这个软件包适用于 intel 80686 以上(奔腾 pro 以上)的 x86 架构的计算机(IA32)<br>noarch 指这个软件包与硬件架构无关，可以通用。</p><p>i686 软件包通常针对 CPU 进行了优化，现在通常配置的机器都可以使用 i686 软件包。</p><p>6.不同操作系统发行的 rpm 包可否混用？</p><p>对于已经编译成二进制的 rpm 包，由于操作系统环境不同，一般不能混用。<br>对于以 src.rpm 发行的软件包，由于需要安装时进行本地编译，所以通常可以在不同系统下安装。</p><p><strong>二、RPM 包管理的用途</strong></p><p>1、可以安装、删除、升级和管理以 rpm 包形式发布的软件；<br>2、可以查询某个 rpm 包中包含哪些文件，以及某个指定文件属于哪个 rpm 包；<br>3、可以在查询系统中的某个 rpm 包是否已安装以及其版本；<br>4、作为开发者可以把自己开发的软件打成 rpm 包发布；<br>5、依赖性的检查，查询安装某个 rpm 包时，需要哪些其它的 rpm 包。</p><p>注：RPM 软件的安装、删除、更新只有 root 权限才能使用；<br>对于查询功能任何用户都可以操作。</p><p><strong>三、rpm 的一点简单用法</strong></p><p>rpm 的一般格式：</p><p>rpm [选项] [rpm 软件包]</p><p>1、初始化 rpm 数据库（可以省略）</p><p>rpm —initdb<br>rpm —rebuilddb % 注：这个要花好长时间</p><p>%注：有时 rpm 系统出了问题，不能安装和查询，大多是这里出了问题。</p><p>2、RPM 软件包管理的查询功能：</p><p>rpm -q [select-options] [query-options]</p><p>RPM 的查询功能是极为强大，是极为重要的功能之一；这里举几个常用的例子，更为详细的具体的，请参考 man rpm</p><p><em>对系统中已安装软件的查询</em></p><p>1）查询系统已安装的软件</p><p>语法：rpm -q 软件名</p><p>例：rpm -q gaim<br>% -q 就是 —query，此选项表示询问系统是不是安装了 gaim 软件包；<br>% 如果已安装会有信息输出；如果没有安装，会输出 gaim 没有安装的信息；</p><p>%查看系统中所有已经安装的包，要加 -a 参数<br>rpm -qa</p><p>% 如果分页查看，再加一个管道 |和 more 命令<br>rpm -qa |more</p><p>% 如果要查找某个软件包，可以用 grep 抽取出来<br>rpm -qa |grep mplayer</p><p>2）查询一个已经安装的文件属于哪个软件包；</p><p>语法: rpm -qf 文件名</p><p>注：文件名所在的绝对路径要指出</p><p>例：rpm -qf /usr/lib/libacl.la</p><p>3）查询已安装软件包都安装到何处；</p><p>语法：rpm -ql 软件包名</p><p>例：rpm -ql mplayer</p><p>4）查询一个已安装软件包的信息</p><p>语法： rpm -qi 软件包名</p><p>例：rpm -qi mplayer</p><p>5）查看一下已安装软件的配置文件；</p><p>语法格式：rpm -qc 软件名</p><p>例：rpm -qc mplayer</p><p>6）查看一个已经安装软件的文档安装位置：</p><p>语法格式： rpm -qd 软件名</p><p>例：rpm -qd mplayer</p><p>7）查看一下已安装软件所依赖的软件包及文件；</p><p>语法格式： rpm -qR 软件名</p><p>例：rpm -qR mplayer</p><p><strong>注</strong>：可以把几个参数组合起来用，如 rpm -qil mplayer</p><p><em>对于未安装的软件包的查看</em> :查看的前提是当前目录下已存在一个.rpm 文件。</p><p>1）查看一个软件包的用途、版本等信息；</p><p>语法： rpm -qpi file.rpm</p><p>例：rpm -qpi mplayer-1.0pre7try2-2.i386.rpm</p><p>2）查看一件软件包所包含的文件；</p><p>语法： rpm -qpl file.rpm</p><p>例：rpm -qpl mplayer-1.0pre7try2-2.i386.rpm</p><p>3）查看软件包的文档所在的位置；</p><p>语法： rpm -qpd file.rpm</p><p>例：rpm -qpd mplayer-1.0pre7try2-2.i386.rpm</p><p>4）查看一个软件包的配置文件；</p><p>语法： rpm -qpc file.rpm</p><p>例：rpm -qpc mplayer-1.0pre7try2-2.i386.rpm</p><p>5）查看一个软件包的依赖关系</p><p>语法： rpm -qpR file.rpm</p><p>例：rpm -qpR mplayer-1.0pre7try2-2.i386.rpm</p><p>3、软件包的安装、升级、删除等； <em>安装和升级一个 rpm 包</em></p><p>语法：<br>rpm -ivh file.rpm % 这个是用来安装一个新的 rpm 包<br>rpm -Uvh file.rpm % 这是用来升级一个 rpm 包</p><p>% 如果有依赖关系的，需解决依赖关系。<br>% 如果找不到依赖关系的包，可以用下面的命令强制安装：</p><p>rpm -ivh —nodeps —force file.rpm<br>rpm -Uvh —nodeps —force file.rpm</p><p>例：<br>rpm -ivh —test mplayer-1.0pre7try2-2.i386.rpm<br>% —test 表示测试，并不真正安装。</p><p>rpm -ivh —relocate /=/usr/local/mplayer mplayer-1.0pre7try2-2.i386.rpm<br>% 为软件包指定安装目录：要加 —relocate 参数<br>% 安装在指定目录中的程序如何调用呢？<br>% 通常可执行程序都放在安装目录下的 bin 或者 sbin 目录中。</p><p><em>删除一个 rpm 包</em></p><p>首先查出需要删除的 rpm 包，然后用下面的命令来卸载：</p><p>rpm -e 软件包名</p><p>例：rpm -e mplayer % 卸载 mplayer<br>% 如果有其它的 rpm 依赖于该 rpm 包，系统会出现警告。<br>% 如果一定要卸载，可以用选项 —nodeps 忽略依赖关系。但最好不要这么做。</p><p><strong>四、RPM 管理包管理器支持网络安装和查询</strong></p><p>rpm [选项] rpm 包的 http 或者 ftp 的地址</p><p>比如我们想通过 Fedora Core 4.0 的一个镜像查询、安装软件包。</p><p>rpm -qpi <a href="http://mirrors.kernel.org/.../RPMS/rsh-0.17-29.rpm">http://mirrors.kernel.org/.../RPMS/rsh-0.17-29.rpm</a><br>% 查询</p><p>rpm -ivh <a href="http://mirrors.kernel.org/.../RPMS/rsh-0.17-29.rpm">http://mirrors.kernel.org/.../RPMS/rsh-0.17-29.rpm</a><br>% 安装</p><p><strong>五、对已安装 rpm 包查询的一点补充</strong></p><p>可以用 locate 来查询一些软件的安装位置，可能需要先运行 updatedb 来更新已安装软件库</p><p><strong>六、从 rpm 软件包抽取文件</strong></p><p>rpm2cpio xxx.rpm | cpio -idmv<br>% i 表示提取文件，v 表示指示执行进程<br>% d 表示根据包中文件原来的路径建立目录<br>% m 表示保持文件的更新时间</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>吉他谱</title>
      <link href="/posts/291db989.html"/>
      <url>/posts/291db989.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="朴树"><a href="#朴树" class="headerlink" title="朴树"></a>朴树</h2><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/朴树/1.jpg"/></div></div><h3 id="平凡之路"><a href="#平凡之路" class="headerlink" title="平凡之路"></a>平凡之路</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/朴树/平凡之路01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/朴树/平凡之路02.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/朴树/平凡之路03.png"/></div></div><h3 id="NewBoy"><a href="#NewBoy" class="headerlink" title="NewBoy"></a>NewBoy</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/朴树/NewBoy01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/朴树/NewBoy02.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/朴树/NewBoy03.png"/></div></div><hr><h2 id="许巍"><a href="#许巍" class="headerlink" title="许巍"></a>许巍</h2><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/许巍/1.jpg"/></div></div><h3 id="漫步前奏"><a href="#漫步前奏" class="headerlink" title="漫步前奏"></a>漫步前奏</h3><ul><li><p>版本1：</p><div class="video"><video controls preload><source src='https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/许巍/漫步前奏00.mp4' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/许巍/漫步前奏01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/许巍/漫步前奏02.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/许巍/漫步前奏03.png"/></div></div></li><li><p>版本2：</p><div class="video"><video controls preload><source src='https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/许巍/漫步前奏10.mp4' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/许巍/漫步前奏11.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/许巍/漫步前奏12.png"/></div></div></li></ul><h3 id="漫步"><a href="#漫步" class="headerlink" title="漫步"></a>漫步</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/许巍/漫步01.jpg"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/许巍/漫步02.jpg"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/许巍/漫步03.jpg"/></div></div><hr><h2 id="李志"><a href="#李志" class="headerlink" title="李志"></a>李志</h2><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/1.jpg"/></div></div><h3 id="下雨"><a href="#下雨" class="headerlink" title="下雨"></a>下雨</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/下雨01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/下雨02.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/下雨03.png"/></div></div><h3 id="这个世界会好吗"><a href="#这个世界会好吗" class="headerlink" title="这个世界会好吗"></a>这个世界会好吗</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/这个世界会好吗01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/这个世界会好吗02.png"/></div></div><h3 id="天空之城"><a href="#天空之城" class="headerlink" title="天空之城"></a>天空之城</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/天空之城01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/天空之城02.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/天空之城03.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/天空之城11.jpg"/></div></div><h3 id="梵高先生"><a href="#梵高先生" class="headerlink" title="梵高先生"></a>梵高先生</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/梵高先生01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/梵高先生02.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/梵高先生03.png"/></div></div><h3 id="和你在一起"><a href="#和你在一起" class="headerlink" title="和你在一起"></a>和你在一起</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/和你在一起01.jpg"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/和你在一起02.jpg"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/和你在一起03.jpg"/></div></div><h3 id="山阴路的夏天"><a href="#山阴路的夏天" class="headerlink" title="山阴路的夏天"></a>山阴路的夏天</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/山阴路的夏天01.jpg"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/山阴路的夏天02.jpg"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/山阴路的夏天03.jpg"/></div></div><h3 id="关于郑州的记忆"><a href="#关于郑州的记忆" class="headerlink" title="关于郑州的记忆"></a>关于郑州的记忆</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/关于郑州的记忆01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/关于郑州的记忆02.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/关于郑州的记忆11.jpg"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/关于郑州的记忆12.jpg"/></div></div><h3 id="人民不需要自由"><a href="#人民不需要自由" class="headerlink" title="人民不需要自由"></a>人民不需要自由</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/人民不需要自由01.jpg"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/李志/人民不需要自由02.jpg"/></div></div><hr><h2 id="宋冬野"><a href="#宋冬野" class="headerlink" title="宋冬野"></a>宋冬野</h2><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/1.jpg"/></div></div><h3 id="安河桥"><a href="#安河桥" class="headerlink" title="安河桥"></a>安河桥</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/安河桥01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/安河桥02.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/安河桥11.jpg"/></div></div><h3 id="斑马斑马"><a href="#斑马斑马" class="headerlink" title="斑马斑马"></a>斑马斑马</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/斑马斑马01.jpg"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/斑马斑马02.jpg"/></div></div><h3 id="莉莉安"><a href="#莉莉安" class="headerlink" title="莉莉安"></a>莉莉安</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/莉莉安01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/莉莉安02.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/莉莉安03.png"/></div></div><h3 id="董小姐"><a href="#董小姐" class="headerlink" title="董小姐"></a>董小姐</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/董小姐01.gif"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/董小姐02.gif"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/董小姐03.gif"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/董小姐04.gif"/></div></div><h3 id="鸽子"><a href="#鸽子" class="headerlink" title="鸽子"></a>鸽子</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/鸽子01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/鸽子02.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/鸽子03.png"/></div></div><h3 id="年年"><a href="#年年" class="headerlink" title="年年"></a>年年</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/年年01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/年年02.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/年年03.png"/></div></div><h3 id="六层楼"><a href="#六层楼" class="headerlink" title="六层楼"></a>六层楼</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/六层楼01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/六层楼02.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/六层楼03.png"/></div></div><h3 id="关忆北"><a href="#关忆北" class="headerlink" title="关忆北"></a>关忆北</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/关忆北01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/关忆北02.png"/></div></div><h3 id="连衣裙"><a href="#连衣裙" class="headerlink" title="连衣裙"></a>连衣裙</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/连衣裙01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/连衣裙02.png"/></div></div><h3 id="卡比巴拉得海"><a href="#卡比巴拉得海" class="headerlink" title="卡比巴拉得海"></a>卡比巴拉得海</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/卡比巴拉得海01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/卡比巴拉得海02.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/宋冬野/卡比巴拉得海03.png"/></div></div><hr><h2 id="贰佰"><a href="#贰佰" class="headerlink" title="贰佰"></a>贰佰</h2><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/贰佰/1.jpg"/></div></div><h3 id="玫瑰"><a href="#玫瑰" class="headerlink" title="玫瑰"></a>玫瑰</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/贰佰/玫瑰01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/贰佰/玫瑰02.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/贰佰/玫瑰03.png"/></div></div><h3 id="嘿抬头"><a href="#嘿抬头" class="headerlink" title="嘿抬头"></a>嘿抬头</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/贰佰/嘿抬头01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/贰佰/嘿抬头02.png"/></div></div><h3 id="狗日的青春"><a href="#狗日的青春" class="headerlink" title="狗日的青春"></a>狗日的青春</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/贰佰/狗日的青春01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/贰佰/狗日的青春02.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/贰佰/狗日的青春03.png"/></div></div><h3 id="我在太原和谁一起假装悲伤"><a href="#我在太原和谁一起假装悲伤" class="headerlink" title="我在太原和谁一起假装悲伤"></a>我在太原和谁一起假装悲伤</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/贰佰/我在太原和谁一起假装悲伤01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/贰佰/我在太原和谁一起假装悲伤02.png"/></div></div><hr><h2 id="赵照"><a href="#赵照" class="headerlink" title="赵照"></a>赵照</h2><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/赵照/1.jpg"/></div></div><h3 id="当你老了"><a href="#当你老了" class="headerlink" title="当你老了"></a>当你老了</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/赵照/当你老了01.jpeg"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/赵照/当你老了02.jpeg"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/赵照/当你老了03.jpeg"/></div></div><hr><h2 id="逃跑计划"><a href="#逃跑计划" class="headerlink" title="逃跑计划"></a>逃跑计划</h2><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/逃跑计划/1.jpg"/></div></div><h3 id="夜空中最亮的星"><a href="#夜空中最亮的星" class="headerlink" title="夜空中最亮的星"></a>夜空中最亮的星</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/逃跑计划/夜空中最亮的星01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/逃跑计划/夜空中最亮的星02.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/逃跑计划/夜空中最亮的星03.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/逃跑计划/夜空中最亮的星04.png"/></div></div><hr><h2 id="陈奕迅"><a href="#陈奕迅" class="headerlink" title="陈奕迅"></a>陈奕迅</h2><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/陈奕迅/1.jpg"/></div></div><h3 id="不要说话"><a href="#不要说话" class="headerlink" title="不要说话"></a>不要说话</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/陈奕迅/不要说话01.jpg"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/陈奕迅/不要说话02.jpg"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/陈奕迅/不要说话03.jpg"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/陈奕迅/不要说话11.jpg"/></div></div><h3 id="你的背包"><a href="#你的背包" class="headerlink" title="你的背包"></a>你的背包</h3><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/陈奕迅/你的背包01.png"/></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/HanxuLiu/guitar-tabs/songs/陈奕迅/你的背包02.png"/></div></div><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub入门与实践.pdf</title>
      <link href="/posts/5441.html"/>
      <url>/posts/5441.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="《GitHub入门与实践》"><a href="#《GitHub入门与实践》" class="headerlink" title="《GitHub入门与实践》"></a>《GitHub入门与实践》</h2><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/HanxuLiu/books-pdf/Git/GitHub入门与实践.pdf" width="100%" height="550" type="application/pdf"></div><hr>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搞懂链接器4：大型项目的构建过程</title>
      <link href="/posts/659154a1.html"/>
      <url>/posts/659154a1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在讲解大型项目如何被构建之前，我们首先来讨论一个问题，有句话说的很好，梦想总是要有的，万一实现了呢，那么问题来了，要怎么实现呢，这里就涉及到了如何实现目标，</p><p>目标是如何实现的</p><p>其实很简单，本质上只有两点：</p><ul><li>知道最后想要的是什么</li><li>为此需要做些什么</li></ul><p>有时我们的目标可能不是简单的诸如每天跑五公里之类，比如像通过一门考试，学会一项技能这样的系统性工程。这时我们可能一下子不知道要做些什么，那么这就需要进行任务分解了，即这里的规则就是，把一个大的目标分解为一个个小的目标，如果对于其中一个小的目标还是不够具体，那么就继续将小目标进行分解，直到将每个小目标分解为如每天读懂两个章节，做完十个练习题之类很具体可以马上实施的任务为止。到这时，对于如何实现这个大的目标就很清晰了，只需要严格按照计划去实施就好了。比如对于考研，我们就可以列出如下的计划：</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730102100.png" alt="image-20210730102100140"></p><p>在考研这个例子中我们就按照上述规则将目标进行了分解，每个目标都按如下格式列出：</p><blockquote><p>  <strong><em>目标(target): 依赖什么\</em></strong></p><p>​        <strong><em>要怎么做\</em></strong></p></blockquote><p>如果“要怎么做”还不是一个具体的目标就继续分解，直到分解为类似进程这样的目标，因为像进程这样的目标已经有了具体的实现步骤。最后我们将各个已经实现的小目标汇集起来整个大的目标就实现了。</p><p>本质上，一个大型项目的构建过程与此类似。</p><p>Make</p><p>再大的项目最后生成的都是一个可执行文件，只要是可执行文件就需要依赖各种目标文件，动态库，静态库；静态库同样需要依赖其它目标文件，静态库；而动态库可能又依赖其它目标文件，动态库，静态库，知道了这些又该如何构建呢，我们可以利用上面目标划分的方法规划好构建最终的可执行文件需要哪些原材料，这些原材料又是如何获取的。有了这些规划后，我们就可以依次编译出一些小的目标文件，将这些目标文件链接成静态库，动态库以方便使用。然后再一步步连接目标文件以及各种库从而形成更大的库，最后将几个必要库以及目标文件进行链接从而生成最终的可执行文件。</p><p>程序员先驱们确实就是使用这种现在看起来非常原始非常古老的方法进行程序编写的，每个目标文件以及库都是自己手动编译链接出来，然后再将它们链接成更大的库，直到最后生成可执行文件。</p><p>这种方法看上去非常简单，但是缺点也很明显，那就是非常繁琐，一旦某个源文件进行了改动，所有依赖此文件的库都需要重新编译链接，手工来完成这项工作是极其枯燥且容易出错的。为解决这个问题，天才的程序员们想出了一个小工具，没错就是make，从此编译链接这个过程就被make自动化了，程序员得以从繁琐的编译链接中解放出来，使用make时我们只需要编写规则，也就是告诉make最终的可执行文件依赖什么，为此需要做些什么，这些规则类似于上面的目标分解，当编写好这些规则后，然后简单的执行一个命令也就是make就可以了。如果某个源文件被修改了，也只需要简单的重新执行一下make命令，因为整个过程的规则并没有改变，而make也会很聪明的只编译链接那些需要更新的目标文件，库，并重新进行可执行文件的生成。对于那些没有改动的源文件，make不会重新编译它们。</p><p>make中每一条规则与前面的目标划分非常相似，make的规则是这样的：</p><blockquote><p><strong><em>target: prerequisites\</em></strong></p><p>​      <strong><em>recipe\</em></strong></p></blockquote><p>target也就类似于我们的一个目标；而prerequisites，即先决条件，也就是依赖什么；recipe，这个就更形象了，即菜谱，也就是上面的要怎么做。make中的规则保存在了叫做Makefile的文件当中(没错，这个文件的名字就叫做Makefile)，当运行make命令时，make程序会自动找到当前路径下的Makefile，然后开始执行里面的规则。</p><p>有些同学可能为此感到疑惑，这里的Makefile其实就是脚本，而make读取这个脚本然后根据里面的内容来执行命令，而对于make大家也不要觉得很神奇，make也是一个普通程序，和我们平时使用的程序没什么区别。确定好了make需要执行的脚本的名字，这样在运行make命令时就少打了几个单词，假如用户可以自定义make的执行脚本名字，比如用户创建了一个脚本叫做foo，那么执行make的时候就需要多打一个单词“make foo”，所以干脆就直接确定好了脚本的名字就叫Makefile，这样在运行命令时只需要打一个单词make就可以了。</p><p>这里举个简单的例子，比如我们写了一个helloworld程序，将源文件命名为了helloworld.c，我们想把该源文件编程成一个叫做hw的可执行文件，那么一个最简单的Makefile就可以写成这样：</p><blockquote><p><em>hw: helloworld.o</em></p><p>​    <em>gcc helloworld.o -o hw</em></p><p><em>helloworld.o : helloworld.c</em></p><p>​    <em>gcc -c helloworld.c</em></p></blockquote><p>在这里最终的可执行文件hw依赖目标文件helloworld.o，那么假设我们现在已经有helloworld.o了就可以利用命令gcc helloworld.o -o hw生成我们需要的可执行文件了。那么helloworld.o又该如何获得呢？我们看第二条规则，helloworld.o依赖helloworld.c，因为helloworld.c已经写好了，所以可以直接用命令gcc -c helloworld.c来生成。这样整个目标就达成了。</p><p>本质上现在我们使用的各种集成开发环境(IDE)，其自动化编译工具背后的原理和make是一样的，比如我们在使用Visual Studio时从来没有关心过每个文件是如何被编译链接的，这些IDE都为我们代劳了。但是在比如Linux环境下进行开发时，这个过程依然是需要程序员了解的。</p><p>现在让我们来回答本节提出的问题，也就是大型项目是如何被构建的。</p><p>构建大型项目</p><p>大型项目中通常会有成百上千甚至上万个源文件，这些源文件统一放在了一个文件夹中方便管理。典型的项目如图所示，圆形代表源文件，其它为文件夹。注意这里仅仅为说明问题，各个公司团队都有自己的代码组织以及命名方式，而且真实项目要比该图复杂的多，但是本质上这里的讨论适用于其它情况。</p><p>源码组织方式</p><p>通常项目的组织方式如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730102125.png" alt="image-20210730102125821"></p><p>项目源码会被放置在src当中，这个例子当中src下有两个文件夹，lib以及app，lib用于存放一些工具性的代码，比如这里列举的网络通信以及字符串处理模块，通常lib下的代码会被编译成各种库，方便app使用。app中就是各种需要可执行文件(程序)的代码了。通常像这里的lib以及app都会有专门的团队来负责。更大一些的项目，每个lib下的子目录比如这里的net，strings都会有专门的团队来负责以方便项目的模块化管理。</p><p>从这里可以看出一般项目通常会按模块将源文件放入相应的文件夹下进行分类，我们在上一节中简单介绍了make的用法，但是那里仅仅需要编译一个源文件helloworld.c。对于如上图所示的项目，像make这一类的编译工具又该如何处理呢？</p><p>make的嵌套执行能力可以解决这个问题。比如对于模块net，你可以为net模块写一个单独的Makefile，该Makefile只用于编译net下的源文件，具体的脚本如下所示，只需要简单的两行。</p><p><em>network:</em></p><p>​    <em>cd net &amp;&amp; make</em></p><p><em></em></p><p>这句话的意思是告诉make，要想编译网络模块(network)需要进到net文件夹并且执行make命令，当make进入到net文件夹开始执行make时，net下的Makefile就开始被执行了。通过这样一个简单的命令就可以实现make的嵌套执行了。make的这项特性使得每个模块都可以当做独立项目进行维护。</p><p>编译工具的这项功能，方便了项目的模块化管理。使得项目中每个模块都可以有独立的编译脚本，比如使用make进行编译的话，那么每个模块中都会有单独的Makefile，比如在文件夹net，strings中都有自己的Makefile。如上图中蓝色部分，其中白色部分为源文件，更清晰的关于Makefile的组织方式如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730102155.png" alt="image-20210730102155778"></p><p>这些脚本中定义了如何编译该模块，以及编译该模块需要依赖什么。这些模块的父目录也就是lib文件夹下同样也有自己的Makefile，lib下的Makefile会收集各个子模块的编译结果，然后将其链接成各种库。而对于app下面的子目录来说，这些子目录中就是各个可执行文件的源码了，比如这里的wechat文件下就是可执行程序微信的源码了，微信中可能会用到lib下提供的功能，那么对于wechat中的Makefile来说，只需要简单的加入对lib中所需要的库的依赖就可以了。wechat的父目录app中同样也有Makefile，这里的Makefile就相对简单了，只需要依次执行QQ，wechat中的Makefile就可以了，因此在src目录下简单的运行make命令，所有app比如QQ和wechat就都被编译出来了。</p><p>接下来我们详细的讲解一下这个过程。请注意一点，接下来讲解的make执行过程仅仅是可能的一种实现方式，但是这个示例已足够说明项目的构建过程。</p><p>make的执行过程</p><p>在上面的示例中src下的Makefile是整个编译过程的入口，因此我们进入src文件夹开始执行make命令。</p><p>（1）在src目录下，make首先读取src下的Makefile，./src/Makefile非常简单，该文件仅仅告诉make需要去app目录下执行make命令。</p><p>（2）make来./src/app目录下，开始读取该目录下的Makefile，该文件定义了编译出QQ，微信的规则，make首先执行编译QQ的规则，该规则告诉make编译QQ则需要到./src/app/QQ目录并执行make命令。</p><p>（3）make来到./src/app/QQ目录下，开始读取该目录下的Makefile，该文件定义了编译QQ程序 的规则，make开始执行这些规则，其中一项规则需要依赖网络模块的库，同时该规则告诉了make如果想得到该网络库则需要进入到./src/lib下执行make命令。</p><p>（4）make来到./src/lib目录下，开始读取该目录下的Makefile，该文件定义了编译出网络库，字符串处理库的规则，make首先执行编译网络库的规则，该规则告诉make如果想得到该网络库则需要进入到./src/lib/net下执行make命令。</p><p>（5）make来到./src/lib/net目录下，开始读取该目录下的Makefile，该文件定义了编译网络库的规则，编译网络库不再依赖任何其它库，make终于可以安心的开始工作不用再跳来跳去了，make开始执行该目录下的Makefile，将一个个源文件编译成目标文件，最后将这些目标文件链接成了静态库(当然也可以是动态库，依赖编译规则)。make在./src/lib/net完成任务后跳转回./src/lib，因为make会记住自己是从哪个目录跳转到当前目录的。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730102227.png" alt="image-20210730102227439"></p><p>（6）make再次回到./src/lib下，因为make执行完了网络库的编译规则，因此继续往下执行，也就是字符串库的编译规则，该规则告诉make如果想得到字符串库则需要进入到src/lib/strings下执行make命令。</p><p>（7）make来到./src/lib/strings目录项，开始读取该目录下的Makefile，该文件定义了编译字符串库的规则，同样，编译字符串库不需要依赖任何其它库，make开始执行该目录下的Makefile，将一个个源文件编译成目标文件，最后将这些目标文件链接成了静态库(当然也可以是动态库)。make在./src/lib/strings下完成任务后跳转回./src/lib，因为make就是从这个目录跳转到./src/lib/strings的。</p><p>（8）make回到./src/lib，如果该目录下的Makefile还有其它编译规则，则继续上面的过程，如果没有其它规则，则该目录下的编译任务执行完成，make返回到./src/app/QQ。</p><p>（9）make回到./src/app/QQ下继续执行被中断的规则，这时QQ所依赖的库都已经编译完成，因此make可以直接进行链接了，QQ程序编译链接完成。make返回到./src/app。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730102246.png" alt="image-20210730102246124"></p><p>（10）make来到./src/app下继续执行被中断的规则，make开始执行微信程序的编译规则，这里和QQ的编译是一样的，唯一一点即如果微信也需要依赖网络库和字符串库，那么当make调转到./src/lib下会发现这些库已经生成了，因此直接返回。当make执行完./src/app下的编译规则后，QQ和微信程序就都编译完成了。make返回到./src后，发现该目录下的Makefile执行完毕，因此make程序退出，整个编译过程完成。</p><p>如果你对这个过程还不是很清楚的话，我们用一个游戏的类比来加深你对整个过程的理解。</p><p>相信很多同学都玩过RPG(角色扮演)游戏，比如仙剑奇侠传，阴阳师。你可以把大型项目的编译过程想象成玩RPG游戏，这类的游戏通常都会有一个主线，若干支线，通常主线的每一关都需要你去某个支线完成任务，例如拿到宝物之类，当你完成支线任务拿到宝物后，你才能回到主线进入到下一关。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730102319.png" alt="image-20210730102319657"></p><p>在这里，make程序就好比玩家，游戏里的任务就好比编译脚本Makefile，主线任务就好比app下的Makefile，支线任务就好比编译app所依赖的库或者目标文件，比如这里的lib下的Makefile。</p><p>首先玩家make进入主线，也就是app下，读取主线需要完成的任务(app下的Makefile)，主线任务告诉玩家make通过其中某一关(比如编译出可执行文件app1)依赖一个支线任务，拿到宝物(app1所依赖的lib下的某个库)，这时玩家make开始去支线场景(进入lib文件夹)，然后读取支线任务(读取lib下的Makefile)，make开始在lib下打怪升级(开始编译链接lib下源文件并生成相应的库)，当make完成支线任务拿到宝物(lib中编译出来的库)回到主线任务(回到app下Makefile因跳转到lib被中断的接下来的编译脚本)后，才可以继续接下来的通关。</p><p>有的同学可能已经发现了，像上面的这种编译实现方式其实是比较混乱的，既然我们make给了我们可以将每个模块当做独立项目进行编译的能力，那么对于非应用程序的代码比如这里的src/lib，我们可以提前编译出来，最后再来编译src/app下的代码，这样当依赖某个库时无需再去将该库编译出来。使用上面的编译顺序是为了说明make的构建方式是多样的，实际上使用make这一类的工具你可以使用任何你想要的编译顺序进行项目构建，本质上写Makefile就是写程序，这些程序告诉make该如何构建出最后的可执行文件，至于构建程序该以什么样的顺序构建出可执行文件，一切由你做主。这就是make这类编译工具的灵活以及强大之处。</p><p>还有一点需要注意的就是，真实的项目中会有很多模块是相互独立的，即这些模块互不依赖，为加快编译速度，make支持并行编译以充分利用多核的处理能力。</p><p>关于大型项目的构建到这里就讲解的差不多了，我们可以看到大型项目的构建其实和我们平时完成一个目标是类似的，先有一个大的目标并将其分解为一个个比较容易实现的小目标，当所有的小目标完成后我们的目的也就是实现了。本质上大型项目的构建与此类似。</p>]]></content>
      
      
      <categories>
          
          <category> 编译器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链接器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搞懂链接器3：重定位</title>
      <link href="/posts/6748ea9.html"/>
      <url>/posts/6748ea9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>程序的运行过程就是CPU不断的从内存中取出指令然后执行执行的过程，对于函数调用来说比如我们在C/C++语言中调用简单的加法函数add，其对应的汇编指令可能是这样的:</p><blockquote><p> <em>call 0x4004fd</em></p></blockquote><p>其中0x4004fd即为函数add在内存中的地址，当CPU执行这条语句的时候就会跳转到0x4004fd这个位置开始执行函数add对应的机器指令。</p><p>再比如我们在C语言中对一个全局变量g_num不断加一来进行计数，其对应的汇编指令可能是这样的：</p><blockquote><p> <em>mov 0x400fda %eax</em></p><p> <em>add $0x1 %eax</em></p></blockquote><p>这里的意思是把内存中 0x400fda 这个地址的数据放到寄存器当中，然后将寄存器中的数据加一，在这里g_num这个全局变量的内存地址就是0x400fda。</p><p>好奇的同学可能会问，那这些函数以及数据的内存地址是怎么来的呢？</p><p>确定程序运行时的内存地址就是接下来我们要讲解的重点内容，这里先给出答案，可执行文件中代码以及数据的运行时内存地址是链接器指定的，也就是上面示例中add的内存地址0x4004fd其是链接器指定的。确定程序运行时地址的过程就是这里重定位(Relocation)。</p><p>为什么这个过程叫做重定位呢，之所以叫做重定位是因为确定可执行文件中代码和数据的运行时地址是分为两个阶段的，在第一个阶段中无法确定这些地址，只有在第二个阶段才可以确定，因此就叫做重定位。接下来让我们来看看这两个阶段，合并同类型段以及引用符号的重定位。</p><p>编译器的工作</p><p>让我们回忆一下前几节的内容，源文件首先被编译器编译生成目标文件，目标文件种有三段内容：数据段、代码段以及符号表，所有的函数定义被放在了代码段，全局变量的定义放在了数据段，对外部变量的引用放到了符号表。</p><p>编译器在将源文件编译生成目标文件时可以确定一下两件事：</p><ul><li>定义在该源文件中函数的内存地址</li><li>定义在该源文件中全局变量的内存地址</li></ul><p>注意这里的内存地址其实只是相对地址，相对于谁的呢，相对于自己的。为什么只是一个相对地址呢？因为在生成一个目标文件时编译器并不知道这个目标文件要和哪些目标文件进行链接生成最后的可执行文件，而链接器是知道要链接哪些目标文件的。因此编译器仅仅生成一个相对地址。</p><p>而对于引用类的变量，也就是在当前代码中引用而定义是在其它源文件中的变量，对于这样的变量编译器是无法确定其内存地址的，这不是编译器需要关心的，确定引用类变量的内存地址是链接器的任务，链接器在进行链接时能够确定这类变量的内存地址。因此当编译器在遇到这样的变量时，比如使用了外部定义的函数时，其在目标文件中对应的机器指令可能是这样的:</p><blockquote><p><em>call 0x000000</em></p></blockquote><p>也就是说对于编译器不能确定的地址都这设置为空(0x000000)，同时编译器还会生成一条记录，该记录告诉链接器在进行链接时要修正这条指令中函数的内存地址，这个记录就放在了目标文件的.rel.text段中。相应的如果是对外部定义的全局变量的使用，则该记录放在了目标文件的.rel.data段中。即链接器需要在链接过程中根据.rel.data以及.rel.text来填好编译器留下的空白位置</p><p>(0x000000)。因此在这里我们进一步丰富目标文件中的内容，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730101533.png" alt="image-20210730101533085"></p><p>生成目标文件后，编译器完成任务，编译器确定了定义在该源文件中函数以及全局变量的相对地址。对于编译器不能确定的引用类变量，编译器在目标文件的.rel.text以及.rel.data段中生成相应的记录告诉链接器要修正这些变量的地址。</p><p>接下来就是链接器的工作了。</p><p>链接器的工作</p><p>我们在静态库下可执行文件的生成一节中知道，链接器会将所有的目标文件进行合并，所有目标文件的数据段合并到可执行文件的数据段，所有目标文件的代码段合并到可执行文件的代码段。当所有合并完成后，各个目标文件中的相对地址也就确定了。因此在这个阶段，链接器需要修正目标文件中的相对地址。</p><p>在这里我们以合并目标文件中的数据段为例来说明链接器是如何修正目标文件的相对地址的，合并代码段时修正相对位置的原理是一样的。</p><p>我们假设链接器需要链接三个目标文件：</p><ul><li>目标文件一：该文件数据段定义了两个变量apple和banana，apple的长度为2字节，banana的长度4字节，因此目标文件一的数据段长度为6字节。从图中也可以看出apple的内存地址为0，也就是相对地址，即apple这个变量在目标文件一的地址是0，banana的地址为2。</li><li>目标文件二：该文件的数据段比较简单，只定义了一个变量orange，其长度为2，因此该目标文件的数据段长度为2。</li><li>目标文件三：该文件的数据段定义了三个变量grape、mango以及limo，其长度分别为4字节、2字节以及2字节，因此该目标文件的数据段长度为8字节。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730101619.png" alt="image-20210730101619806"></p><p>链接器在链接三个目标文件时其顺序是依次链接的，链接完成后：</p><ul><li>目标文件一：该数据段的起始地址为0，因此该数据段中的变量的最终地址不变。</li><li>目标文件二：由于目标文件一的数据段长度为6，因此链接完成后该数据段的起始地址为6(这里的起始地址其实就是偏移offset)，相应的orange的最终内存地址为0+offset即6。</li><li>目标文件三：由于前两个数据段的长度为8，因此该数据段的起始地址为8(即offset为8)，因此所有该数据段中的变量其地址都要加上该offset，即grape的最终地址为8，即0+offset，mango的最终地址为4+offset即12，limo的最终地址为6+offset即14。</li></ul><p>从这个过程中可以看到，数据段中的相对地址是通过这个公式来修正的，即：</p><blockquote><p>相对地址 + offset(偏移) = 最终内存地址</p></blockquote><p>而每个段的偏移只有在链接完成后才能确定，因此对相对地址的修正只能由链接器来完成，编译器无法完成这项任务。</p><p>当所有目标文件的同类型段合并完毕后，数据段和代码段中的相对地址都被链接器修正为最终的内存位置，这样所有的变量以及函数都确定了其各自位置。</p><p>至此，重定位的第一阶段完成。接下来是重定位的第二阶段，即引用符号的重定位。</p><p>相对地址是编译器在编译过程中确定了，在链接器完成后被链接器修正为最终地址，而对于编译器没有确定的所引用的外部函数以及变量的地址，编译器将其记录在了.rel.text和.rel.data中。</p><p>由于在第一阶段中，所有函数以及数据都有了最终地址，因此重定位的第二阶段就相对简单了。我们知道编译器引用外部变量时将机器指令中的引用地址设置为空(比如call 0x000000)，并将该信息记录在了目标文件的.rel.text以及.rel.data段中。因此在这个阶段链接器依次扫描所有的.rel.text以及.rel.data段并找到相应变量的最终地址(这些位置都已在第一阶段确定)，并将机器指令中的0x000000修正为所引用变量的最终地址就可以了。</p><p>到这里链接器的重定位就讲解的这里，作为程序员一般很少会有问题出现在重定位阶段，因此这个阶段对程序员相对透明。请同学们注意一点，这里的分析仅限于目标文件的静态链接。我们知道静态链接下，链接器会将需要的代码和数据都合并到可执行文件当中，因此需要确定代码和数据的最终位置。而对于动态链接库来说情况则有所不同，动态链接库可以同时被多个进程使用，如果动态链接库的机器指令中不可以存在引用变量的最终位置，否则在被多个进程使用时会出现一个进程中使用的数据被其它进程修改。因此动态库下的机器指令都是PIC代码，即位置无关代码(Position-Independent Code)。关于PIC的机制原理就不在这里阐述了，对此感兴趣的同学可以关注微信公众号，码农的荒岛求生，我会在那里来讲解。</p><p>问题：为什么链接器能确定运行时地址</p><p>我们知道只有把可执行文件加载到内存当中程序才可以开始运行。不同的程序会被加载到内存的不同位置。我们从前两节的过程中可以看出，链接器完全没有考虑不同的程序会被加载不同的内存位置被执行。比如对于一个可执行文件我们分别运行两次，如下图所示，因为两个程序数据段变量的地址是一样的，那么程序一的数据会不会被程序二修改呢？</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730101648.png" alt="image-20210730101648724"></p><p>如果你去试一试的话就会发现显然不会有这种问题的。而当可执行文件加载到内存的时候也不会根据程序加载的起始地址再去修改可执行文件中变量的地址(这样就启动速度就太慢了)，那么操作系统又是如何能做到基于同一个可执行文件的两个程序能在各自的内存空间中运行而不相互干扰呢，链接器在可执行文件中确定的到底是不是程序最终的运行地址呢，我会在后面的文章当中给出答案，欢迎同学们关注微信公共账号码农的荒岛求生获取更多内容。</p>]]></content>
      
      
      <categories>
          
          <category> 编译器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链接器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搞懂链接器2：库与可执行文件的生成</title>
      <link href="/posts/7173be3f.html"/>
      <url>/posts/7173be3f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>链接器可以操作的最小单元为目标文件，也就是说无论是静态库、动态库、可执行文件，都是基于目标文件构建出来的。目标文件就好比乐高积木中最小的零部件。</p><p>给定目标文件以及链接选项，链接器可以生成两种库，分别是静态库以及动态库，如图所示，给定同样的目标文件，链接器可以生成两种不同类型的库，接下来我们分别介绍。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730085852.png" alt="库生成示意图"></p><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>假设这样一个应用场景，基础设计团队设计了好多实用并且功能强大的工具函数，业务团队需要用到里面的各种函数。每次新添加其中一个函数，业务团队都要去找相应的实现文件并修改链接选项。使用静态库就可以解决这个问题。静态库在Windows下是以.lib为后缀的文件，Linux下是以.a为后缀的文件。</p><p>为解决上述问题，基础设计团队可以提前将工具函数集合打包编译链接成为静态库提供给业务团队使用，业务团队在使用时只要链接该静态库就可以了，每次新使用一个工具函数的时候，只要该函数在此静态库中就无需进行任何修改。</p><p>你可以简单的将静态库理解为由一堆目标文件打包而成， 使用者只需要使用其中的函数而无需关注该函数来自哪个目标文件（找到函数实现所在的目标文件是链接器来完成的，从这里也可以看出，不是所有静态库中的目标文件都会用到，而是用到哪个链接器就链接哪个）。静态库极大方便了对其它团队所写代码的使用。</p><h2 id="静态连接"><a href="#静态连接" class="headerlink" title="静态连接"></a>静态连接</h2><p>静态库是链接器通过静态链接将其和其它目标文件合并生成可执行文件的，如下图一所示，而静态库只不过是将多个目标文件进行了打包，在链接时只取静态库中所用到的目标文件，因此，你可以将静态链接想象成如下图2所示的过程。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730090423.png" alt="image-20210730090423254"></p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730090432.png" alt="image-20210730090431921"></p><p>静态库是使用库的最简单的方法，如果你想使用别人的代码，找到这些代码的静态库并简单的和你的程序链接就可以了。静态链接生成的可执行文件在运行时不依赖任何其它代码，要理解这句话，我们需要知道静态链接下，可执行文件是如何生成的。</p><h2 id="静态链接下可执行文件的生成"><a href="#静态链接下可执行文件的生成" class="headerlink" title="静态链接下可执行文件的生成"></a>静态链接下可执行文件的生成</h2><p>在上一节中我们知道，可以将静态链接简单的理解为链接器将使用到的目标文件集合进行拼装，拼装之后就生成了可执行文件，同时我们在目标文件里有什么这一节中知道，目标文件分成了三段，代码段，数据段，符号表，那么在静态链接下可执行文件的生成过程如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730090553.png" alt="image-20210730090553480"></p><p>从上图中我们可以看到可执行文件的特点：</p><ul><li>可执行文件和目标文件一样，也是由代码段和数据段组成。</li><li>每个目标文件中的数据段都合并到了可执行文件的数据段，每个目标文件当中的代码段都合并到了可执行文件的代码段。</li><li>目标文件当中的符号表并没有合并到可执行文件当中，因为可执行文件不需要这些字段。</li></ul><p>可执行文件和目标文件没有什么本质的不同，可执行文件区别于目标文件的地方在于，可执行文件有一个入口函数，这个函数也就是我们在C语言当中定义的main函数，main函数在执行过程中会用到所有可执行文件当中的代码和数据。而这个main函数是被谁调用执行的呢，答案就是操作系统(Operating System)，这也是后面文章当中要重点介绍的内容。</p><p>现在你应该对可执行文件有一个比较形象的认知了吧。你可以把可执行文件生成的过程想象成装订一本书，一本书中通常有好多章节，这些章节是你自己写的，且一本书不可避免的要引用其它著作。静态链接这个过程就好比不但要装订你自己写的文章，而且也把你引用的其它人的著作也直接装订进了你的书里，这里不考虑版权问题 :)，这些工作完成后，只需要按一下订书器，一本书就制作完成啦。</p><p>在这个比喻中，你写的各个章节就好比你写的代码，引用的其它人的著作就好比使用其它人的静态库，装订成一本书就好比可执行文件的生成。</p><p>静态链接是使用库的最简单最直观的形式， 从静态链接生成可执行文件的过程中可以看到，静态链接会将用到的目标文件直接合并到可执行文件当中，想象一下，如果有这样的一种静态库，几乎所有的程序都要使用到，也就是说，生成的所有可执行文件当中都有一份一模一样的代码和数据，这将是对硬盘和内存的极大浪费，假设一个静态库为2M，那么500个可执行文件就有1G的数据是重复的。如何解决这个问题呢，答案就是使用动态库。</p><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p>在前三小节中我们了解了静态库、静态链接以及使用静态链接下可执行文件是如何生成的。接下来我们讲解一下动态库，那么什么是动态库？</p><p><code>动态库(Dynamic Library)</code>，又叫<code>共享库(Shared Library)</code>，动态链接库等，在Windows下就是我们常见的大名鼎鼎的DLL文件了，Windows系统下大量使用了动态库。在Linux下动态库是以.so为后缀的文件，同时以lib为前缀，比如进行数字计算的动态库Math，编译链接后产生的动态库就叫做libMath.so。从名字中我们知道动态库也是库，本质上动态库同样包含我们已经熟悉的代码段、数据段、符号表。只不过动态库的使用方式以及使用时间和静态库不太一样。</p><p>在前面几个小节中我们知道，使用静态库时，静态库的代码段和数据段都会直接打包copy到可执行文件当中，使用静态库无疑会增大可执行文件的大小，同时如果程序都需要某种类型的静态库，比如libc，使用静态链接的话，每个可执行文件当中都会有一份同样的libc代码和数据的拷贝，如图所示，动态库的出现解决了此类问题。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730090957.png" alt="image-20210730090956928"></p><p>动态库允许使用该库的可执行文件仅仅包含对动态库的引用而无需将该库拷贝到可执行文件当中。也就是说，同静态库进行整体拷贝的方式不同，对于动态库的使用仅仅需要可执行文件当中包含必要的信息即可，为了方便理解，你可以将可执行文件当中保存的必要信息仅仅理解为需要记录动态库的名字就可以了，如图所示，同静态库相比，动态库的使用减少了可执行文件的大小。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730091106.png" alt="image-20210730091106648"></p><p>从上面这张图中可以看出，动态库的使用解决了静态链接当中可执行文件过大的问题。我们在前几节中将静态链接生成可执行文件的过程比作了装订一本书，静态链接将引用的其它人的著作也装订到了书里，而动态链接可以想象成作者仅仅在引用的地方写了一句话，比如引用了《码农的荒岛求生》，那么作者就在引用的地方写上“此处参考《码农的荒岛求生》”，那么读者在读到这里的时候会自己去找到码农的荒岛求生这本书并查找相应的内容，其实这个过程就是动态链接的基本思想了。</p><p>到这里我们就可以回答之前提到过的问题了，helloworld程序中的printf函数到底是在哪里定义的，答案就是该函数是在libc.so当中定义的，Linux下编译链接生成可执行文件时会默认动态链接libc.so(Windows下也是同样的道理)，使用ldd命令就会发现每个可执行文件都依赖libc.so。因此虽然你从没有看到过printf的定义也可以正确的使用这个函数。</p><h2 id="动态链接。"><a href="#动态链接。" class="headerlink" title="动态链接。"></a>动态链接。</h2><p>我们知道静态库在编译链接期间就被打包copy到了可执行文件，也就是说静态库其实是在编译期间(Compile time)链接使用的，那么动态库又是在什么时候才链接使用的呢，动态链接可以在两种情况下被链接使用，分别是load-time dynamic linking(加载时动态链接) 以及 run-time dynamic linking(运行时动态链接)，接下来我们分别讲解一下。</p><ul><li>load-time dynamic linking(加载时动态链接)</li></ul><p>首先可能有的同学会问，什么是load-time呢，load_time翻译过来也就是加载时，那么什么又是加载呢？</p><p>我们大家都玩过游戏，当我们打开游戏的时候经常会跳出来一句话：“加载中，请稍后。。。”和这里的加载意思差不多。这里的加载指的是程序的加载，而所谓程序的加载就是把可执行文件从磁盘搬到内存的过程，因为程序最终都是在内存中被执行的。至于这个过程的详解内容我会在接下来的文章《加载器与可执行文件》一文中给大家详细讲解。在这里我们只需要简单的把加载理解为程序从磁盘复制到内存的过程，加载时动态链接就出现在这个过程。</p><p>当把可执行文件复制到内存后，且在程序开始运行之前，操作系统会查找可执行文件依赖的动态库信息(主要是动态库的名字以及存放路径)，找到该动态库后就将该动态库从磁盘搬到内存，并进行符号决议，如果这个过程没有问题，那么一切准备工作就绪，程序就可以开始执行了，如果找不到相应的动态库或者符号决议失败，那么会有相应的错误信息报告为用户，程序运行失败。比如Windows下比较常见的启动错误问题，就是因为没有找到依赖的动态库。Linux下同样会有类似信息提示用户程序启动失败。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730101021.png" alt="image-20210730101021256"></p><p>到这里，同学们应该对加载时动态链接应该有一个比较清晰的了解了。从总体上看，加载时动态链接可以分为两个阶段：阶段一，将动态库信息写入可执行文件；阶段二，加载可执行文件时依据动态库信息进行动态链接。</p><p><em>阶段一，将动态库信息写入可执行文件</em></p><p>在编译链接生成可执行文件时，需要将使用的动态库加入到链接选项当中，比如在Linux下引用libMath.so，就需要将libMath.so加入到链接选项当中（比如libMath.so放到了/usr/lib下，那么使用命令 gcc … -lMath -L/user/lib … 进行编译链接），所以使用这种方式生成的可执行文件中保存了依赖的动态库信息，在Linux可使用一个简单的命令ldd来查看。</p><p><em>阶段二：加载可执行文件时依据动态库信息进行动态链接</em></p><p>由于在阶段一生成的可执行文件中保存了动态库信息，当可执行文件加载完成后，就可以依据此信息进行中动态库的查找以及符号决议了。</p><p>通过这个过程也可以清楚的看到静态库和动态库的区别，使用动态库的可执行文件当中仅仅保留相应信息，动态库的链接过程被推迟到了程序启动加载时。</p><p>为加深你对加载时动态链接这个过程的理解，我们用一个类比来结束本小节，沿用前几节读书的例子，我们正在读的书中引用了《码农的荒岛求生》以及其它著作，那么加载时动态链接就好比，读者开始准备读这本书的时候（还没有真正的读）就把所有该书当中引用的资料著作都找齐放到一旁准备查看，当我们真正看到引用其它文献的地方时就可以直接在一旁找到该著作啦。在这个类比当中，开始读书前的准备工作就好比加载时动态链接。</p><p>接下来我们讲解第二种动态链接，run-time dynamic linking(运行时动态链接) 。</p><ul><li>run-time dynamic linking(运行时动态链接)</li></ul><p>上一小节中我们看到如果我们想使用加载时动态链接，那么在编译链接生成可执行文件阶段时需要告诉编译器所依赖的动态库信息，而run-time dynamic linking 运行时动态链接则不需要在编译链接时提供动态库信息，也就是说，在可执行文件被启动运行之前，可执行文件对所依赖的动态库信息一无所知，只有当程序运行到需要调用动态库所提供的代码时才会启动动态链接过程。</p><p>我们在上一节中介绍了load-time，也就是程序加载时，那么程序加载完成后就开始程序执行了，那么所谓run-time(运行时)指的就是从程序开始被CPU执行到程序执行完成退出的这段时间。</p><p>所以运行时动态链接这种方式对于“动态链接”阐释的更加淋漓尽致，因为可执行文件在启动运行之前都不知道需要依赖哪些动态库，只在运行时根据代码的需要再进行动态链接。同加载时动态链接相比，运行时动态链接将链接这个过程再次推迟往后推迟，推迟到了程序运行时。</p><p>由于在编译链接生成可执行文件的过程中没有提供所依赖的动态库信息，因此这项任务就留给了程序员，在代码当中如果需要使用某个动态库所提供的函数，我们可以使用特定的API来运行时加载动态库，在Windows下通过LoadLibrary或者LoadLibraryEx，在Linux下通过使用dlopen、dlsym、dlclose这样一组函数在运行时链接动态库。当这些API被调用后，同样是首先去找这些动态库，将其从磁盘copy到内存，然后查找程序依赖的函数是否在动态库中定义。这些过程完成后动态库中的代码就可以被正常使用了。</p><p>相对于加载时动态链接，运行时动态链接更加灵活，同时将动态链接过程推迟到运行时可以加快程序的启动速度。</p><p>为了和加载时动态链接作比对，我们继续使用上一小节当中读书的例子，加载时动态链接就好比在开始准备读一本书之前，将该书中所有引用到的资料文献找齐全，而运行时动态链接则不需要这个过程，运行时动态链接就好比直接拿起一本书开始看，看到有引用的参考文献时再去找该资料，找到后查看该文献然后继续读我们的书。从这个例子当中运行时动态链接更像是我们平时读书时的样子。</p><p>至此，两种动态链接的形式我们就都已经清楚了，接下来我们看一下动态链接下生成的可执行文件。</p><p>动态链接下可执行文件的生成</p><p>在静态链接下，链接器通过将各个目标文件的代码段和数据段合并拷贝到可执行文件，因此静态链接下可执行文件当中包含了所依赖的所有代码和数据，而与之对比的动态链接下可执行文件又是什么样的呢？</p><p>其实我们在动态库这一节中已经了解了动态链接下可执行文件的生成，即，在动态链接下，链接器并不是将动态库中的代码和数据拷贝到可执行文件中，而是将动态库的必要信息写入了可执行文件，这样当可执行文件在加载时就可以根据此信息进行动态链接了。为方便理解，我们将该信息仅仅认为是动态库都名字，真实情况当然要更复杂一点，这里我们以Linux下可执行文件即ELF文件为例（这一系列的文章重点关注最本质的原理思想，所以这里讨论的同样适合Windows下的可执行文件即exe文件）。</p><p>在前几节中我们将可执行文件简单的划分为了两段，数据段和代码段，在这里我们继续丰富可执行文件中的内容，如图所示，在动态链接下，可执行文件当中会新增两段，即dynamic段以及GOT（Global offset table）段，这两段内容就是是我们之前所说的必要信息。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210730101148.png" alt="image-20210730101148719"></p><p>dynamic段中保存了可执行文件依赖哪些动态库，动态链接符号表的位置以及重定位表的位置等信息。关于dynamic以及GOT段的作用限于篇幅就不重点阐述了。如果你对GOT段的具体作用很好奇的话，欢迎关注微信公共账号，码农的荒岛求生。</p><p>当加载可执行文件时，操作系统根据dynamic段中的信息即可找到使用的动态库，从而完成动态链接。</p><p>这里需要强调一点，在编译链接过程中，可以同时使用动态库以及静态库。这两种库的使用并不冲突，那么在这种情况下生成的可执行文件中，可执行文件中包含了静态库的数据和代码，以及动态库的必要信息。</p><p>至此，关于静态库，静态链接，动态库，动态链接就讲述到这，那么接下来的问题就是静态库和动态库都有什么样的优缺点。</p><h2 id="动态库vs静态库"><a href="#动态库vs静态库" class="headerlink" title="动态库vs静态库"></a>动态库vs静态库</h2><p>在计算机的历史当中，最开始程序只能静态链接，但是人们很快发现，静态链接生成的可执行文件存在磁盘空间浪费问题，因为对于每个程序都需要依赖的libc库，在静态链接下每个可执行文件当中都有一份libc代码和数据的拷贝，为解决该问题才提出动态库。</p><p>在前几节我们知道，动态链接下可执行文件当中仅仅保留动态库的必要信息，因此解决了静态链接下磁盘浪费问题。动态库的强大之处不仅仅于此，我们知道对于现代计算机系统，比如PC，通常会运行成百上千个程序（进程），且程序只有被加载到内存中才可以使用，如果使用静态链接那么在内存中就会有成百上千份同样的libc代码，这对于宝贵的内存资源同样是极大的浪费，而使用动态链接，内存中只需要有一份libc代码，所有的程序（进程）共享这一份代码，因此极大的节省了内存资源，这也是为什么动态库又叫共享库。</p><p>动态库还有另外一个强大之处，那就是如果我们修改了动态库的代码，我们只需要重新编译动态库就可以了而无需重新新编译我们自己的程序，因为可执行文件当中仅仅保留了动态库的必要信息，重新编译动态库后这些必要都信息是不会改变的（只要不修改动态库的名字和动态库导出的供可执行文件使用的函数），编译好新的动态库后只需要简单的替换原有动态库，下一次运行程序时就可以使用新的动态库了，因此动态库的这种特性极大的方便了程序升级和bug修复。我们平时使用都客户端程序，比如我们常用QQ，输入法，播放器，都利用了动态库的这一优点，原因就在于方便升级以bug修复，只需要更新相应的动态库就可以了。</p><p>动态库的优点不止于此，我们知道动态链接可以出现在运行时（run-time dynamic link），动态链接的这种特性可以用于扩展程序能力，那么如何扩展呢？你肯定听说过一样神器，没错，就是插件。你有没有想过插件是怎么实现的？实现插件时，我们只需要实现几个规定好的几个函数，我们的插件就可以运行了，可这是怎么做到的呢，答案就在于运行时动态链接，可以将插件以动态的都方式实现。我们知道使用运行时动态链接无需在编译链接期间告诉链接器所使用的动态库信息，可执行文件对此一无所知，只有当运行时才知道使用什么动态库，以及使用了动态库中哪些函数，但是在编译链接可执行文件时又怎么知道插件中定义了哪些函数呢，因此所有的插件实现函数必须都有一个统一的格式，程序在运行时需要加载所有插件（动态库），然后调用所有插件的入口函数（统一的格式），这样我们写的插件就可以被执行起来了。</p><p>动态库都强大优势还体现在多语言编程上。我们知道使用Python可以快速进行开发，但Python的性能无法同C/C++相比(因为Python是解释型语言，至于什么是解释型语言我会在后面码农的荒岛求生系列文章当中给大家详细讲解)，有没有办法可以兼具Python的快速开发能力以及C/C++的高性能呢，答案是可以的，我们可以将C/C++代码编译链接成动态库，这样python就可以直接调用动态库中的函数了。不但Python，Perl以及Java等都可以通过动态库的形式调用C/C++代码。动态库的使用使得同一个项目不同语言混合编程成为可能，而且动态库的使用更大限度的实现了代码复用。</p><p>了解了动态库的这么多优点，那么动态库就没有缺点吗，当然是有的。</p><p>首先由于动态库是程序加载时或运行是才进行链接的，因此同静态链接相比，使用动态链接的程序在性能上要稍弱于静态链接，这时因为对于加载时动态链接，这无疑会减慢程序都启动速度，而对于运行时链接，当首次调用到动态库的函数时，程序会被暂停，当链接过程结束后才可以继续进行。且动态库中的代码是地址无关代码（Position-Idependent Code，PIC），之所以动态库中的代码是地址无关代码是因为动态库又被成为共享库，所有的程序都可以调用动态库中的代码，因此在使用动态库中的代码时程序要多做一些工作，这里我们不再具体展开讲解到底程序多做了哪些工作，对此感兴趣当同学可以参考CSAPP（深入理解计算机系统）。这里我们说动态链接的程序性能相比静态链接稍弱，但是这里的性能损失是微乎其微的，同动态库可以带来的好处相比，我们可以完全忽略这里的性能损失，同学们可以放心的使用动态库。</p><p>动态库的一个优点其实也是它的缺点，即动态链接下的可执行文件不可以被独立运行（这里讨论的是加载时动态链接，load-time dynamic link），换句话说就是，如果没有提供所依赖的动态库或者所提供的动态库版本和可执行文件所依赖的不兼容，程序是无法启动的。动态库的依赖问题会给程序的安装部署带来麻烦，在Linux环境下尤其严重，以笔者曾参与开发维护的一个虚拟桌面系统为例，我们在开发过程中依赖的一些比较有名的第三方库默认不会随着安装包发布，这就会导致用户在较低版本Linux中安装时经常会出现程序无法启动的问题，原因就在于我们编译链接使用都动态库和用户Linux系统中都动态库不兼容。解决这个问题的方法通常有两种，一个是用户升级系统中都动态库，另一个是我们讲需要都第三方库随安装包一起发布，当然这是在取得许可的情况下。</p><p>在了解了动态库的优缺点后，接下来我们来看一下静态库。</p><p>静态链接是最古老也是最简单的链接技术。静态链接都最大优点就是使用简单，编译好的可执行文件是完备的，即静态链接下的可执行文件不需要依赖任何其它的库，因为静态链接下，链接器将所有依赖的代码和数据都写入到了最终的可执行文件当中，这就消除了动态链接下的库依赖问题，没有了库都依赖问题就意味着程序都安装部署都得到了极大都简化。请大家不要小看这一点，这对当今那些拥有海量用户的后端系统来说至关重要，比如类似微信这种量级的系统，其后端会部署在成千上万台机器上，这么多的机器其系统的安装部署以及升级会给运维带来极大挑战，而静态链接下的可执行文件由于不依赖任何库，因为部署非常方便，仅仅用一个新的可执行文件进行覆盖就可以了，因此极大的简化了系统部署以及升级。笔者之前所在的某电商广告后端系统就完全使用静态链接来简化部署升级。</p><p>而静态库的缺点相信大家都已经清楚了，那就是静态链接会导致可执行文件过大，且多个程序静态链接同一个静态库的话会导致磁盘浪费的问题。</p><p>到这里关于静态库和动态库的讨论就告一段落了，相信大家对于这两种链接类型都有了清晰都认知。接下来让我们稍作休息，开始链接器的下一个重要功能，重定位。</p>]]></content>
      
      
      <categories>
          
          <category> 编译器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链接器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搞懂链接器1：链接器定义和符号决议</title>
      <link href="/posts/600f79ea.html"/>
      <url>/posts/600f79ea.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="什么是链接器-Linker"><a href="#什么是链接器-Linker" class="headerlink" title="什么是链接器 (Linker)"></a>什么是链接器 (Linker)</h2><p>维基百科的定义为：</p><blockquote><p><code>链接器</code> （英语：Linker），是一个程序，将一个或多个由编译器或汇编器生成的目标文件外加库，链接为一个可执行文件。</p><p>在Unix-like系统上常用的链接器是GNU ld。目标文件是包括机器码和链接器可用信息的程序模块。简单的讲，链接器的工作就是解析未定义的符号引用，将目标文件中的占位符替换为符号的地址。链接器还要完成程序中各目标文件的地址空间的组织，这可能涉及重定位工作。大多数现代操作系统都提供动态链接和静态链接两种形式。</p></blockquote><p>为便于理解，可将链接器的定义分解成如下三点：</p><ul><li>首先是链接器的本质，链接器本质上也是一个程序，和我们经常使用的普通程序没什么不同。</li><li>接器的输入是编译器编译好的目标文件（object file）。</li><li>链接器的输出，链接器在将目标文件打包处理后，生成或者可执行文件，或者库，或者目标文件。</li></ul><p>从这个定义中能够看出，链接器的作用有点类似于我们经常使用的压缩软WinRAR (Linux下是tar)，压缩软件将一堆文件打包压缩成一个压缩文件，而链接器和压缩软件的区别在于链接器是将多个目标文件打包成一个文件而不进行压缩。</p><h2 id="符号决议-Symbol-Resolution"><a href="#符号决议-Symbol-Resolution" class="headerlink" title="符号决议 (Symbol Resolution)"></a>符号决议 (Symbol Resolution)</h2><p>所有的应用程序都是链接器将所需要的一个个简单的目标文件汇集起来形成的，可以将这个过程想象成拼图游戏，每个拼块就是一个简单的目标文件：</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210729223235.jpg" alt="拼图" style="zoom: 33%;" /></p><p>1、拼图游戏当中的每个拼块都依赖于其它拼块提供的拼接口，这就好比我们写的程序模块依赖于其它模块提供的编程接口，比如我们在list.c中实现了一种特定的链表数据结构，其它模块需要使用这种链表，这就是模块间的依赖。而链接器其中一项任务就是要确保提供给链接器进行链接的目标文件集合之间依赖是成立的（也就是说，不会出现在被依赖的模块中链接器找不到需要的接口），这就是要讲到的<code>符号决议</code>(Symbol Resolution)。</p><p>2、我们在拼图游戏当中通常都是将一整幅图按组成部位一部分一部分拼接好，然后将这些比较完整的大的组成部分拼接成最后一整幅图。这就好比链接器会首先将程序每个模块当中目标文件集合链接成库，然后再将各个库进行链接最终形成可执行程序。这就是可执行程序的生成过程。</p><p>3，链接器还有一项任务是无法用这个拼图游戏来类比的，但是这项重要的任务对程序员不可见，作为程序员几乎不会在这个过程遇到问题，这项任务就是<code>重定位</code>。</p><h3 id="链接器的工作过程"><a href="#链接器的工作过程" class="headerlink" title="链接器的工作过程"></a>链接器的工作过程</h3><p>通过拼图这个游戏的类比，我们给出链接器的工作过程：</p><ol><li>首先，链接器对给定的目标文件或库的集合进行符号决议以确保模块间的依赖是正确的。</li><li>其次，链接器将给定的目标文件集合进行拼接打包成需要的库或最终可执行文件。</li><li>最后，链接器对链接好的库或可执行文件进行重定位。</li></ol><p>接下来详细的讲解下每一个过程。首先讲解链接器的符号决议过程。在这个过程当中，链接器需要做的工作就是确保所有目标文件中的符号引用都有唯一的定义。要想理解这句话我们首先来看看一个典型的c文件里都有些什么。</p><h3 id="c源文件中都有什么"><a href="#c源文件中都有什么" class="headerlink" title="c源文件中都有什么"></a>c源文件中都有什么</h3><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210729220137.png" alt="c程序示例图"></p><p>如图所示是一个典型的c源文件，该文件中的变量可以划分为两类：</p><ul><li><p>全局变量：比如x_global_uninit，x_global_init，fn_c。只要程序没有结束运行，全局变量都可以随时使用。注意，用static修饰的全局变量比如y_global_uninit，其生命周期也等同于程序的运行周期，只是这种全局变量只能在所被定义的文件当中使用，对其它文件不可见。</p></li><li><p>局部变量：比如y_local_uninit，y_local_init，局部局部变量的生命周期和全局变量不同，局部变量变量只能在相应的函数内部使用，当函数调用完成后该函数中的局部变量也就无法使用了。因为局部变量只存在于函数运行时的栈帧当中，函数调用完成后相应的栈帧被自动回收(该内容涉及到程序运行时的内存模型)。</p></li></ul><h3 id="目标文件里有什么"><a href="#目标文件里有什么" class="headerlink" title="目标文件里有什么"></a>目标文件里有什么</h3><p>编译器的任务就是把人类可以理解的代码转换成机器可以执行的机器指令，源文件编译后形成对应的目标文件。源文件被编译后生成的目标文件中本质上只有两部分：</p><ul><li><p>代码部分：你可能会想，一个源文件中不都是代码吗，这里的代码指的是计算机可以执行的机器指令，也就是源文件中定义的所有函数。比如上图中定义的函数fn_b以及fn_c。</p></li><li><p>数据部分：源文件中定义的全局变量。如果是已经初始化后的全局变量，该全局变量的值也存在于数据部分。</p></li></ul><p>到目前为止，可以把一个目标文件简单的理解为由两部分组成，代码部分中保存的是CPU可以执行的机器指令，这些机器指令来自程序员所定义的函数，编译器将这些定义的函数翻译成机器指令并存放在目标文件的代码部分。数据部分存放的是机器指令所操作的数据。因此目前，可以简单的将目标文件理解为一个只有两部分的文件，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210729220213.png" alt="目标文件组成示意图"></p><p>你可能会好奇函数中定义的局部变量为什么没有放到目标文件的数据段当中，这是因为局部变量是函数私有的，局部变量只能在该函数内部使用而全局变量时没有这个限制的，所以函数私有的局部变量被放在了代码段中，作为机器指令的操作数。</p><p>编译器在编译过程中遇到外部定义的全局变量或函数时，只要编译器能找到相应的变量声明就会在心里默念“all is well， all is well(一切顺利)“，从这里可以看出编译器的要求还是很低的，至于所使用变量的定义编译器是不会费力去四处搜索，而是愉快的继续接下来的编译。注意，这里再次强调一下，编译器在遇到外部定义的全局变量或者函数时只要能在当前文件找到其声明，编译器就认为编译正确。而寻找使用变量定义的这项任务就被留给了链接器。链接器的其中一项任务就是要确定所使用的变量要有其唯一的定义。虽然编译器给链接器留了一项任务，但为了让链接器工作的轻松一点编译器还是多做了一点工作的，这部分工作就是符号表(Symbol table)。</p><h3 id="什么是符号表-Symbol-table"><a href="#什么是符号表-Symbol-table" class="headerlink" title="什么是符号表 (Symbol table)"></a>什么是符号表 (Symbol table)</h3><p>之前提到，虽然编译器很不厚道的给链接器留了一项任务，但是编译器为了链接器工作的轻松一点还是做了一点事情，这就是<code>符号表</code>。那符号表中保存的是什么呢，符号表中保存的信息有两部分：</p><ul><li>该目标文件中引用的全局变量以及函数</li><li>该目标文件中定义的全局变量以及函数</li></ul><p>以上图中的代码为例，编译器在编译过程中每次遇到一个全局变量或者函数名都会在符号表中添加一项，最终编译器会统计出如下所示的一张符号表：</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210729220247.png" alt="符号表示意图"></p><ul><li>z_global以及fn_a是未定义的，因为在当前文件中，这两个变量仅仅是声明，编译器并没有找到其定义。剩余的变量编译器都可以在当前文件中找到其定义。</li><li>fn_b以及fn_c为当前文件定义的函数，因为在代码段。</li><li>剩余的符号都是全局变量，因此放在了数据段。</li></ul><p>有同学可能会问，为什么全局变量y_global_uninit ，y_global_init以及函数fn_b不可被其它目标文件引用，这是因为这些变量用static修饰过了，在C语言中经static修饰过的函数的函数以及变量都是当前文件私有的，对外部不可见，这里一定要注意。所以static这个关键字的用法就是，如果你认为一个变量只应该被当前文件使用而不暴露给外部，那么你就可以使用<code>static关键字</code>修饰一下。 </p><p>本质上整个符号表只是想表达两件事：</p><ul><li>我能提供给其它文件使用的符号</li><li>我需要其它文件提供给我使用的符号</li></ul><p>这里还有一个问题就是，编译器将统计的这张符号表放在哪里了呢？</p><h3 id="符号表存放在哪里"><a href="#符号表存放在哪里" class="headerlink" title="符号表存放在哪里"></a>符号表存放在哪里</h3><p>在目标文件里有什么这一小节中，我们将一个目标文件简单的划分了两段，数据段和代码段，现在我们要向目标文件中再添加一段，而符号表也被编译器很贴心的放在目标文件中，因此一个目标文件可以理解为如图所示的三段，而符号表中的内容就是上一节当中编译器统计的表格。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210729220335.png" alt="image-20210729220335315"></p><p>有了符号表，链接器就可以进行符号决议了。</p><h3 id="符号决议的过程"><a href="#符号决议的过程" class="headerlink" title="符号决议的过程"></a>符号决议的过程</h3><p>在上一节符号表中，我们知道符号表给链接器提供了两种信息，一个是当前目标文件可以提供给其它目标文件使用的符号，另一个其它目标文件需要提供给当前目标文件使用的符号。有了这些信息链接器就可以进行符号决议了。如图所示，假设链接器需要链接三个目标文件：</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210729220420.png" alt="链接三个目标文件示意图"></p><p>链接器会依次扫描每一个给定的目标文件，同时链接器还维护了两个集合，一个是已定义符号集合D，另一个是未定义符合集合U，下面是链接器进行符合决议的过程：</p><p>1，对于当前目标文件，查找其符号表，并将已定义的符号并添加到已定义符号集合D中。</p><p>2，对于当前目标文件，查找其符号表，将每一个当前目标文件引用的符号与已定义符号集合D进行对比，如果该符号不在集合D中则将其添加到未定义符合集合U中。</p><p>3，当所有文件都扫描完成后，如果为定义符号集合U不为空，则说明当前输入的目标文件集合中有未定义错误，链接器报错，整个编译过程终止。</p><p>上面的过程看似复杂，其实用一句话概括就是只要每个目标文件所引用变量都能在其它目标文件中找到唯一的定义，整个链接过程就是正确的。</p><p>如果你觉得上面的解释比较晦涩的话，你也可以将链接符号决议这个过程想象成如下的游戏：</p><p>新学期开学后，幼儿园的小朋友们都带了礼物要和其它的小朋友们分享，同时每个小朋友也有自己的心愿单，每个小朋友都可以依照自己的心愿单去其它的小朋友那里拿礼物，整个过程结束后，每个小朋友都能拿到自己想要的礼物。</p><p>在这个游戏当中，小朋友就好比目标文件，每个小朋友自己带的礼物就好比每个目标文件的已定义符号集合，心愿单就好比每个目标文件中未定义符号的集合。</p><h3 id="举例说明-undefined-reference"><a href="#举例说明-undefined-reference" class="headerlink" title="举例说明 undefined reference"></a>举例说明 undefined reference</h3><p>假设我们写了一个math.c的数字计算程序，其中定义了一个add函数，该函数在main.c中被引用到，那么很简单，我们只需要在main.c中include写好的math.h头文件就可以使用add函数了，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210729221716.png" alt="引用示意图"></p><p>但是由于粗心大意，一不小心把math.c中的add函数给注释掉了，当你在写完main.c、打算很潇洒的编译一下时，出现了很经典的undefined reference to <code>add(int, int)</code>错误，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210729221746.png" alt="引用报错示意图"></p><p>这个错误其实是这样产生的：</p><ol><li>链接器发现了你写的代码math.o中引用了外部定义的add函数(不要忘了，这是通过检查目标文件math.o中的符号表得到的信息)，所以链接器开始查找add函数到底是在哪里定义的。</li><li>链接器转而去目标文件math.o的目标文件符号表中查找，没有找到add函数的定义。</li><li>链接器转而去其它目标文件符号表中查找，同样没有找到add函数的定义。</li><li>链接器在查找了所有目标文件的符号表后都没有找到add函数，因此链接器停止工作并报出错误undefined reference to `add(int, int)’，如上图所示。</li></ol><p>因此如果你很清楚链接器符号决议这个过程的话就会进行如下排查：</p><ol><li>main.c中对add函数的函数名有没有写正确。</li><li>链接命令中有没有包含math.o，如果没有添加上该目标文件。</li><li>如果链接命令没有问题，查看math.c中定义的add函数定义是否有问题。</li><li>如果是C和C++混合编程时，确保相应的位置添加了extern “C”。</li></ol><p>一般情况下经过这几个步骤的排查基本能够解决问题。</p><p>所以当你再次看到undefined reference这样的错误的是时候，你就应该可以很从容的去解决这类问题了。</p><blockquote><p>参考资料来自于公众号《码农的荒岛求生》，此处整理仅供个人学习。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编译器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链接器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过hexo-pdf插件在博客上发布pdf</title>
      <link href="/posts/54657.html"/>
      <url>/posts/54657.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>我又回来写hexo博客的技术笔记了，因为有一个大(cai)佬(bi)他平时的文档都是用latex写得，发博客有点麻烦，所以要用嵌入pdf的方式进行发表，但是hexo原生不支持pdf，所以我就写了这个教程附带了hexo博客平时的部署方法，供参考。</p><h2 id="安装PDF插件"><a href="#安装PDF插件" class="headerlink" title="安装PDF插件"></a>安装PDF插件</h2><ul><li><p>进入你个人博客本地的根目录，在命令行中打开，并运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">npm install --save hexo-pdf</span><br></pre></td></tr></table></figure></li></ul><h2 id="PDF发表"><a href="#PDF发表" class="headerlink" title="PDF发表"></a>PDF发表</h2><p>  这一步在国内有两种可行办法，一种是使用本地的文件，让hexo从博客中加载，一种就是放在云端的存储仓库进行加载。这里两种方法都做演示，但是推荐使用后者。</p><h3 id="方法一：本地仓库"><a href="#方法一：本地仓库" class="headerlink" title="方法一：本地仓库"></a>方法一：本地仓库</h3><ol><li><p>这个方法比较简单，但是效果较差，可能会造成较大的卡顿，首先在本地的根目录下打开<code>source</code>在这个文件夹下直接将你的pdf放进去即可。</p></li><li><p>在你的本地的博客根目录下新建一篇文章命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">hexo new &quot;文章名称&quot;</span><br></pre></td></tr></table></figure></li><li><p>到你的根目录里的<code>source/_posts</code>文件夹中找到新建的文章，在完成了文章的头部编辑之后，在正文部分只用加一句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">&#123;% pdf /你自己刚刚放的pdf文档的名称.pdf %&#125;</span><br></pre></td></tr></table></figure></li><li><p>回到博客的根目录运行,生成hexo部署文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure></li><li><p>运行<code>hexo s</code>做本地调试或者是使用<code>hexo d</code>进行远端部署，这个过程中可能会遇到命令行提示github用户名和密码，用户名是GitHub注册邮箱，输入后回车确认密码的输入是不可见的，保证输入无误之后回车即可。</p></li></ol><h3 id="方法二：远端仓库"><a href="#方法二：远端仓库" class="headerlink" title="方法二：远端仓库"></a>方法二：远端仓库</h3><p>白嫖GitHub的远端资源。（这里默认已经掌握GitHub基本操作）</p><ol><li><p>新建一个英文名称的公共仓库。</p></li><li><p>在本地文件夹clone或者是通过任何方法使本地文件夹和仓库相连通</p></li><li><p>将你要发布的pdf放在本地的文件夹中</p></li><li><p>使用<code>git push</code>命令将文件推到远端仓库</p></li><li><p>使用jsDelivr的cdn服务实现国内的加速访问，访问方法如下：<br>在文档中加入pdf嵌入语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">&#123;% pdf https://cdn.jsdelivr.net/gh/你的GitHub账户名/你的新建的仓库名/你的文件路径/你的pdf文件.pdf %&#125;</span><br></pre></td></tr></table></figure><p><em>其中的文件路径需要自己进行调整，若是主目录直接使用pdf文件名即可，不需要输入路径。</em></p></li><li><p>和第一种方法一致，新建文章并进行推送即可。</p></li></ol><h2 id="访问网站"><a href="#访问网站" class="headerlink" title="访问网站"></a>访问网站</h2><p>  到这里应该就已经全部结束了，但是在实际访问过程中，我发现我的一些下载插件经常会自动抓取到pdf并提示下载，遇到这种情况就可以通过白名单，或者是忽略解决。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/pdf/test.pdf %&#125;</span><br></pre></td></tr></table></figure><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/pdf/test.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础知识-软硬件和汇编</title>
      <link href="/posts/df8d5ad8.html"/>
      <url>/posts/df8d5ad8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h2><ol><li>计算机是执行<code>输入、运算、输出</code>的机器</li><li>程序是<code>指令</code>和<code>数据</code>的集合</li><li>计算机处理方式有时和人类思维习惯不同</li></ol><h3 id="计算机只会输入、运算、输出"><a href="#计算机只会输入、运算、输出" class="headerlink" title="计算机只会输入、运算、输出"></a>计算机只会输入、运算、输出</h3><p>计算机由大量的IC（集成电路）组成，每块IC上都有很多引脚，用于输入和输出。IC将输入的信息进行运算，并把运算结果输出。</p><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210717161912.png" alt="image-20210717161906146"></p><h3 id="软件是指令和数据的集合"><a href="#软件是指令和数据的集合" class="headerlink" title="软件是指令和数据的集合"></a>软件是指令和数据的集合</h3><p>指令就是控制计算机进行输入、运算、输出的命令，把向计算机发出的命令一条条记录下来就构成了程序。程序执行的过程就是计算机依次执行这些指令的过程。把一组指令取个名字就叫做函数了。</p><p>数据就是在程序运行过程中需要的内容，比如变量。</p><h3 id="计算机认为一切都是数字"><a href="#计算机认为一切都是数字" class="headerlink" title="计算机认为一切都是数字"></a>计算机认为一切都是数字</h3><p>比如人们所说的颜色，计算机都用数字编码来表示，如用“0，0，255”表示蓝色。</p><h2 id="计算机硬件组成"><a href="#计算机硬件组成" class="headerlink" title="计算机硬件组成"></a>计算机硬件组成</h2><p>计算机硬件有三个基本要素：</p><ul><li>CPU：负责解释、执行指令，从而执行程序。从内存或I/O输入数据，在内部进行运算，再把运算结果输出到内存或I/O。</li><li>内存：存放程序，程序又是指令和数据和集合。</li><li>I/O：临时存放着用于和周边设备进行输入输出的数据。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/HanxuLiu/CDN1/img/20210717165118.png" alt="image-20210717165117971"></p><blockquote><p>参考资料《计算机是怎样跑起来的》</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0开始学习GitHub系列.pdf</title>
      <link href="/posts/5440.html"/>
      <url>/posts/5440.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="《从0开始学习GitHub系列》"><a href="#《从0开始学习GitHub系列》" class="headerlink" title="《从0开始学习GitHub系列》"></a>《从0开始学习GitHub系列》</h2><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/HanxuLiu/books-pdf/Git/从0开始学习GitHub系列.pdf" width="100%" height="550" type="application/pdf"></div><hr>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly的外挂标签引入后写作技巧</title>
      <link href="/posts/5538.html"/>
      <url>/posts/5538.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="行内文本样式-text"><a href="#行内文本样式-text" class="headerlink" title="行内文本样式 text"></a>行内文本样式 text</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line">2. 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line">3. 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line">4. 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line">5. 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line">6. 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><h2 id="行内文本-span"><a href="#行内文本-span" class="headerlink" title="行内文本 span"></a>行内文本 span</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line">- 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<span class='p center logo large'>Volantis</span><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><h2 id="段落文本-p"><a href="#段落文本-p" class="headerlink" title="段落文本 p"></a>段落文本 p</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line">- 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p></li></ul><h2 id="复选列表-checkbox"><a href="#复选列表-checkbox" class="headerlink" title="复选列表 checkbox"></a>复选列表 checkbox</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [markdown](https://guides.github.com/features/mastering-markdown/) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><h2 id="单选列表-radio"><a href="#单选列表-radio" class="headerlink" title="单选列表 radio"></a>单选列表 radio</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [markdown](https://guides.github.com/features/mastering-markdown/) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><h2 id="时间轴-timeline"><a href="#时间轴-timeline" class="headerlink" title="时间轴 timeline"></a>时间轴 timeline</h2><div class="timeline"><div class="timenode"><div class="meta"><p><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></p></div><div class="body"><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></p></div><div class="body"><p>不需要额外处理。</p></div></div><div class="timenode"><div class="meta"><p><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></p></div><div class="body"><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><h2 id="按钮-btns"><a href="#按钮-btns" class="headerlink" title="按钮 btns"></a>按钮 btns</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><div class="btns circle grid5">            <a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>          </div><h2 id="音频-audio"><a href="#音频-audio" class="headerlink" title="音频 audio"></a>音频 audio</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure><div class="audio"><audio controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><h2 id="视频-video"><a href="#视频-video" class="headerlink" title="视频 video"></a>视频 video</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov %&#125;</span><br></pre></td></tr></table></figure><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><h2 id="折叠框-folding"><a href="#折叠框-folding" class="headerlink" title="折叠框 folding"></a>折叠框 folding</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line">![](https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg)</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line">- haha</span><br><span class="line">- hehe</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line">hahaha &lt;span&gt;&lt;img src=&#x27;https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27; style=&#x27;height:24px&#x27;&gt;&lt;/span&gt;</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt=""></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><h2 id="分栏-tab"><a href="#分栏-tab" class="headerlink" title="分栏 tab"></a>分栏 tab</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mount命令-挂载磁盘</title>
      <link href="/posts/37407.html"/>
      <url>/posts/37407.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="mount命令介绍"><a href="#mount命令介绍" class="headerlink" title="mount命令介绍"></a>mount命令介绍</h2><p>用于加载文件系统到指定的加载点。此命令的最常用于挂载cdrom，使我们可以访问cdrom中的数据，因为你将光盘插入cdrom中，Linux并不会自动挂载，必须使用Linux mount命令来手动完成挂载。</p><h2 id="mount命令常用参数"><a href="#mount命令常用参数" class="headerlink" title="mount命令常用参数"></a>mount命令常用参数</h2><div class="table-container"><table><thead><tr><th>-t</th><th>指定挂载类型</th></tr></thead><tbody><tr><td>-a</td><td>加载文件“/etc/fstab”中描述的所有文件系统</td></tr></tbody></table></div><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>挂载 /dev/cdrom 到 /mnt：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxcool ~]# mount /dev/cdrom /mnt</span><br></pre></td></tr></table></figure><p>启动所有挂载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxcool ~]# mount -a</span><br></pre></td></tr></table></figure><p>挂载nfs格式文件系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linuxcool ~]# mount -t nfs /123 /mnt  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>df命令-显示磁盘空间</title>
      <link href="/posts/22729.html"/>
      <url>/posts/22729.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="df命令介绍"><a href="#df命令介绍" class="headerlink" title="df命令介绍"></a>df命令介绍</h2><p>df命令的英文全称即<code>Disk Free</code>，顾名思义功能是用于显示系统上可使用的磁盘空间。默认显示单位为KB，建议使用“df -h”的参数组合，根据磁盘容量自动变换合适的单位，更利于人性化阅读。</p><p>日常普遍用该命令可以查看磁盘被占用了多少空间、还剩多少空间等信息。</p><h2 id="df命令常用参数"><a href="#df命令常用参数" class="headerlink" title="df命令常用参数"></a>df命令常用参数</h2><div class="table-container"><table><thead><tr><th>-a</th><th>显示所有系统文件</th></tr></thead><tbody><tr><td>-h</td><td>以容易阅读的方式显示</td></tr></tbody></table></div><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="df默认选项"><a href="#df默认选项" class="headerlink" title="df默认选项"></a><code>df</code>默认选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@paopao ~]# df</span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">devtmpfs          347636       0    347636   0% /dev</span><br><span class="line">tmpfs             362780       0    362780   0% /dev/shm</span><br><span class="line">tmpfs             362780   41188    321592  12% /run</span><br><span class="line">tmpfs             362780       0    362780   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1       20510332 1610056  17835368   9% /</span><br><span class="line">tmpfs              72556       0     72556   0% /run/user/0</span><br><span class="line">[root@paopao ~]# </span><br></pre></td></tr></table></figure><h3 id="df-h便于人性化阅读"><a href="#df-h便于人性化阅读" class="headerlink" title="df -h便于人性化阅读"></a><code>df -h</code>便于人性化阅读</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@paopao ~]# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs        340M     0  340M   0% /dev</span><br><span class="line">tmpfs           355M     0  355M   0% /dev/shm</span><br><span class="line">tmpfs           355M   41M  315M  12% /run</span><br><span class="line">tmpfs           355M     0  355M   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1        20G  1.6G   18G   9% /</span><br><span class="line">tmpfs            71M     0   71M   0% /run/user/0</span><br><span class="line">[root@paopao ~]# </span><br></pre></td></tr></table></figure><h3 id="df-ah显示全部文件系统"><a href="#df-ah显示全部文件系统" class="headerlink" title="df -ah显示全部文件系统"></a><code>df -ah</code>显示全部文件系统</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@paopao ~]# df -ah</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">sysfs              0     0     0    - /sys</span><br><span class="line">proc               0     0     0    - /proc</span><br><span class="line">devtmpfs        340M     0  340M   0% /dev</span><br><span class="line">securityfs         0     0     0    - /sys/kernel/security</span><br><span class="line">tmpfs           355M     0  355M   0% /dev/shm</span><br><span class="line">devpts             0     0     0    - /dev/pts</span><br><span class="line">tmpfs           355M   41M  315M  12% /run</span><br><span class="line">tmpfs           355M     0  355M   0% /sys/fs/cgroup</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/systemd</span><br><span class="line">pstore             0     0     0    - /sys/fs/pstore</span><br><span class="line">bpf                0     0     0    - /sys/fs/bpf</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/memory</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/cpu,cpuacct</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/net_cls,net_prio</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/hugetlb</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/cpuset</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/freezer</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/perf_event</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/devices</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/pids</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/blkio</span><br><span class="line">cgroup             0     0     0    - /sys/fs/cgroup/rdma</span><br><span class="line">none               0     0     0    - /sys/kernel/tracing</span><br><span class="line">configfs           0     0     0    - /sys/kernel/config</span><br><span class="line">/dev/vda1        20G  1.6G   18G   9% /</span><br><span class="line">mqueue             0     0     0    - /dev/mqueue</span><br><span class="line">hugetlbfs          0     0     0    - /dev/hugepages</span><br><span class="line">debugfs            0     0     0    - /sys/kernel/debug</span><br><span class="line">systemd-1          -     -     -    - /proc/sys/fs/binfmt_misc</span><br><span class="line">binfmt_misc        0     0     0    - /proc/sys/fs/binfmt_misc</span><br><span class="line">tmpfs            71M     0   71M   0% /run/user/0</span><br><span class="line">[root@paopao ~]#      </span><br></pre></td></tr></table></figure><h3 id="df-目录-指定目录下的文件’指定文件所在分区的磁盘使用情况"><a href="#df-目录-指定目录下的文件’指定文件所在分区的磁盘使用情况" class="headerlink" title="df  目录 指定目录下的文件’指定文件所在分区的磁盘使用情况"></a><code>df  目录</code> 指定目录下的文件’指定文件所在分区的磁盘使用情况</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@paopao ~]# df /root/.bashrc </span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/vda1       20510332 1610068  17835356   9% /</span><br><span class="line">[root@paopao ~]# </span><br><span class="line">[root@paopao ~]# </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yum命令-RPM包管理器</title>
      <link href="/posts/29820.html"/>
      <url>/posts/29820.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="yum命令介绍"><a href="#yum命令介绍" class="headerlink" title="yum命令介绍"></a>yum命令介绍</h2><p>yum命令是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，它可以使系统管理人员交互和自动化地更新与管理RPM软件包，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p><h2 id="yum命令常用参数"><a href="#yum命令常用参数" class="headerlink" title="yum命令常用参数"></a>yum命令常用参数</h2><div class="table-container"><table><thead><tr><th>-h</th><th>显示帮助信息</th></tr></thead><tbody><tr><td>-y</td><td>对所有的提问都回答“yes”</td></tr><tr><td>install</td><td>安装rpm软件包</td></tr><tr><td>update</td><td>更新rpm软件包</td></tr><tr><td>check-update</td><td>检查是否有可用的更新rpm软件包</td></tr><tr><td>remove</td><td>删除指定的rpm软件包</td></tr><tr><td>list</td><td>显示软件包的信息</td></tr><tr><td>search</td><td>检查软件包的信息</td></tr><tr><td>info</td><td>显示指定的rpm软件包的描述信息和概要信息</td></tr><tr><td>clean</td><td>清理yum过期的缓存</td></tr><tr><td>resolvedep</td><td>显示rpm软件包的依赖关系</td></tr><tr><td>localinstall</td><td>安装本地的rpm软件包</td></tr><tr><td>localupdate</td><td>显示本地rpm软件包进行更新</td></tr><tr><td>deplist</td><td>显示rpm软件包的所有依赖关系</td></tr></tbody></table></div><h2 id="国内-yum-源"><a href="#国内-yum-源" class="headerlink" title="国内 yum 源"></a>国内 yum 源</h2><p>网易（163）yum源是国内最好的yum源之一 ，无论是速度还是软件版本，都非常的不错。</p><p>将yum源设置为163 yum，可以提升软件包安装和更新的速度，同时避免一些常见软件版本无法找到。</p><h3 id="yum源配置方法"><a href="#yum源配置方法" class="headerlink" title="yum源配置方法"></a>yum源配置方法</h3><p>首先备份/etc/yum.repos.d/CentOS-Base.repo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure><p>下载对应版本 repo 文件, 放入 /etc/yum.repos.d/ (操作前请做好相应备份)</p><ul><li><a href="http://mirrors.163.com/.help/CentOS5-Base-163.repo">CentOS5</a> ：<a href="http://mirrors.163.com/.help/CentOS5-Base-163.repo">http://mirrors.163.com/.help/CentOS5-Base-163.repo</a></li><li><a href="http://mirrors.163.com/.help/CentOS6-Base-163.repo">CentOS6</a> ：<a href="http://mirrors.163.com/.help/CentOS6-Base-163.repo">http://mirrors.163.com/.help/CentOS6-Base-163.repo</a></li><li><a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo">CentOS7</a> ：<a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo">http://mirrors.163.com/.help/CentOS7-Base-163.repo</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.163.com/.help/CentOS6-Base-163.repo</span><br><span class="line">mv CentOS6-Base-163.repo CentOS-Base.repo</span><br></pre></td></tr></table></figure><p>运行以下命令生成缓存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rz、sz命令-文件传输</title>
      <link href="/posts/42689.html"/>
      <url>/posts/42689.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-软件安装"><a href="#1-软件安装" class="headerlink" title="1. 软件安装"></a>1. 软件安装</h1><p>rz/sz命令用来在xshell远程服务器和本地之间传输文件，主要有两种方式安装，yum安装或者编译安装。</p><h2 id="1-1-yum包安装"><a href="#1-1-yum包安装" class="headerlink" title="1.1 yum包安装"></a>1.1 yum包安装</h2><p>root账号登陆后执行以下命令：</p><blockquote><p>yum install -y lrzsz</p></blockquote><h2 id="2-2-源码编译安装"><a href="#2-2-源码编译安装" class="headerlink" title="2.2 源码编译安装"></a>2.2 源码编译安装</h2><p>root账号登陆后，依次执行以下命令：</p><blockquote><p>cd /tmp<br>wget <a href="http://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz">http://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz</a><br>tar zxvf lrzsz-0.12.20.tar.gz &amp;&amp; cd lrzsz-0.12.20<br>./configure &amp;&amp; make &amp;&amp; make install</p></blockquote><p>上面安装过程默认把lsz/lrz安装到了/usr/local/bin/目录下，现在我们还不能使用sz/rz命令，需要手动建立软链接：</p><blockquote><p>cd /usr/bin<br>ln -s /usr/local/bin/lsz sz<br>ln -s /usr/local/bin/lrz rz</p></blockquote><h1 id="2-使用说明"><a href="#2-使用说明" class="headerlink" title="2. 使用说明"></a>2. 使用说明</h1><h2 id="2-1-sz命令：发送文件到本地目录"><a href="#2-1-sz命令：发送文件到本地目录" class="headerlink" title="2.1 sz命令：发送文件到本地目录"></a>2.1 sz命令：发送文件到本地目录</h2><blockquote><p>sz filename</p></blockquote><h2 id="2-2-rz命令：将本地文件上传到linux服务器"><a href="#2-2-rz命令：将本地文件上传到linux服务器" class="headerlink" title="2.2 rz命令：将本地文件上传到linux服务器"></a>2.2 rz命令：将本地文件上传到linux服务器</h2><blockquote><p>rz</p></blockquote><p>执行此命令后，在弹出框中选择要上传的文件即可。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>V2Ray配置教程</title>
      <link href="/posts/39483.html"/>
      <url>/posts/39483.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="V2Ray-配置教程"><a href="#V2Ray-配置教程" class="headerlink" title="V2Ray 配置教程"></a>V2Ray 配置教程</h1><p>V2Ray 是继 Shadowsocks(R)后又一个体验很棒、功能非常强大的科学上网工具，近年来受到网友的广泛关注和喜爱。敏感时期，基本上只有 <a href="https://tlanyan.pp.ua/v2ray-traffic-mask/">V2ray 伪装</a> 或 <a href="https://tlanyan.pp.ua/trojan-tutorial/">trojan</a> 能提供十分稳的服务，推荐使用。</p><p>本教程详细介绍 V2ray 的特点，安装和配置过程，让读者能迅速上手和使用 V2ray。在本文基础上，建议网友继续阅读 <a href="https://tlanyan.pp.ua/v2ray-traffic-mask/">V2ray 高级技巧：流量伪装</a>，以及最新出炉的<a href="https://tlanyan.pp.ua/introduce-v2ray-vless-protocol/">VLESS 协议和 XTLS 黑科技</a>，体验更稳的上外网方式。v2ray 客户端下载请访问：<a href="https://tlanyan.pp.ua/v2ray-clients-download">V2ray 客户端</a>。</p><h2 id="V2Ray-简介"><a href="#V2Ray-简介" class="headerlink" title="V2Ray 简介"></a>V2Ray 简介</h2><p><code>V2Ray</code>是近几年十分流行的网络工具，其功能强大，用途不限于突破防火墙，但因其能有效翻墙而广为人知。<code>V2Ray</code>有如下大放异彩的特点：</p><ul><li>开源。<code>V2Ray</code>是<code>Project V</code>的核心工具，源代码开源；</li><li>多协议支持。传输层支持 TCP、mKCP、WebSocket 等，上层协议支持 Socks、Shadowsocks、以及自定义的<code>VMess</code>等；</li><li>多入口和多出口。<code>V2Ray</code>可同时支持多个入站和出站协议，每个协议独立工作；</li><li>多平台支持。原生支持 Windows、Linux、MacOS 三大常用平台，安卓、iOS 两大移动平台有丰富的第三方工具；</li><li>隐蔽性。<code>V2Ray</code>流量可伪装成网页流量，更难被检测和干扰。</li></ul><p>与另一个知名的翻墙工具<code>Shadowsocks(R)</code>相比，V2ray 和 SSR 区别在于：</p><ol><li><code>V2Ray</code>是一个框架/平台，而<code>Shadowsocks(R)</code>是一个代理工具；</li><li><code>V2Ray</code>功能强大配置复杂，<code>Shadowsocks(R)</code>简单易用；</li><li><code>V2Ray</code>性能更好，协议支持更完善。</li></ol><p>一句话总结：<code>V2Ray</code>更好更强大，但更难上手和用好。</p><blockquote><p>因 v2ray 原开发者长期不上线，社区为了维护方便创建了 v2fly，v2fly 的官网是 <a href="https://www.v2fly.org">https://www.v2fly.org</a>。大名鼎鼎的 v2ray 白话文、一键安装脚本等都出自 v2fly。目前 v2ray 项目主要由 v2fly 推动，v2fly 的代码更新也会合并到 v2ray 项目库中，一般可以认为 v2ray 和 v2fly 是同一个组织。</p><p>V2ray 发布了新版 VLESS 协议，详情请参考 <a href="https://tlanyan.pp.ua/introduce-v2ray-vless-protocol/">VLESS 协议介绍和使用教程</a></p></blockquote><h2 id="一、服务器配置"><a href="#一、服务器配置" class="headerlink" title="一、服务器配置"></a>一、服务器配置</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul><li>买一台位于境外的服务器。</li><li>在本地使用 SSH 连到服务器。</li></ul><h3 id="安装V2Ray"><a href="#安装V2Ray" class="headerlink" title="安装V2Ray"></a>安装V2Ray</h3><p>在 CentOS、Ubuntu 等常用 Linux 系统上，直接执行如下命令安装<code>V2Ray</code>（如果已安装则更新程序）：</p><pre><code>bash &lt;(curl -sL https://raw.githubusercontent.com/hijkpw/scripts/master/goV2.sh)</code></pre><p>安装完成后，安装成功后会自动生成的配置文件，配置文件为<code>/etc/v2ray/config.json</code>。<br>cat 命令可查看内容：<code>cat /etc/v2ray/config.json</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@paopao v2ray]<span class="comment"># cat config.json </span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;inbounds&quot;</span>: [&#123;</span><br><span class="line">    <span class="string">&quot;port&quot;</span>: 12345,</span><br><span class="line">    <span class="string">&quot;protocol&quot;</span>: <span class="string">&quot;vmess&quot;</span>,</span><br><span class="line">    <span class="string">&quot;settings&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;clients&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;id&quot;</span>: <span class="string">&quot;9e3939be-76db-4757-a95e-db5158725eaa&quot;</span>,</span><br><span class="line">          <span class="string">&quot;level&quot;</span>: 1,</span><br><span class="line">          <span class="string">&quot;alterId&quot;</span>: 64</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">&quot;outbounds&quot;</span>: [&#123;</span><br><span class="line">    <span class="string">&quot;protocol&quot;</span>: <span class="string">&quot;freedom&quot;</span>,</span><br><span class="line">    <span class="string">&quot;settings&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    <span class="string">&quot;protocol&quot;</span>: <span class="string">&quot;blackhole&quot;</span>,</span><br><span class="line">    <span class="string">&quot;settings&quot;</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;blocked&quot;</span></span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">&quot;routing&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;rules&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;field&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ip&quot;</span>: [<span class="string">&quot;geoip:private&quot;</span>],</span><br><span class="line">        <span class="string">&quot;outboundTag&quot;</span>: <span class="string">&quot;blocked&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件中”inbounds”下的这几项信息需要留意：<br>port（<code>端口</code>）、clients 中的 id（<code>用户id</code>）和 alterId（<code>额外id</code>），它们将在配置客户端时用到。</p><p>配置文件无需任何改动即可正常使用。接下来防火墙放行监听的端口，设置开机启动并运行<code>V2Ray</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewalld放行端口（适用于CentOS7/8）</span></span><br><span class="line">firewall-cmd --permanent --add-port=12345/tcp <span class="comment"># 12345改成你配置文件中的端口号</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># ufw放行端口（适用于ubuntu）</span></span><br><span class="line">ufw allow 12345/tcp <span class="comment"># 12345改成你的端口号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># iptables 放行端口（适用于CentOS 6/7）</span></span><br><span class="line">iptables -I INPUT -p tcp --dport 12345 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> v2ray</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行v2ray</span></span><br><span class="line">systemctl start v2ray</span><br></pre></td></tr></table></figure><p><code>ss -ntlp | grep v2ray</code> 命令可以查看 v2ray 是否正在运行。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@paopao v2ray]<span class="comment"># ss -ntlp | grep v2ray</span></span><br><span class="line">LISTEN      0      128       *:12345   *:*     users:((<span class="string">&quot;v2ray&quot;</span>,pid=9544,fd=3))</span><br></pre></td></tr></table></figure><p>如果输出如上面的内容，则成功了。<br>如果输出为空，大概率是被 selinux 限制了，解决办法如下：</p><p>1. 禁用 selinux：<code>setenforce 0</code>;</p><p>2. 重启 v2ray：<code>systemctl restart v2ray</code></p><p>到此，服务端应该配置好了。如果服务器商层面还有防火墙（阿里云/Google/AWS 购买的 vps），请登录网页后台，放行 v2ray 的端口。</p><h2 id="二、Windows客户端：V2rayN-配置"><a href="#二、Windows客户端：V2rayN-配置" class="headerlink" title="二、Windows客户端：V2rayN 配置"></a>二、Windows客户端：V2rayN 配置</h2><p>V2rayN 是一个基于<a href="https://v2raytech.com/category/v2ray/">V2ray</a>核心的 Windows 客户端，功能强大且支持多种协议。V2rayN 4.0 版本开始取消 PAC 模式，给许多用户使用上带来困难。鉴于此，本文介绍最新 V2rayN 4.12 正式版的配置教程，让你能顺利切换 PAC 模式和全局模式。</p><h3 id="V2rayN-4-12-配置教程"><a href="#V2rayN-4-12-配置教程" class="headerlink" title="V2rayN 4.12 配置教程"></a>V2rayN 4.12 配置教程</h3><p>到这个页面 <a href="https://v2xtls.org/v2ray-windows%e5%ae%a2%e6%88%b7%e7%ab%af%e4%b8%8b%e8%bd%bd/">V2Ray windows 客户端下载</a> 下载 V2rayN 并解压。V2rayN 是绿色软件，解压后直接能用，不需要安装。</p><p>首先. 进入解压后的 V2rayN-core 目录，双击”v2rayN”文件，程序启动后会最小化到右下角的托盘。双击蓝色的 V 字小图标，打开 V2rayN 的主界面：</p><p><a href="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN主界面.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN主界面.png" alt="v2rayN主界面"></a></p><p>v2rayN 主界面</p><p>接下来，<strong>如果用了 VLESS 或者 XTLS 技术，请更换为 Xray 内核</strong>，否则可能无法正常连接到节点！操作为：点击“设置” -&gt; “参数设置” -> “V2rayN 设置” -&gt; “Core 类型”，选择“Xray_core”，然后点击确定：</p><p><a href="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN切换Xray内核.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN切换Xray内核.png" alt="v2rayN切换Xray内核"></a></p><p>v2rayN 切换 Xray 内核</p><p>接着添加新的 V2ray 节点：点击界面上方的“服务器”，按照自己节点类型选择，<strong>注意 VMess 服务器和 VLESS 服务器是不同的</strong>！</p><p><a href="https://v2xtls.org/wp-content/uploads/2021/03/v2ray添加新服务器.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/v2ray添加新服务器.png" alt="v2ray添加新服务器"></a></p><p>v2ray 添加新服务器</p><p>这里以我们以手动 VLESS 服务器为例进行说明，根据 V2ray 节点信息填写地址、端口、用户 ID 等、流控等信息。VLESS 协议不需要额外 id（alterID），所以不需要填写。反过来说如果你看到要填写额外 ID，说明服务器类型选错了！</p><p>底层传输安全那里，建议跳过证书验证为 false，证书过期或者上不了外网再改成 true。SNI 填写伪装域名，也就是保持和伪装域名那里填的一样就可以了：</p><p><a href="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN添加VLESS服务器.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN添加VLESS服务器.png" alt="v2rayN添加VLESS服务器"></a></p><p>v2rayN 添加 VLESS 服务器</p><p>配置好后点击确定，主界面出现了节点的简要信息。可以双击节点那一行再次出来上面的配置界面修改配置，也可以点击右键删除、移动该节点：</p><p><a href="https://v2xtls.org/wp-content/uploads/2021/03/V2rayN添加了节点界面.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/V2rayN添加了节点界面.png" alt="V2rayN添加了节点界面"></a></p><p>V2rayN 添加了节点界面</p><p>配置好节点后需要设置系统代理才能让浏览器访问外网，操作为：右下角托盘找到 v2rayN 图标，在图标上点击右键，找到“系统代理” ，点击“自动配置系统代理”，此时图标会变成红色：</p><p><a href="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN设置系统代理.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN设置系统代理.png" alt="v2rayN设置系统代理"></a></p><p>v2rayN 设置系统代理</p><p>默认 v2rayN 是全局代理，也就是不管访问什么网站，都是走节点流量。大部分网友之前用 v2rayN 都是 PAC 模式，v2rayN 4.0 版本开始取消了 PAC，因此需要下面的操作来代替 PAC：</p><p>主界面点击“设置” -&gt; “路由设置” -&gt; “基础功能” -> “一键导入基础规则”，然后点击“确定”：</p><p><a href="https://v2xtls.org/wp-content/uploads/2021/03/V2rayN设置PAC模式.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/V2rayN设置PAC模式.png" alt="V2rayN设置PAC模式"></a></p><p>V2rayN 设置 PAC 模式</p><blockquote><p>域名策略一般建议选“IPIfNotMatch”或者“ASIS”，也可以按照需求选其他的</p></blockquote><p>接下来访问百度、淘宝等国外网站都是直连，不会再走代理了。如果想让某个网站走代理而不是直连，那么在上图中“代理的 Domain 或 IP”的左边加一行：<code>domain:网站域名</code>，例如添加本站走代理：domain:v2raytech.com，然后点击“确定”。</p><p>想换成所有网站都走代理又该怎么操作呢？方法也很简单：上图中“直连的 Domain 或 IP”，把左边和右边输入框的行都清空，然后点击“确定”。</p><p>V2ray 节点没挂，你配置又没问题的话，接下来应该能愉快的上外网了。</p><blockquote><p>如果不想上外网了，右下角托盘找到 v2rayN 图标，在图标上点击右键，找到“系统代理” ，点击“清除系统代理”。</p></blockquote><h3 id="查看-V2rayN-日志"><a href="#查看-V2rayN-日志" class="headerlink" title="查看 V2rayN 日志"></a>查看 V2rayN 日志</h3><p>配置好后不能上外网，请先参考 <a href="https://v2xtls.org/pc%e7%ab%af%e7%a7%91%e5%ad%a6%e4%b8%8a%e7%bd%91%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98/">PC 端科学上网常见问题</a>，不能解决再复制 V2rayN 日志错误信息，然后在本教程下面留言，或者到 <a href="https://hijk.club">网络跳越论坛</a> 或 tg 群组<a href="https://t.me/hijkclub">https://t.me/hijkclub</a> 交流。</p><p>V2rayN 的日志在主界面下面的黑框框里，不能上外网的话一般会输出类似下面的日志：</p><p><a href="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN日志.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/v2rayN日志.png" alt="v2rayN日志"></a></p><p>v2rayN 日志</p><h3 id="V2rayN-报病毒"><a href="#V2rayN-报病毒" class="headerlink" title="V2rayN 报病毒"></a>V2rayN 报病毒</h3><p>由于一些原因，V2rayN 在 Windows 上可能会报病毒导致无法正常使用：</p><p><a href="https://v2xtls.org/wp-content/uploads/2021/03/windows提示v2rayN病毒.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/windows提示v2rayN病毒.png" alt="windows提示v2rayN病毒"></a></p><p>windows 提示 v2rayN 病毒</p><p>如果不放心 V2rayN，可以换其他客户端，比如 <a href="https://v2xtls.org/clash-for-windows%e9%85%8d%e7%bd%aev2ray%e6%95%99%e7%a8%8b/">Clash for Windows</a>，或者试试从官网下载的版本。但一般来说这都是 Windows 的误报，添加到例外即可。操作为：点击右下角托盘的 Windows 安全中心 -&gt; “病毒和威胁防护” -&gt; “保护历史记录” -&gt; “已隔离威胁” -&gt; “操作”，点击“还原”。如果 V2rayN 界面里还是提示病毒，找到同一个界面，操作点击“允许”：</p><p><a href="https://v2xtls.org/wp-content/uploads/2021/03/还原病毒提示.png"><img src="https://v2xtls.org/wp-content/uploads/2021/03/还原病毒提示-1024x794.png" alt="还原病毒提示"></a></p><p>还原病毒提示</p><p>尽管移除了 PAC 模式，但 V2rayN 还是 Windows 上最好用的 V2ray、trojan 客户端之一，非常推荐！</p><h2 id="三、安卓客户端：V2rayNG-配置"><a href="#三、安卓客户端：V2rayNG-配置" class="headerlink" title="三、安卓客户端：V2rayNG 配置"></a>三、安卓客户端：V2rayNG 配置</h2><p><strong>v2rayNG</strong> 是安卓平台上一款基于 v2ray 核心的简洁、功能强大的客户端。本文通过图文详细介绍其安装和配置过程，希望对在安卓手机上使用 v2rayNG 进行科学上网的网友有帮助。如果配置完后依然无法上外网，请参考：<a href="https://v2xtls.org/%e7%a7%91%e5%ad%a6%e4%b8%8a%e7%bd%91%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98/">科学上网常见问题</a>。</p><p>阅读本教程的前提：</p><ol><li>已有服务端信息，可参考 <a href="https://v2xtls.org/v2ray%e4%b8%80%e9%94%ae%e8%84%9a%e6%9c%ac/">v2ray 一键脚本</a> 或 <a href="https://v2xtls.org/%e8%8e%b7%e5%8f%96%e7%a7%91%e5%ad%a6%e4%b8%8a%e7%bd%91%e6%9c%8d%e5%8a%a1%e7%ab%af%e4%bf%a1%e6%81%af/">获取科学上网服务端信息</a></li><li>下载 v2rayNG，未下载的请到这个页面下载：<a href="https://v2xtls.org/v2ray%e5%ae%89%e5%8d%93%e5%ae%a2%e6%88%b7%e7%ab%af%e4%b8%8b%e8%bd%bd/">V2Ray 安卓客户端下载</a></li></ol><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>1. 安装下载的 v2rayNG apk 文件；</p><p>2. 打开软件，进入主界面（即配置文件界面）：</p><p><a href="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG主界面-576x1024-1.png"><img src="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG主界面-576x1024-1.png" alt="v2rayNG主界面"></a></p><p>v2rayNG 主界面</p><p>3. 点右上方的“+”，可以看到 V2rayNG 支持从二维码、剪切板导入，也可以手动配置 vmess、ss 等，还支持订阅（在自定义配置中）：</p><p><a href="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG服务器菜单-576x1024-1.png"><img src="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG服务器菜单-576x1024-1.png" alt="v2rayNG服务器菜单"></a></p><p>v2rayNG 服务器菜单</p><p>4. 本教程以手动输入为例，点击“手动输入[vmess]”，进入服务器填写界面。别名随意填写，例如“香港 vps”。地址、端口、用户 id、额外 id 按照服务端的信息填写（不知道这些信息填什么请参考参考 <a href="https://v2xtls.org/%e8%8e%b7%e5%8f%96%e7%a7%91%e5%ad%a6%e4%b8%8a%e7%bd%91%e6%9c%8d%e5%8a%a1%e7%ab%af%e4%bf%a1%e6%81%af/">获取科学上网服务端信息</a>），这几项非常重要，不要填错！</p><p><a href="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG基础配置-576x1024-1.png"><img src="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG基础配置-576x1024-1.png" alt="v2rayNG基础配置"></a></p><p>v2rayNG 基础配置</p><p>后半部分是高级选项，一般不用填写（加密方式一般选 auto）。</p><blockquote><p>Just My Socks V2ray 加密方式选 none 或者 auto 上不了网，请改成 chacha20-ietf-poly1305</p></blockquote><p><strong>如果使用了伪装</strong>，传输协议选 ws，伪装类型保持默认的 none，“功能设置”下面填入域名、伪装路径，同时底层传输安全选 tls<strong>（不是伪装就不要选！）</strong>：</p><p><a href="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG高级配置-576x1024-1.jpeg"><img src="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG高级配置-576x1024-1.jpeg" alt="v2rayNG高级配置"></a></p><p>v2rayNG 高级配置</p><p>5. 点界面右上角的勾保存配置。界面回到主界面，点右下角的 v2rayNG 图标，启动程序。如果出现网络连接请求，点击确定：</p><p><a href="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG网络连接请求-576x1024-1.jpeg"><img src="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG网络连接请求-576x1024-1.jpeg" alt="v2rayNG网络连接请求"></a></p><p>v2rayNG 网络连接请求</p><p>6. 一些高级设置在左侧菜单的“设置”中，建议将域名策略改成”Asis”，勾选“启用速度显示”打开 vpn 流量速度显示，其他不懂的就不用管：</p><p><a href="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG全局设置-576x1024-1.jpeg"><img src="https://v2xtls.org/wp-content/uploads/2020/11/v2rayNG全局设置-576x1024-1.jpeg" alt="v2rayNG全局设置"></a></p><p>v2rayNG 全局设置</p><p>配置好且服务端没有问题的话，打开浏览器应该能正常访问 google、youtube 等网站了。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> V2Ray </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS 原理入门</title>
      <link href="/posts/44210.html"/>
      <url>/posts/44210.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="DNS-原理入门"><a href="#DNS-原理入门" class="headerlink" title="DNS 原理入门"></a>DNS 原理入门</h1><p>作者： <a href="http://www.ruanyifeng.com">阮一峰</a></p><p>日期： <a href="http://www.ruanyifeng.com/blog/2016/06/">2016 年 6 月 16 日</a></p><p>DNS 是互联网核心协议之一。不管是上网浏览，还是编程开发，都需要了解一点它的知识。</p><p>本文详细介绍 DNS 的原理，以及如何运用工具软件观察它的运作。我的目标是，读完此文后，你就能完全理解 DNS。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061513.png" alt=""></p><h2 id="一、DNS-是什么？"><a href="#一、DNS-是什么？" class="headerlink" title="一、DNS 是什么？"></a>一、DNS 是什么？</h2><p>DNS （Domain Name System 的缩写）的作用非常简单，就是根据域名查出 IP 地址。你可以把它想象成一本巨大的电话本。</p><p>举例来说，如果你要访问域名<code>math.stackexchange.com</code>，首先要通过 DNS 查出它的 IP 地址是<code>151.101.129.69</code>。</p><p>如果你不清楚为什么一定要查出 IP 地址，才能进行网络通信，建议先阅读我写的<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">《互联网协议入门》</a>。</p><h2 id="二、查询过程"><a href="#二、查询过程" class="headerlink" title="二、查询过程"></a>二、查询过程</h2><p>虽然只需要返回一个 IP 地址，但是 DNS 的查询过程非常复杂，分成多个步骤。</p><p>工具软件<code>dig</code>可以显示整个查询过程。</p><blockquote><pre><code>$ dig math.stackexchange.com</code></pre></blockquote><p>上面的命令会输出六段信息。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061501.png" alt=""></p><p>第一段是查询参数和统计。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061502.png" alt=""></p><p>第二段是查询内容。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061503.png" alt=""></p><p>上面结果表示，查询域名<code>math.stackexchange.com</code>的<code>A</code>记录，<code>A</code>是 address 的缩写。</p><p>第三段是 DNS 服务器的答复。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061504.png" alt=""></p><p>上面结果显示，<code>math.stackexchange.com</code>有四个<code>A</code>记录，即四个 IP 地址。<code>600</code>是 TTL 值（Time to live 的缩写），表示缓存时间，即 600 秒之内不用重新查询。</p><p>第四段显示<code>stackexchange.com</code>的 NS 记录（Name Server 的缩写），即哪些服务器负责管理<code>stackexchange.com</code>的 DNS 记录。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061505.png" alt=""></p><p>上面结果显示<code>stackexchange.com</code>共有四条 NS 记录，即四个域名服务器，向其中任一台查询就能知道<code>math.stackexchange.com</code>的 IP 地址是什么。</p><p>第五段是上面四个域名服务器的 IP 地址，这是随着前一段一起返回的。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061506.png" alt=""></p><p>第六段是 DNS 服务器的一些传输信息。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061514.png" alt=""></p><p>上面结果显示，本机的 DNS 服务器是<code>192.168.1.253</code>，查询端口是 53（DNS 服务器的默认端口），以及回应长度是 305 字节。</p><p>如果不想看到这么多内容，可以使用<code>+short</code>参数。</p><blockquote><pre><code>$ dig +short math.stackexchange.com151.101.129.69151.101.65.69151.101.193.69151.101.1.69</code></pre></blockquote><p>上面命令只返回<code>math.stackexchange.com</code>对应的 4 个 IP 地址（即<code>A</code>记录）。</p><h2 id="三、DNS-服务器"><a href="#三、DNS-服务器" class="headerlink" title="三、DNS 服务器"></a>三、DNS 服务器</h2><p>下面我们根据前面这个例子，一步步还原，本机到底怎么得到域名<code>math.stackexchange.com</code>的 IP 地址。</p><p>首先，本机一定要知道 DNS 服务器的 IP 地址，否则上不了网。通过 DNS 服务器，才能知道某个域名的 IP 地址到底是什么。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061507.jpg" alt=""></p><p>DNS 服务器的 IP 地址，有可能是动态的，每次上网时由网关分配，这叫做 DHCP 机制；也有可能是事先指定的固定地址。Linux 系统里面，DNS 服务器的 IP 地址保存在<code>/etc/resolv.conf</code>文件。</p><p>上例的 DNS 服务器是<code>192.168.1.253</code>，这是一个内网地址。有一些公网的 DNS 服务器，也可以使用，其中最有名的就是 Google 的<a href="https://developers.google.com/speed/public-dns/"><code>8.8.8.8</code></a>和 Level 3 的<a href="https://www.tummy.com/articles/famous-dns-server/"><code>4.2.2.2</code></a>。</p><p>本机只向自己的 DNS 服务器查询，<code>dig</code>命令有一个<code>@</code>参数，显示向其他 DNS 服务器查询的结果。</p><blockquote><pre><code>$ dig @4.2.2.2 math.stackexchange.com</code></pre></blockquote><p>上面命令指定向 DNS 服务器<code>4.2.2.2</code>查询。</p><h2 id="四、域名的层级"><a href="#四、域名的层级" class="headerlink" title="四、域名的层级"></a>四、域名的层级</h2><p>DNS 服务器怎么会知道每个域名的 IP 地址呢？答案是分级查询。</p><p>请仔细看前面的例子，每个域名的尾部都多了一个点。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061503.png" alt=""></p><p>比如，域名<code>math.stackexchange.com</code>显示为<code>math.stackexchange.com.</code>。这不是疏忽，而是所有域名的尾部，实际上都有一个根域名。</p><p>举例来说，<code>www.example.com</code>真正的域名是<code>www.example.com.root</code>，简写为<code>www.example.com.</code>。因为，根域名<code>.root</code>对于所有域名都是一样的，所以平时是省略的。</p><p>根域名的下一级，叫做”顶级域名”（top-level domain，缩写为 TLD），比如<code>.com</code>、<code>.net</code>；再下一级叫做”次级域名”（second-level domain，缩写为 SLD），比如<code>www.example.com</code>里面的<code>.example</code>，这一级域名是用户可以注册的；再下一级是主机名（host），比如<code>www.example.com</code>里面的<code>www</code>，又称为”三级域名”，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。</p><p>总结一下，域名的层级结构如下。</p><blockquote><pre><code>主机名.次级域名.顶级域名.根域名# 即host.sld.tld.root</code></pre></blockquote><h2 id="五、根域名服务器"><a href="#五、根域名服务器" class="headerlink" title="五、根域名服务器"></a>五、根域名服务器</h2><p>DNS 服务器根据域名的层级，进行分级查询。</p><p>需要明确的是，每一级域名都有自己的 NS 记录，NS 记录指向该级域名的域名服务器。这些服务器知道下一级域名的各种记录。</p><p>所谓”分级查询”，就是从根域名开始，依次查询每一级域名的 NS 记录，直到查到最终的 IP 地址，过程大致如下。</p><blockquote><ol><li>从”根域名服务器”查到”顶级域名服务器”的 NS 记录和 A 记录（IP 地址）</li><li>从”顶级域名服务器”查到”次级域名服务器”的 NS 记录和 A 记录（IP 地址）</li><li>从”次级域名服务器”查出”主机名”的 IP 地址</li></ol></blockquote><p>仔细看上面的过程，你可能发现了，没有提到 DNS 服务器怎么知道”根域名服务器”的 IP 地址。回答是”根域名服务器”的 NS 记录和 IP 地址一般是不会变化的，所以内置在 DNS 服务器里面。</p><p>下面是内置的根域名服务器 IP 地址的一个<a href="http://www.cyberciti.biz/faq/unix-linux-update-root-hints-data-file/">例子</a>。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061508.png" alt=""></p><p>上面列表中，列出了根域名（<code>.root</code>）的三条 NS 记录<code>A.ROOT-SERVERS.NET</code>、<code>B.ROOT-SERVERS.NET</code>和<code>C.ROOT-SERVERS.NET</code>，以及它们的 IP 地址（即<code>A</code>记录）<code>198.41.0.4</code>、<code>192.228.79.201</code>、<code>192.33.4.12</code>。</p><p>另外，可以看到所有记录的 TTL 值是 3600000 秒，相当于 1000 小时。也就是说，每 1000 小时才查询一次根域名服务器的列表。</p><p>目前，世界上一共有十三组根域名服务器，从<code>A.ROOT-SERVERS.NET</code>一直到<code>M.ROOT-SERVERS.NET</code>。</p><h2 id="六、分级查询的实例"><a href="#六、分级查询的实例" class="headerlink" title="六、分级查询的实例"></a>六、分级查询的实例</h2><p><code>dig</code>命令的<code>+trace</code>参数可以显示 DNS 的整个分级查询过程。</p><blockquote><pre><code>$ dig +trace math.stackexchange.com</code></pre></blockquote><p>上面命令的第一段列出根域名<code>.</code>的所有 NS 记录，即所有根域名服务器。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061509.png" alt=""></p><p>根据内置的根域名服务器 IP 地址，DNS 服务器向所有这些 IP 地址发出查询请求，询问<code>math.stackexchange.com</code>的顶级域名服务器<code>com.</code>的 NS 记录。最先回复的根域名服务器将被缓存，以后只向这台服务器发请求。</p><p>接着是第二段。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061510.png" alt=""></p><p>上面结果显示<code>.com</code>域名的 13 条 NS 记录，同时返回的还有每一条记录对应的 IP 地址。</p><p>然后，DNS 服务器向这些顶级域名服务器发出查询请求，询问<code>math.stackexchange.com</code>的次级域名<code>stackexchange.com</code>的 NS 记录。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061511.png" alt=""></p><p>上面结果显示<code>stackexchange.com</code>有四条 NS 记录，同时返回的还有每一条 NS 记录对应的 IP 地址。</p><p>然后，DNS 服务器向上面这四台 NS 服务器查询<code>math.stackexchange.com</code>的主机名。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061512.png" alt=""></p><p>上面结果显示，<code>math.stackexchange.com</code>有 4 条<code>A</code>记录，即这四个 IP 地址都可以访问到网站。并且还显示，最先返回结果的 NS 服务器是<code>ns-463.awsdns-57.com</code>，IP 地址为<code>205.251.193.207</code>。</p><h2 id="七、NS-记录的查询"><a href="#七、NS-记录的查询" class="headerlink" title="七、NS 记录的查询"></a>七、NS 记录的查询</h2><p><code>dig</code>命令可以单独查看每一级域名的 NS 记录。</p><blockquote><pre><code>$ dig ns com$ dig ns stackexchange.com</code></pre></blockquote><p><code>+short</code>参数可以显示简化的结果。</p><blockquote><pre><code>$ dig +short ns com$ dig +short ns stackexchange.com</code></pre></blockquote><h2 id="八、DNS-的记录类型"><a href="#八、DNS-的记录类型" class="headerlink" title="八、DNS 的记录类型"></a>八、DNS 的记录类型</h2><p>域名与 IP 之间的对应关系，称为”记录”（record）。根据使用场景，”记录”可以分成不同的类型（type），前面已经看到了有<code>A</code>记录和<code>NS</code>记录。</p><p>常见的 DNS 记录类型如下。</p><blockquote><p>（1） <code>A</code>：地址记录（Address），返回域名指向的 IP 地址。</p><p>（2） <code>NS</code>：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为 IP 地址。</p><p>（3）<code>MX</code>：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。</p><p>（4）<code>CNAME</code>：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转，详见下文。</p><p>（5）<code>PTR</code>：逆向查询记录（Pointer Record），只用于从 IP 地址查询域名，详见下文。</p></blockquote><p>一般来说，为了服务的安全可靠，至少应该有两条<code>NS</code>记录，而<code>A</code>记录和<code>MX</code>记录也可以有多条，这样就提供了服务的冗余性，防止出现单点失败。</p><p><code>CNAME</code>记录主要用于域名的内部跳转，为服务器配置提供灵活性，用户感知不到。举例来说，<code>facebook.github.io</code>这个域名就是一个<code>CNAME</code>记录。</p><blockquote><pre><code>$ dig facebook.github.io...;; ANSWER SECTION:facebook.github.io. 3370    IN  CNAME   github.map.fastly.net.github.map.fastly.net.  600 IN  A   103.245.222.133</code></pre></blockquote><p>上面结果显示，<code>facebook.github.io</code>的 CNAME 记录指向<code>github.map.fastly.net</code>。也就是说，用户查询<code>facebook.github.io</code>的时候，实际上返回的是<code>github.map.fastly.net</code>的 IP 地址。这样的好处是，变更服务器 IP 地址的时候，只要修改<code>github.map.fastly.net</code>这个域名就可以了，用户的<code>facebook.github.io</code>域名不用修改。</p><p>由于<code>CNAME</code>记录就是一个替换，所以域名一旦设置<code>CNAME</code>记录以后，就不能再设置其他记录了（比如<code>A</code>记录和<code>MX</code>记录），这是为了防止产生冲突。举例来说，<code>foo.com</code>指向<code>bar.com</code>，而两个域名各有自己的<code>MX</code>记录，如果两者不一致，就会产生问题。由于顶级域名通常要设置<code>MX</code>记录，所以一般不允许用户对顶级域名设置<code>CNAME</code>记录。</p><p><code>PTR</code>记录用于从 IP 地址反查域名。<code>dig</code>命令的<code>-x</code>参数用于查询<code>PTR</code>记录。</p><blockquote><pre><code>$ dig -x 192.30.252.153...;; ANSWER SECTION:153.252.30.192.in-addr.arpa. 3600 IN    PTR pages.github.com.</code></pre></blockquote><p>上面结果显示，<code>192.30.252.153</code>这台服务器的域名是<code>pages.github.com</code>。</p><p>逆向查询的一个应用，是可以防止垃圾邮件，即验证发送邮件的 IP 地址，是否真的有它所声称的域名。</p><p><code>dig</code>命令可以查看指定的记录类型。</p><blockquote><pre><code>$ dig a github.com$ dig ns github.com$ dig mx github.com</code></pre></blockquote><h2 id="九、其他-DNS-工具"><a href="#九、其他-DNS-工具" class="headerlink" title="九、其他 DNS 工具"></a>九、其他 DNS 工具</h2><p>除了<code>dig</code>，还有一些其他小工具也可以使用。</p><p><strong>（1）host 命令</strong></p><p><code>host</code>命令可以看作<code>dig</code>命令的简化版本，返回当前请求域名的各种记录。</p><blockquote><pre><code>$ host github.comgithub.com has address 192.30.252.121github.com mail is handled by 5 ALT2.ASPMX.L.GOOGLE.COM.github.com mail is handled by 10 ALT4.ASPMX.L.GOOGLE.COM.github.com mail is handled by 10 ALT3.ASPMX.L.GOOGLE.COM.github.com mail is handled by 5 ALT1.ASPMX.L.GOOGLE.COM.github.com mail is handled by 1 ASPMX.L.GOOGLE.COM.$ host facebook.github.comfacebook.github.com is an alias for github.map.fastly.net.github.map.fastly.net has address 103.245.222.133</code></pre></blockquote><p><code>host</code>命令也可以用于逆向查询，即从 IP 地址查询域名，等同于<code>dig -x &lt;ip&gt;</code>。</p><blockquote><pre><code>$ host 192.30.252.153153.252.30.192.in-addr.arpa domain name pointer pages.github.com.</code></pre></blockquote><p><strong>（2）nslookup 命令</strong></p><p><code>nslookup</code>命令用于互动式地查询域名记录。</p><blockquote><pre><code>$ nslookup&gt; facebook.github.ioServer:     192.168.1.253Address:    192.168.1.253#53Non-authoritative answer:facebook.github.io  canonical name = github.map.fastly.net.Name:   github.map.fastly.netAddress: 103.245.222.133&gt;</code></pre></blockquote><p><strong>（3）whois 命令</strong></p><p><code>whois</code>命令用来查看域名的注册情况。</p><blockquote><pre><code>$ whois github.com</code></pre></blockquote><h1 id="十、参考链接"><a href="#十、参考链接" class="headerlink" title="十、参考链接"></a>十、参考链接</h1><ul><li><a href="https://www.petekeen.net/dns-the-good-parts">DNS: The Good Parts</a>, by Pete Keen</li><li><a href="http://www.integralist.co.uk/posts/dnsbasics.html">DNS 101</a>, by Mark McDonnell</li></ul><p>（完）</p><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享 3.0 许可证</a>）</li><li>发表日期： 2016 年 6 月 16 日</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 的启动流程</title>
      <link href="/posts/59504.html"/>
      <url>/posts/59504.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Linux-的启动流程"><a href="#Linux-的启动流程" class="headerlink" title="Linux 的启动流程"></a>Linux 的启动流程</h1><p>作者： <a href="http://www.ruanyifeng.com">阮一峰</a></p><p>日期： <a href="http://www.ruanyifeng.com/blog/2013/08/">2013 年 8 月 17 日</a></p><p>半年前，我写了<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">《计算机是如何启动的？》</a>，探讨 BIOS 和主引导记录的作用。</p><p>那篇文章不涉及操作系统，只与主板的板载程序有关。今天，我想接着往下写，探讨操作系统接管硬件以后发生的事情，也就是操作系统的启动流程。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201308/bg2013081701.png" alt=""></p><p>这个部分比较有意思。因为在 BIOS 阶段，计算机的行为基本上被写死了，程序员可以做的事情并不多；但是，一旦进入操作系统，程序员几乎可以定制所有方面。所以，这个部分与程序员的关系更密切。</p><p>我主要关心的是 Linux 操作系统，它是目前服务器端的主流操作系统。下面的内容针对的是<a href="http://en.wikipedia.org/wiki/Debian">Debian</a>发行版，因为我对其他发行版不够熟悉。</p><p><strong>第一步、加载内核</strong></p><p>操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201308/bg2013081702.png" alt=""></p><p>以我的电脑为例，/boot 目录下面大概是这样一些文件：</p><blockquote><pre><code>　　$ ls /boot　　　　config-3.2.0-3-amd64　　config-3.2.0-4-amd64　　grub　　initrd.img-3.2.0-3-amd64　　initrd.img-3.2.0-4-amd64　　System.map-3.2.0-3-amd64　　System.map-3.2.0-4-amd64　　vmlinuz-3.2.0-3-amd64　　vmlinuz-3.2.0-4-amd64</code></pre></blockquote><p><strong>第二步、启动初始化进程</strong></p><p>内核文件加载以后，就开始运行第一个程序 /sbin/init，它的作用是初始化系统环境。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201308/bg2013081703.png" alt=""></p><p>由于 init 是第一个运行的程序，它的进程编号（pid）就是 1。其他所有进程都从它衍生，都是它的子进程。</p><p><strong>第三步、确定运行级别</strong></p><p>许多程序需要开机启动。它们在 Windows 叫做”服务”（service），在 Linux 就叫做”<a href="http://zh.wikipedia.org/wiki/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">守护进程</a>“（daemon）。</p><p>init 进程的一大任务，就是去运行这些开机启动的程序。但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动 Apache，用作桌面就不需要。Linux 允许为不同的场合，分配不同的开机启动程序，这就叫做”<a href="http://zh.wikipedia.org/wiki/%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB">运行级别</a>“（runlevel）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201308/bg2013081704.png" alt=""></p><p>Linux 预置七种运行级别（0-6）。一般来说，0 是关机，1 是单用户模式（也就是维护模式），6 是重启。运行级别 2-5，各个发行版不太一样，对于 Debian 来说，都是同样的多用户模式（也就是正常模式）。</p><p>init 进程首先读取文件 /etc/inittab，它是运行级别的设置文件。如果你打开它，可以看到第一行是这样的：</p><blockquote><pre><code>　　　　id:2:initdefault:</code></pre></blockquote><p>initdefault 的值是 2，表明系统启动时的运行级别为 2。如果需要指定其他级别，可以手动修改这个值。</p><p>那么，运行级别 2 有些什么程序呢，系统怎么知道每个级别应该加载哪些程序呢？……回答是每个运行级别在/etc 目录下面，都有一个对应的子目录，指定要加载的程序。</p><blockquote><pre><code>　　/etc/rc0.d　　/etc/rc1.d　　/etc/rc2.d　　/etc/rc3.d　　/etc/rc4.d　　/etc/rc5.d　　/etc/rc6.d</code></pre></blockquote><p>上面目录名中的”rc”，表示 run command（运行程序），最后的 d 表示 directory（目录）。下面让我们看看 /etc/rc2.d 目录中到底指定了哪些程序。</p><blockquote><pre><code>　　$ ls  /etc/rc2.d　　　　README　　S01motd　　S13rpcbind　　S14nfs-common　　S16binfmt-support　　S16rsyslog　　S16sudo　　S17apache2　　S18acpid　　...</code></pre></blockquote><p>可以看到，除了第一个文件 README 以外，其他文件名都是”字母 S+两位数字+程序名”的形式。字母 S 表示 Start，也就是启动的意思（启动脚本的运行参数为 start），如果这个位置是字母 K，就代表 Kill（关闭），即如果从其他运行级别切换过来，需要关闭的程序（启动脚本的运行参数为 stop）。后面的两位数字表示处理顺序，数字越小越早处理，所以第一个启动的程序是 motd，然后是 rpcbing、nfs……数字相同时，则按照程序名的字母顺序启动，所以 rsyslog 会先于 sudo 启动。</p><p>这个目录里的所有文件（除了 README），就是启动时要加载的程序。如果想增加或删除某些程序，不建议手动修改 /etc/rcN.d 目录，最好是用一些专门命令进行管理（参考<a href="http://www.debianadmin.com/manage-linux-init-or-startup-scripts.html">这里</a>和<a href="http://www.debianadmin.com/remove-unwanted-startup-files-or-services-in-debian.html">这里</a>）。</p><p><strong>第四步、加载开机启动程序</strong></p><p>前面提到，七种预设的”运行级别”各自有一个目录，存放需要开机启动的程序。不难想到，如果多个”运行级别”需要启动同一个程序，那么这个程序的启动脚本，就会在每一个目录里都有一个拷贝。这样会造成管理上的困扰：如果要修改启动脚本，岂不是每个目录都要改一遍？</p><p>Linux 的解决办法，就是七个 /etc/rcN.d 目录里列出的程序，都设为链接文件，指向另外一个目录 /etc/init.d ，真正的启动脚本都统一放在这个目录中。init 进程逐一加载开机启动程序，其实就是运行这个目录里的启动脚本。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201308/bg2013081705.png" alt=""></p><p>下面就是链接文件真正的指向。</p><blockquote><pre><code>　　$ ls -l /etc/rc2.d　　　　README　　S01motd -&gt; ../init.d/motd　　S13rpcbind -&gt; ../init.d/rpcbind　　S14nfs-common -&gt; ../init.d/nfs-common　　S16binfmt-support -&gt; ../init.d/binfmt-support　　S16rsyslog -&gt; ../init.d/rsyslog　　S16sudo -&gt; ../init.d/sudo　　S17apache2 -&gt; ../init.d/apache2　　S18acpid -&gt; ../init.d/acpid　　...</code></pre></blockquote><p>这样做的另一个好处，就是如果你要手动关闭或重启某个进程，直接到目录 /etc/init.d 中寻找启动脚本即可。比如，我要重启 Apache 服务器，就运行下面的命令：</p><blockquote><pre><code>　　　　$ sudo /etc/init.d/apache2 restart</code></pre></blockquote><p>/etc/init.d 这个目录名最后一个字母 d，是 directory 的意思，表示这是一个目录，用来与程序 /etc/init 区分。</p><p><strong>第五步、用户登录</strong></p><p>开机启动程序加载完毕以后，就要让用户登录了。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201308/bg2013081706.png" alt=""></p><p>一般来说，用户的登录方式有三种：</p><blockquote><p>（1）命令行登录</p><p>（2）ssh 登录</p><p>（3）图形界面登录</p></blockquote><p>这三种情况，都有自己的方式对用户进行认证。</p><p>（1）命令行登录：init 进程调用 getty 程序（意为 get teletype），让用户输入用户名和密码。输入完成后，再调用 login 程序，核对密码（Debian 还会再多运行一个身份核对程序/etc/pam.d/login）。如果密码正确，就从文件 /etc/passwd 读取该用户指定的 shell，然后启动这个 shell。</p><p>（2）ssh 登录：这时系统调用 sshd 程序（Debian 还会再运行/etc/pam.d/ssh ），取代 getty 和 login，然后启动 shell。</p><p>（3）图形界面登录：init 进程调用显示管理器，Gnome 图形界面对应的显示管理器为 gdm（GNOME Display Manager），然后用户输入用户名和密码。如果密码正确，就读取/etc/gdm3/Xsession，启动用户的会话。</p><p><strong>第六步、进入 login shell</strong></p><p>所谓 shell，简单说就是命令行界面，让用户可以直接与操作系统对话。用户登录时打开的 shell，就叫做 login shell。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201308/bg2013081707.png" alt=""></p><p>Debian 默认的 shell 是<a href="http://zh.wikipedia.org/wiki/Bash">Bash</a>，它会读入一系列的配置文件。上一步的三种情况，在这一步的处理，也存在差异。</p><p>（1）命令行登录：首先读入 /etc/profile，这是对所有用户都有效的配置；然后依次寻找下面三个文件，这是针对当前用户的配置。</p><blockquote><pre><code>　　~/.bash_profile　　~/.bash_login　　~/.profile</code></pre></blockquote><p>需要注意的是，这三个文件只要有一个存在，就不再读入后面的文件了。比如，要是 ~/.bash_profile 存在，就不会再读入后面两个文件了。</p><p>（2）ssh 登录：与第一种情况完全相同。</p><p>（3）图形界面登录：只加载 /etc/profile 和 ~/.profile。也就是说，~/.bash_profile 不管有没有，都不会运行。</p><p><strong>第七步，打开 non-login shell</strong></p><p>老实说，上一步完成以后，Linux 的启动过程就算结束了，用户已经可以看到命令行提示符或者图形界面了。但是，为了内容的完整，必须再介绍一下这一步。</p><p>用户进入操作系统以后，常常会再手动开启一个 shell。这个 shell 就叫做 non-login shell，意思是它不同于登录时出现的那个 shell，不读取/etc/profile 和.profile 等配置文件。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201308/bg2013081708.png" alt=""></p><p>non-login shell 的重要性，不仅在于它是用户最常接触的那个 shell，还在于它会读入用户自己的 bash 配置文件 ~/.bashrc。大多数时候，我们对于 bash 的定制，都是写在这个文件里面的。</p><p>你也许会问，要是不进入 non-login shell，岂不是.bashrc 就不会运行了，因此 bash 也就不能完成定制了？事实上，Debian 已经考虑到这个问题了，请打开文件 ~/.profile，可以看到下面的代码：</p><blockquote><pre><code>　　if [ -n &quot;$BASH_VERSION&quot; ]; then　　　　if [ -f &quot;$HOME/.bashrc&quot; ]; then　　　　　　. &quot;$HOME/.bashrc&quot;　　　　fi　　fi</code></pre></blockquote><p>上面代码先判断变量 $BASH_VERSION 是否有值，然后判断主目录下是否存在 .bashrc 文件，如果存在就运行该文件。第三行开头的那个点，是 source 命令的简写形式，表示运行某个文件，写成”source ~/.bashrc”也是可以的。</p><p>因此，只要运行～/.profile 文件，～/.bashrc 文件就会连带运行。但是上一节的第一种情况提到过，如果存在～/.bash_profile 文件，那么有可能不会运行～/.profile 文件。解决这个问题很简单，把下面代码写入.bash_profile 就行了。</p><blockquote><pre><code>　　if [ -f ~/.profile ]; then　　　　. ~/.profile　　fi</code></pre></blockquote><p>这样一来，不管是哪种情况，.bashrc 都会执行，用户的设置可以放心地都写入这个文件了。</p><p>Bash 的设置之所以如此繁琐，是由于历史原因造成的。早期的时候，计算机运行速度很慢，载入配置文件需要很长时间，Bash 的作者只好把配置文件分成了几个部分，阶段性载入。系统的通用设置放在 /etc/profile，用户个人的、需要被所有子进程继承的设置放在.profile，不需要被继承的设置放在.bashrc。</p><p>顺便提一下，除了 Linux 以外， Mac OS X 使用的 shell 也是 Bash。但是，它只加载.bash_profile，然后在.bash_profile 里面调用.bashrc。而且，不管是 ssh 登录，还是在图形界面里启动 shell 窗口，都是如此。</p><p><strong>参考链接</strong></p><blockquote><p>[1] Debian Wiki, <a href="https://wiki.debian.org/EnvironmentVariables">Environment Variables</a></p><p>[2] Debian Wiki, <a href="https://wiki.debian.org/DotFiles">Dot Files</a></p><p>[3] Debian Administration, <a href="http://www.debian-administration.org/articles/212">An introduction to run-levels</a></p><p>[4] Debian Admin，<a href="http://www.debianadmin.com/debian-and-ubuntu-linux-run-levels.html">Debian and Ubuntu Linux Run Levels</a></p><p>[5] Linux Information Project (LINFO), <a href="http://www.linfo.org/runlevel_def.html">Runlevel Definition</a></p><p>[6] LinuxQuestions.org, <a href="http://wiki.linuxquestions.org/wiki/Run_Levels">What are run levels?</a></p><p>[7] Dalton Hubble, <a href="http://dghubble.com/.bashprofile-.profile-and-.bashrc-conventions.html">Bash Configurations Demystified</a></p></blockquote><p>（完）</p><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享 3.0 许可证</a>）</li><li>发表日期： 2013 年 8 月 17 日</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix 目录结构的来历</title>
      <link href="/posts/6728.html"/>
      <url>/posts/6728.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Unix-目录结构的来历"><a href="#Unix-目录结构的来历" class="headerlink" title="Unix 目录结构的来历"></a>Unix 目录结构的来历</h1><p>作者： <a href="http://www.ruanyifeng.com">阮一峰</a></p><p>日期： <a href="http://www.ruanyifeng.com/blog/2012/02/">2012 年 2 月 6 日</a></p><p>Unix（包含 Linux）的初学者，常常会很困惑，不明白目录结构的含义何在。</p><p><img src="/http://www.ruanyifeng.com/blogimg/asset/201202/bg2012020601.jpg" alt=""></p><p>举例来说，根目录下面有一个子目录/bin，用于存放二进制程序。但是，/usr 子目录下面还有/usr/bin，以及/usr/local/bin，也用于存放二进制程序；某些系统甚至还有/opt/bin。它们有何区别？</p><p>长久以来，我也感到很费解，不明白为什么这样设计。像大多数人一样，我只是根据<a href="http://www.pathname.com/fhs/pub/fhs-2.3.html">《Unix 文件系统结构标准》</a>（Filesystem Hierarchy Standard），死记硬背不同目录的区别。</p><p>昨天，我读到了 Rob Landley 的<a href="http://lists.busybox.net/pipermail/busybox/2010-December/074114.html">简短解释</a>，这才恍然大悟，原来 Unix 目录结构是历史造成的。</p><p>话说 1969 年，<a href="http://www.ruanyifeng.com/blog/2009/06/unix_turns_40.html">Ken Thompson</a>和<a href="http://www.ruanyifeng.com/blog/2011/10/dennis_ritchie.html">Dennis Ritchie</a>在小型机 PDP-7 上发明了 Unix。1971 年，他们将主机升级到了 PDP-11。</p><p><img src="/http://www.ruanyifeng.com/blogimg/asset/201202/bg2012020602.jpg" alt=""></p><p>当时，他们使用一种叫做 RK05 的储存盘，一盘的容量大约是 1.5MB。</p><p><img src="/http://www.ruanyifeng.com/blogimg/asset/201202/bg2012020603.jpg" alt=""></p><p>没过多久，操作系统（根目录）变得越来越大，一块盘已经装不下了。于是，他们加上了第二盘 RK05，并且规定第一块盘专门放系统程序，第二块盘专门放用户自己的程序，因此挂载的目录点取名为/usr。也就是说，根目录”/“挂载在第一块盘，”/usr”目录挂载在第二块盘。除此之外，两块盘的目录结构完全相同，第一块盘的目录（/bin, /sbin, /lib, /tmp…）都在/usr 目录下重新出现一次。</p><p>后来，第二块盘也满了，他们只好又加了第三盘 RK05，挂载的目录点取名为/home，并且规定/usr 用于存放用户的程序，/home 用于存放用户的数据。</p><p>从此，这种目录结构就延续了下来。随着硬盘容量越来越大，各个目录的含义进一步得到明确。</p><p><strong>/</strong>：存放系统程序，也就是 At&amp;t 开发的 Unix 程序。</p><p><strong>/usr</strong>：存放 Unix 系统商（比如 IBM 和 HP）开发的程序。</p><p><strong>/usr/local</strong>：存放用户自己安装的程序。</p><p><strong>/opt</strong>：在某些系统，用于存放第三方厂商开发的程序，所以取名为 option，意为”选装”。</p><p>（完）</p><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享 3.0 许可证</a>）</li><li>发表日期： 2012 年 2 月 6 日</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>User space 与 Kernel space</title>
      <link href="/posts/45531.html"/>
      <url>/posts/45531.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="User-space-与-Kernel-space"><a href="#User-space-与-Kernel-space" class="headerlink" title="User space 与 Kernel space"></a>User space 与 Kernel space</h1><p>作者： <a href="http://www.ruanyifeng.com">阮一峰</a></p><p>日期： <a href="http://www.ruanyifeng.com/blog/2016/12/">2016 年 12 月 2 日</a></p><p>学习 Linux 时，经常可以看到两个词：User space（用户空间）和 Kernel space（内核空间）。</p><p>简单说，Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016120201-2.png" alt=""></p><p>Kernel space 可以执行任意命令，调用系统的一切资源；User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。</p><blockquote><pre><code>str = &quot;my string&quot; // 用户空间x = x + 2file.write(str) // 切换到内核空间y = x + 4 // 切换回用户空间</code></pre></blockquote><p>上面代码中，第一行和第二行都是简单的赋值运算，在 User space 执行。第三行需要写入文件，就要切换到 Kernel space，因为用户不能直接写文件，必须通过内核安排。第四行又是赋值运算，就切换回 User space。</p><p>查看 CPU 时间在 User space 与 Kernel Space 之间的分配情况，可以使用<code>top</code>命令。它的第三行输出就是 CPU 时间分配统计。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016120202.jpg" alt=""></p><p>这一行有 8 项统计指标。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016120203-1.png" alt=""></p><p>其中，第一项<code>24.8 us</code>（user 的缩写）就是 CPU 消耗在 User space 的时间百分比，第二项<code>0.5 sy</code>（system 的缩写）是消耗在 Kernel space 的时间百分比。</p><p>随便也说一下其他 6 个指标的含义。</p><blockquote><ul><li><code>ni</code>：niceness 的缩写，CPU 消耗在 nice 进程（低优先级）的时间百分比</li><li><code>id</code>：idle 的缩写，CPU 消耗在闲置进程的时间百分比，这个值越低，表示 CPU 越忙</li><li><code>wa</code>：wait 的缩写，CPU 等待外部 I/O 的时间百分比，这段时间 CPU 不能干其他事，但是也没有执行运算，这个值太高就说明外部设备有问题</li><li><code>hi</code>：hardware interrupt 的缩写，CPU 响应硬件中断请求的时间百分比</li><li><code>si</code>：software interrupt 的缩写，CPU 响应软件中断请求的时间百分比</li><li><code>st</code>：stole time 的缩写，该项指标只对虚拟机有效，表示分配给当前虚拟机的 CPU 时间之中，被同一台物理机上的其他虚拟机偷走的时间百分比</li></ul></blockquote><p>如果想查看单个程序的耗时，一般使用<code>time</code>命令。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016120204.jpg" alt=""></p><p>程序名之前加上<code>time</code>命令，会在程序执行完毕以后，默认显示三行统计。</p><blockquote><ul><li><code>real</code>：程序从开始运行到结束的全部时间，这是用户能感知到的时间，包括 CPU 切换去执行其他任务的时间。</li><li><code>user</code>：程序在 User space 执行的时间</li><li><code>sys</code>：程序在 Kernel space 执行的时间</li></ul></blockquote><p><code>user</code>和<code>sys</code>之和，一般情况下，应该小于<code>real</code>。但如果是多核 CPU，这两个指标反映的是所有 CPU 的总耗时，所以它们之和可能大于<code>real</code>。</p><p>[参考链接]</p><blockquote><ul><li><a href="https://drawings.jvns.ca/userspace/">User space vs kernel space</a></li><li><a href="https://www.lifewire.com/linux-top-command-2201163">Using the Linux Top Command</a></li><li><a href="http://blog.scoutapp.com/articles/2015/02/24/understanding-linuxs-cpu-stats">Understanding Linux CPU stats</a></li><li><a href="http://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1">What do ‘real’, ‘user’ and ‘sys’ mean in the output of time(1)?</a></li></ul></blockquote><p>（完）</p><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享 3.0 许可证</a>）</li><li>发表日期： 2016 年 12 月 2 日</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么寄存器比内存快？</title>
      <link href="/posts/21374.html"/>
      <url>/posts/21374.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="为什么寄存器比内存快？"><a href="#为什么寄存器比内存快？" class="headerlink" title="为什么寄存器比内存快？"></a>为什么寄存器比内存快？</h1><p>作者： <a href="http://www.ruanyifeng.com">阮一峰</a></p><p>日期： <a href="http://www.ruanyifeng.com/blog/2013/10/">2013 年 10 月 14 日</a></p><p>计算机的<a href="http://zh.wikipedia.org/wiki/%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1">存储层次</a>（memory hierarchy）之中，<a href="http://zh.wikipedia.org/wiki/%E5%AF%84%E5%AD%98%E5%99%A8">寄存器</a>（register）最快，内存其次，最慢的是硬盘。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201310/2013101401.png" alt="存储层次"></p><p>同样都是晶体管存储设备，为什么寄存器比内存快呢？</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201310/2013101402.jpg" alt="晶体管"></p><p><a href="http://www.mikeash.com/pyblog/friday-qa-2013-10-11-why-registers-are-fast-and-ram-is-slow.html">Mike Ash</a>写了一篇很好的解释，非常通俗地回答了这个问题，有助于加深对硬件的理解。下面就是我的简单翻译。</p><p><strong>原因一：距离不同</strong></p><p>距离不是主要因素，但是最好懂，所以放在最前面说。内存离 CPU 比较远，所以要耗费更长的时间读取。</p><p>以 3GHz 的 CPU 为例，电流每秒钟可以振荡 30 亿次，每次耗时大约为 0.33<a href="http://en.wikipedia.org/wiki/Nanosecond">纳秒</a>。光在 1 纳秒的时间内，可以前进 30 厘米。也就是说，在 CPU 的一个<a href="http://zh.wikipedia.org/wiki/%E6%97%B6%E9%92%9F%E9%A2%91%E7%8E%87">时钟周期</a>内，光可以前进 10 厘米。因此，如果内存距离 CPU 超过 5 厘米，就不可能在一个时钟周期内完成数据的读取，这还没有考虑硬件的限制和电流实际上达不到光速。相比之下，寄存器在 CPU 内部，当然读起来会快一点。</p><p>距离对于桌面电脑影响很大，对于手机影响就要小得多。手机 CPU 的时钟频率比较慢（iPhone 5s 为 1.3GHz），而且手机的内存紧挨着 CPU。</p><p><strong>原因二：硬件设计不同</strong></p><p>苹果公司新推出的 iPhone 5s，CPU 是<a href="http://en.wikipedia.org/wiki/Apple_A7">A7</a>，寄存器有 6000 多位（31 个 64 位寄存器，加上 32 个 128 位寄存器）。而 iPhone 5s 的内存是 1GB，约为 80 亿位（bit）。这意味着，高性能、高成本、高耗电的设计可以用在寄存器上，反正只有 6000 多位，而不能用在内存上。因为每个位的成本和能耗只要增加一点点，就会被放大 80 亿倍。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201310/2013101403.jpg" alt="A7"></p><p>事实上确实如此，内存的设计相对简单，每个位就是一个电容和一个晶体管，而寄存器的<a href="http://en.wikipedia.org/wiki/Register_file#Array">设计</a>则完全不同，多出好几个电子元件。并且通电以后，寄存器的晶体管一直有电，而内存的晶体管只有用到的才有电，没用到的就没电，这样有利于省电。这些设计上的因素，决定了寄存器比内存读取速度更快。</p><p><strong>原因三：工作方式不同</strong></p><p>寄存器的工作方式很简单，只有两步：（1）找到相关的位，（2）读取这些位。</p><p>内存的工作方式就要复杂得多：</p><blockquote><p>（1）找到数据的指针。（指针可能存放在寄存器内，所以这一步就已经包括寄存器的全部工作了。）</p><p>（2）将指针送往<a href="http://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83">内存管理单元</a>（MMU），由 MMU 将虚拟的内存地址翻译成实际的物理地址。</p><p>（3）将物理地址送往内存控制器（<a href="http://en.wikipedia.org/wiki/Memory_controller">memory controller</a>），由内存控制器找出该地址在哪一根内存插槽（bank）上。</p><p>（4）确定数据在哪一个内存块（chunk）上，从该块读取数据。</p><p>（5）数据先送回内存控制器，再送回 CPU，然后开始使用。</p></blockquote><p>内存的工作流程比寄存器多出许多步。每一步都会产生延迟，累积起来就使得内存比寄存器慢得多。</p><p>为了缓解寄存器与内存之间的巨大速度差异，硬件设计师做出了许多努力，包括在 CPU 内部设置<a href="http://zh.wikipedia.org/wiki/CPU%E7%BC%93%E5%AD%98">缓存</a>、优化 CPU 工作方式，尽量一次性从内存读取指令所要用到的全部数据等等。</p><p>（完）</p><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享 3.0 许可证</a>）</li><li>发表日期： 2013 年 10 月 14 日</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根域名的知识</title>
      <link href="/posts/23017.html"/>
      <url>/posts/23017.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="根域名的知识"><a href="#根域名的知识" class="headerlink" title="根域名的知识"></a>根域名的知识</h1><p>作者： <a href="http://www.ruanyifeng.com">阮一峰</a></p><p>日期： <a href="http://www.ruanyifeng.com/blog/2018/05/">2018 年 5 月 9 日</a></p><p>域名是互联网的基础设施，只要上网就会用到。</p><p>它还是一门利润丰厚的生意，所有域名每年都必须交注册费，这是很大的一笔钱。</p><p>这些钱交到了哪里？到底谁控制域名的价格？为什么有的域名注册费很贵，有的便宜？……今天，我就来谈谈这些与根域名（root domain）相关的知识。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018050901.jpg" alt=""></p><h2 id="一、ICANN"><a href="#一、ICANN" class="headerlink" title="一、ICANN"></a>一、ICANN</h2><p>全世界域名的最高管理机构，是一个叫做 <a href="https://www.icann.org/">ICANN</a> （Internet Corporation for Assigned Names and Numbers）的组织。它的总部在美国加州。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018050902.jpg" alt=""></p><p>它原来是美国商务部下面的一个非盈利机构，所以有人说，美国政府控制了全世界的域名，这种说法是有根据的。2016 年，美国政府宣布，ICANN 不再隶属于商务部，成为一个自我管理的独立机构。但是可想而知，美国政府依然对它有绝对影响。</p><p>ICANN 负责管理全世界域名系统的运作。它的一项主要工作，就是规定顶级域名（top level domain，简写为 TLD）。</p><h2 id="二、TLD"><a href="#二、TLD" class="headerlink" title="二、TLD"></a>二、TLD</h2><p>所谓顶级域名（TLD），就是最高层级的域名。简单说，就是网址的最后一个部分。比如，网址<code>www.example.com</code>的顶级域名就是<code>.com</code>。</p><p>ICANN 就负责规定，哪些字符串可以当作顶级域名。截至 2015 年 7 月，顶级域名共有 1058 个。</p><p>它们可以分成两类。一类是一般性顶级域名（gTLD），比如<code>.com</code>、<code>.net</code>、<code>.edu</code>、<code>.org</code>、<code>.xxx</code>等等，共有 700 多个。另一类是国别顶级域名（ccTLD），代表不同的国家和地区，比如<code>.cn</code>（中国）、<code>.io</code>（英属印度洋领地）、<code>.cc</code>（ 科科斯群岛）、<code>.tv</code>（图瓦卢）等，共有 300 多个。</p><h2 id="三、顶级域名托管商"><a href="#三、顶级域名托管商" class="headerlink" title="三、顶级域名托管商"></a>三、顶级域名托管商</h2><p>ICANN 自己不会去管理这些顶级域名，因为根本管不过来。想想看，顶级域名有 1000 多个，每个顶级域名下面都有许多批发商，如果每个都要管，就太麻烦了。</p><p>ICANN 的政策是，每个顶级域名都找一个托管商，该域名的所有事项都由托管商负责。ICANN 只与托管商联系，这样管理起来就容易多了。举例来说，<code>.cn</code>域名的托管商就是<a href="http://www.cnnic.net.cn/">中国互联网络信息中心</a>（CNNIC），它决定了<code>.cn</code>域名的各种政策。</p><p>目前，世界最大的顶级域名托管商是美国的 <a href="https://www.verisign.com/">Verisign</a> 公司。</p><h2 id="四、Verisign"><a href="#四、Verisign" class="headerlink" title="四、Verisign"></a>四、Verisign</h2><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018050903.jpg" alt=""></p><p>Verisign 是一家商业公司，总部在美国维吉尼亚州。它托管了<code>.com</code>、<code>.net</code> 、<code>.name</code>、<code>.gov</code>这四个一般性顶级域名，以及<code>.cc</code>和<code>.tv</code>这两个国别顶级域名。另外，<code>.edu</code>和<code>.jobs</code>的后台管理工作，也外包给了它。</p><p>它对<code>.com</code>和<code>.net</code>的独家垄断是历史形成的。最早的时候， Network Solutions 公司接受美国国家科学基金会的委托，管理顶级域名。2000 年，Verisign 收购了这家公司，继承了域名业务。2003 年，Verisign 卖掉了域名注册业务，只保留顶级域名管理。也就是说，它只做域名批发，不做域名零售了。</p><p>2010 年，Verisign 又把网站安全和加密证书业务卖给了 Symantec 公司。后者又在 2017 年把这项业务卖给了 DigiCert。</p><h2 id="五、ICANN-与-Verisign-打官司"><a href="#五、ICANN-与-Verisign-打官司" class="headerlink" title="五、ICANN 与 Verisign 打官司"></a>五、ICANN 与 Verisign 打官司</h2><p>按理说，Verisign 是 ICANN 最大的托管商，两家的关系应该很好才对。事实却是它们的关系很差，甚至还打过官司。</p><p>原因在于，ICANN 是政府支持的非盈利机构，不以盈利为目标，而 Verisign 是一家商业公司，追求利润最大化，每年必须交大量的托管费给前者。两家的矛盾就源于此。</p><p>2003 年，Verisign 推出了一项新业务 Site Finder，用户访问没有注册过的<code>.com</code>或<code>.net</code>域名，都会被导向 Verisign 的网站。这意味着，它事实上拥有了所有没有注册过的<code>.com</code>和<code>.net</code>域名。 几天之内，Verisign 就挤入了全世界的前 10 大网站。</p><p>ICANN 要求 Verisign 立刻停止该业务，否则将终止域名托管合同。Verisign 屈服了，停止了这项业务，但是接着就把 ICANN 告上了法庭，要求法庭厘请两者之间的合同，ICANN 到底有没有权力干涉它的业务。</p><p>2006 年底，它们达成了庭外和解。ICANN 同意延长 Verisign 的顶级域名托管合同，并且同意 Verisign 向消费者收取的单个域名注册费的上限，从 6 美元提高到了 7.85 美元。这个费用标准，一直沿用到了今天，你去注册一个<code>.com</code>或<code>.net</code>域名，所交的钱有 0.18 美元是 ICANN 收取的管理费，7.85 美元是 Verisign 收取的托管费，其余的钱就是域名零售商的费用。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018050904.png" alt=""></p><p>如果一个<code>.com</code>或<code>.net</code>域名售价 10 美元，ICANN 和 Verisign 合计拿走 8.03 美元。</p><p>后来，Verisign 的顶级域名托管合同又延长过两次，当前合同要到 2024 年才会到期。</p><p>表面上看，ICANN 让 Verisign 获得了巨额垄断利润。（曾经有公司提出，只要让它来托管<code>.com</code>域名，单个域名的托管费，可以降低到每年 1 美元。）但是实际上，ICANN 通过另一种方式在发挥市场的力量，那就是它不断提高顶级域名的数量和品种。如果你觉得<code>.com</code>域名太贵，你完全可以申请其他的顶级域名，有 1000 多个顶级域名任你选择。</p><h2 id="六、根域名"><a href="#六、根域名" class="headerlink" title="六、根域名"></a>六、根域名</h2><p>由于 ICANN 管理着所有的顶级域名，所以它是最高一级的域名节点，被称为根域名（root domain）。在有些场合，<code>www.example.com</code>被写成<code>www.example.com.</code>，即最后还会多出一个点。这个点就是根域名。</p><p>理论上，所有域名查询都必须先查询根域名，因为只有根域名才能告诉你，某个顶级域名由哪台服务器管理。事实上也确实如此，ICANN 维护着一张列表，里面记载着顶级域名和对应的托管商。</p><p>比如，我要访问<code>www.example.com</code>，就必须先询问 ICANN 的根域名列表，它会告诉我<code>.com</code>域名由 Verisign 托管，我必须去找 Verisign，它会告诉我<code>example.com</code>服务器在哪里。</p><p>再比如，我要访问<code>abc.xyz</code>，也必须先去询问根域名列表，它会告诉我<code>.xyz</code>域名由 CentralNic 公司托管。根域名列表还记载，<code>.google</code>由谷歌公司托管，<code>.apple</code>由苹果公司托管等等。</p><p>由于根域名列表很少变化，大多数 DNS 服务商都会提供它的缓存，所以根域名的查询事实上不是那么频繁。</p><h2 id="七、DNS-根区"><a href="#七、DNS-根区" class="headerlink" title="七、DNS 根区"></a>七、DNS 根区</h2><p>根域名列表的正式名称是 <a href="https://en.wikipedia.org/wiki/DNS_root_zone">DNS 根区</a>（DNS root zone），ICANN 官网可以<a href="https://www.iana.org/domains/root/files">查看</a>这个<a href="https://www.internic.net/domain/root.zone">根区文件</a>。</p><p>该文件保存所有顶级域名的托管信息，所以非常大，超过 2MB。</p><p>举例来说，顶级域名<code>.com</code>可以查到 13 个域名服务器。</p><blockquote><pre><code>com.            172800  IN  NS  a.gtld-servers.net.com.            172800  IN  NS  b.gtld-servers.net.com.            172800  IN  NS  c.gtld-servers.net.com.            172800  IN  NS  d.gtld-servers.net.com.            172800  IN  NS  e.gtld-servers.net.com.            172800  IN  NS  f.gtld-servers.net.com.            172800  IN  NS  g.gtld-servers.net.com.            172800  IN  NS  h.gtld-servers.net.com.            172800  IN  NS  i.gtld-servers.net.com.            172800  IN  NS  j.gtld-servers.net.com.            172800  IN  NS  k.gtld-servers.net.com.            172800  IN  NS  l.gtld-servers.net.com.            172800  IN  NS  m.gtld-servers.net.</code></pre></blockquote><p>也就是说，<code>.com</code>域名的解析结果，可以到这个 13 个服务器的任一台查询。细心的读者可能发现，这些服务器本身也是使用域名（比如<code>a.gtld-servers.net.</code>）标识，那么还得去查询它们指向的服务器，这样很容易造成循环查询。</p><p>因此，DNS 根区还会同时提供这些服务器的 IP 地址（IPv4 和 IPv6）。</p><blockquote><pre><code>a.gtld-servers.net. 172800  IN  A   192.5.6.30a.gtld-servers.net. 172800  IN  AAAA    2001:503:a83e:0:0:0:2:30b.gtld-servers.net. 172800  IN  A   192.33.14.30b.gtld-servers.net. 172800  IN  AAAA    2001:503:231d:0:0:0:2:30c.gtld-servers.net. 172800  IN  A   192.26.92.30c.gtld-servers.net. 172800  IN  AAAA    2001:503:83eb:0:0:0:0:30... ...</code></pre></blockquote><h2 id="八、根域名服务器"><a href="#八、根域名服务器" class="headerlink" title="八、根域名服务器"></a>八、根域名服务器</h2><p>保存 DNS 根区文件的服务器，就叫做 DNS 根域名服务器（root name server）。</p><p>由于早期的 DNS 查询结果是一个 512 字节的 UDP 数据包。这个包最多可以容纳 13 个服务器的地址，因此就规定全世界有 13 个根域名服务器，编号从<code>a.root-servers.net</code>一直到<code>m.root-servers.net</code>。</p><p>这 13 台根域名服务器由 12 个组织独立运营。其中，Verisign 公司管理两台根域名服务器：A 和 J。每家公司为了保证根域名服务器的可用性，会部署多个节点，比如单单 Verisign 一家公司就部署了 104 台根域名服务器（2016 年 1 月数据）。</p><p>所以，根域名服务器其实<a href="https://www.icann.org/news/blog/there-are-not-13-root-servers">不止 13 台</a>。据统计，截止 2016 年 1 月，全世界共有 517 台根域名服务器。你可以在 <a href="http://root-servers.org">http://root-servers.org</a> 这个网站查到所有根域名服务器的信息。</p><p>根域名服务器虽然有域名，但是最少必须知道一台的 IP 地址，否则就会陷入循环查询。一般来说，本机都保存一份根域名服务器的 IP 地址的缓存，叫做 <a href="https://www.internic.net/zones/named.cache">name.cache</a> 文件。</p><blockquote><pre><code>A.ROOT-SERVERS.NET.   3600000 A 198.41.0.4A.ROOT-SERVERS.NET.   3600000 AAAA 2001:503:ba3e :: 2:30B.ROOT-SERVERS.NET.   3600000 A 199.9.14.201B.ROOT-SERVERS.NET.   3600000 AAAA 2001:500:200 :: bC.ROOT-SERVERS.NET.   3600000 A 192.33.4.12C.ROOT-SERVERS.NET.   3600000 AAAA 2001:500:2 :: c... ...</code></pre></blockquote><p>这个文件记录了 13 台根域名服务器的 IP 地址。</p><h2 id="九、参考链接"><a href="#九、参考链接" class="headerlink" title="九、参考链接"></a>九、参考链接</h2><ul><li><a href="https://taimur.me/domain-names/">What actually happens when you buy a domain name?</a>, by Taimur</li><li><a href="https://en.wikipedia.org/wiki/ICANN">ICANN</a>, by Wikipedia</li><li><a href="https://en.wikipedia.org/wiki/Verisign">Verisign</a>, by Wikipedia</li><li><a href="https://en.wikipedia.org/wiki/Root_name_server">DNS root zone</a>, by Wikipedia</li><li><a href="https://en.wikipedia.org/wiki/Root_name_server">Root Name Server</a>, by Wikipedia</li></ul><p>（完）</p><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享 3.0 许可证</a>）</li><li>发表日期： 2018 年 5 月 9 日</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解字节序</title>
      <link href="/posts/1810.html"/>
      <url>/posts/1810.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="理解字节序"><a href="#理解字节序" class="headerlink" title="理解字节序"></a>理解字节序</h1><p>作者： <a href="http://www.ruanyifeng.com">阮一峰</a></p><p>日期： <a href="http://www.ruanyifeng.com/blog/2016/11/">2016 年 11 月 22 日</a></p><p>1.</p><p>计算机硬件有两种储存数据的方式：大端字节序（big endian）和小端字节序（little endian）。</p><p>举例来说，数值<code>0x2211</code>使用两个字节储存：高位字节是<code>0x22</code>，低位字节是<code>0x11</code>。</p><blockquote><ul><li><strong>大端字节序</strong>：高位字节在前，低位字节在后，这是人类读写数值的方法。</li><li><strong>小端字节序</strong>：低位字节在前，高位字节在后，即以<code>0x1122</code>形式储存。</li></ul></blockquote><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016112202.jpg" alt=""></p><p>同理，<code>0x1234567</code>的大端字节序和小端字节序的写法如下图。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016112201.gif" alt=""></p><p>2.</p><p>我一直不理解，为什么要有字节序，每次读写都要区分，多麻烦！统一使用大端字节序，不是更方便吗？</p><p>上周，我读到了一篇<a href="http://blog.erratasec.com/2016/11/how-to-teach-endian.html">文章</a>，解答了所有的疑问。而且，我发现原来的理解是错的，字节序其实很简单。</p><p>3.</p><p>首先，为什么会有小端字节序？</p><p>答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。</p><p>但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</p><p>4.</p><p>计算机处理字节序的时候，不知道什么是高位字节，什么是低位字节。它只知道按顺序读取字节，先读第一个字节，再读第二个字节。</p><p>如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。</p><p>理解这一点，才能理解计算机如何处理字节序。</p><p>5.</p><p>字节序的处理，就是一句话：</p><blockquote><p><strong>“只有读取的时候，才必须区分字节序，其他情况都不用考虑。”</strong></p></blockquote><p>处理器读取外部数据的时候，必须知道数据的字节序，将其转成正确的值。然后，就正常使用这个值，完全不用再考虑字节序。</p><p>即使是向外部设备写入数据，也不用考虑字节序，正常写入一个值即可。外部设备会自己处理字节序的问题。</p><p>6.</p><p>举例来说，处理器读入一个 16 位整数。如果是大端字节序，就按下面的方式转成值。</p><blockquote><pre><code>x = buf[offset] * 256 + buf[offset+1];</code></pre></blockquote><p>上面代码中，<code>buf</code>是整个数据块在内存中的起始地址，<code>offset</code>是当前正在读取的位置。第一个字节乘以 256，再加上第二个字节，就是大端字节序的值，这个式子可以用逻辑运算符改写。</p><blockquote><pre><code>x = buf[offset]&lt;&lt;8 | buf[offset+1];</code></pre></blockquote><p>上面代码中，第一个字节左移 8 位（即后面添 8 个<code>0</code>），然后再与第二个字节进行或运算。</p><p>如果是小端字节序，用下面的公式转成值。</p><blockquote><pre><code>x = buf[offset+1] * 256 + buf[offset];</code></pre></blockquote><p>32 位整数的求值公式也是一样的。</p><blockquote><pre><code>/* 大端字节序 */i = (data[3]&lt;&lt;0) | (data[2]&lt;&lt;8) | (data[1]&lt;&lt;16) | (data[0]&lt;&lt;24);/* 小端字节序 */i = (data[0]&lt;&lt;0) | (data[1]&lt;&lt;8) | (data[2]&lt;&lt;16) | (data[3]&lt;&lt;24);</code></pre></blockquote><p>（完）</p><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享 3.0 许可证</a>）</li><li>发表日期： 2016 年 11 月 22 日</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译器的工作过程</title>
      <link href="/posts/7966.html"/>
      <url>/posts/7966.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="编译器的工作过程"><a href="#编译器的工作过程" class="headerlink" title="编译器的工作过程"></a>编译器的工作过程</h1><p>作者： <a href="http://www.ruanyifeng.com">阮一峰</a></p><p>日期： <a href="http://www.ruanyifeng.com/blog/2014/11/">2014 年 11 月 11 日</a></p><p>源码要运行，必须先转成二进制的机器码。这是编译器的任务。</p><p>比如，下面这段源码（假定文件名叫做 test.c）。</p><blockquote><pre><code>#include &lt;stdio.h&gt;int main(void)&#123;  fputs(&quot;Hello, world!\n&quot;, stdout);  return 0;&#125;</code></pre></blockquote><p>要先用编译器处理一下，才能运行。</p><blockquote><pre><code>$ gcc test.c$ ./a.outHello, world!</code></pre></blockquote><p>对于复杂的项目，编译过程还必须分成三步。</p><blockquote><pre><code>$ ./configure$ make$ make install</code></pre></blockquote><p>这些命令到底在干什么？大多数的书籍和资料，都语焉不详，只说这样就可以编译了，没有进一步的解释。</p><p>本文将介绍编译器的工作过程，也就是上面这三个命令各自的任务。我主要参考了 Alex Smith 的文章<a href="http://nethack4.org/blog/building-c.html">《Building C Projects》</a>。需要声明的是，本文主要针对 gcc 编译器，也就是针对 C 和 C++，不一定适用于其他语言的编译。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014110803.png" alt=""></p><h2 id="第一步-配置（configure）"><a href="#第一步-配置（configure）" class="headerlink" title="第一步 配置（configure）"></a>第一步 配置（configure）</h2><p>编译器在开始工作之前，需要知道当前的系统环境，比如标准库在哪里、软件的安装位置在哪里、需要安装哪些组件等等。这是因为不同计算机的系统环境不一样，通过指定编译参数，编译器就可以灵活适应环境，编译出各种环境都能运行的机器码。这个确定编译参数的步骤，就叫做”配置”（configure）。</p><p>这些配置信息保存在一个配置文件之中，约定俗成是一个叫做 configure 的脚本文件。通常它是由<a href="http://zh.wikipedia.org/wiki/Autoconf">autoconf</a>工具生成的。编译器通过运行这个脚本，获知编译参数。</p><p>configure 脚本已经尽量考虑到不同系统的差异，并且对各种编译参数给出了默认值。如果用户的系统环境比较特别，或者有一些特定的需求，就需要手动向 configure 脚本提供编译参数。</p><blockquote><pre><code>$ ./configure --prefix=/www --with-mysql</code></pre></blockquote><p>上面代码是 php 源码的一种编译配置，用户指定安装后的文件保存在 www 目录，并且编译时加入 mysql 模块的支持。</p><h2 id="第二步-确定标准库和头文件的位置"><a href="#第二步-确定标准库和头文件的位置" class="headerlink" title="第二步 确定标准库和头文件的位置"></a>第二步 确定标准库和头文件的位置</h2><p>源码肯定会用到标准库函数（standard library）和头文件（header）。它们可以存放在系统的任意目录中，编译器实际上没办法自动检测它们的位置，只有通过配置文件才能知道。</p><p>编译的第二步，就是从配置文件中知道标准库和头文件的位置。一般来说，配置文件会给出一个清单，列出几个具体的目录。等到编译时，编译器就按顺序到这几个目录中，寻找目标。</p><h2 id="第三步-确定依赖关系"><a href="#第三步-确定依赖关系" class="headerlink" title="第三步 确定依赖关系"></a>第三步 确定依赖关系</h2><p>对于大型项目来说，源码文件之间往往存在依赖关系，编译器需要确定编译的先后顺序。假定 A 文件依赖于 B 文件，编译器应该保证做到下面两点。</p><blockquote><p>（1）只有在 B 文件编译完成后，才开始编译 A 文件。</p><p>（2）当 B 文件发生变化时，A 文件会被重新编译。</p></blockquote><p>编译顺序保存在一个叫做 makefile 的文件中，里面列出哪个文件先编译，哪个文件后编译。而 makefile 文件由 configure 脚本运行生成，这就是为什么编译时 configure 必须首先运行的原因。</p><p>在确定依赖关系的同时，编译器也确定了，编译时会用到哪些头文件。</p><h2 id="第四步-头文件的预编译（precompilation）"><a href="#第四步-头文件的预编译（precompilation）" class="headerlink" title="第四步 头文件的预编译（precompilation）"></a>第四步 头文件的预编译（precompilation）</h2><p>不同的源码文件，可能引用同一个头文件（比如 stdio.h）。编译的时候，头文件也必须一起编译。为了节省时间，编译器会在编译源码之前，先编译头文件。这保证了头文件只需编译一次，不必每次用到的时候，都重新编译了。</p><p>不过，并不是头文件的所有内容，都会被预编译。用来声明宏的#define 命令，就不会被预编译。</p><h2 id="第五步-预处理（Preprocessing）"><a href="#第五步-预处理（Preprocessing）" class="headerlink" title="第五步 预处理（Preprocessing）"></a>第五步 预处理（Preprocessing）</h2><p>预编译完成后，编译器就开始替换掉源码中 bash 的头文件和宏。以本文开头的那段源码为例，它包含头文件 stdio.h，替换后的样子如下。</p><blockquote><pre><code>extern int fputs(const char *, FILE *);extern FILE *stdout;int main(void)&#123;    fputs(&quot;Hello, world!\n&quot;, stdout);    return 0;&#125;</code></pre></blockquote><p>为了便于阅读，上面代码只截取了头文件中与源码相关的那部分，即 fputs 和 FILE 的声明，省略了 stdio.h 的其他部分（因为它们非常长）。另外，上面代码的头文件没有经过预编译，而实际上，插入源码的是预编译后的结果。编译器在这一步还会移除注释。</p><p>这一步称为”预处理”（Preprocessing），因为完成之后，就要开始真正的处理了。</p><h2 id="第六步-编译（Compilation）"><a href="#第六步-编译（Compilation）" class="headerlink" title="第六步 编译（Compilation）"></a>第六步 编译（Compilation）</h2><p>预处理之后，编译器就开始生成机器码。对于某些编译器来说，还存在一个中间步骤，会先把源码转为汇编码（assembly），然后再把汇编码转为机器码。</p><p>下面是本文开头的那段源码转成的汇编码。</p><blockquote><pre><code>    .file   &quot;test.c&quot;    .section    .rodata    .LC0:    .string &quot;Hello, world!\n&quot;    .text    .globl  main    .type   main, @function    main:    .LFB0:    .cfi_startproc    pushq   %rbp    .cfi_def_cfa_offset 16    .cfi_offset 6, -16    movq    %rsp, %rbp    .cfi_def_cfa_register 6    movq    stdout(%rip), %rax    movq    %rax, %rcx    movl    $14, %edx    movl    $1, %esi    movl    $.LC0, %edi    call    fwrite    movl    $0, %eax    popq    %rbp    .cfi_def_cfa 7, 8    ret    .cfi_endproc    .LFE0:    .size   main, .-main    .ident  &quot;GCC: (Debian 4.9.1-19) 4.9.1&quot;    .section    .note.GNU-stack,&quot;&quot;,@progbits</code></pre></blockquote><p>这种转码后的文件称为对象文件（object file）。</p><h2 id="第七步-连接（Linking）"><a href="#第七步-连接（Linking）" class="headerlink" title="第七步 连接（Linking）"></a>第七步 连接（Linking）</h2><p>对象文件还不能运行，必须进一步转成可执行文件。如果你仔细看上一步的转码结果，会发现其中引用了 stdout 函数和 fwrite 函数。也就是说，程序要正常运行，除了上面的代码以外，还必须有 stdout 和 fwrite 这两个函数的代码，它们是由 C 语言的标准库提供的。</p><p>编译器的下一步工作，就是把外部函数的代码（通常是后缀名为.lib 和.a 的文件），添加到可执行文件中。这就叫做连接（linking）。这种通过拷贝，将外部函数库添加到可执行文件的方式，叫做<a href="http://zh.wikipedia.org/zh-cn/%E9%9D%9C%E6%85%8B%E9%80%A3%E7%B5%90%E5%87%BD%E5%BC%8F%E5%BA%AB">静态连接</a>（static linking），后文会提到还有<a href="http://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93">动态连接</a>（dynamic linking）。</p><p>make 命令的作用，就是从第四步头文件预编译开始，一直到做完这一步。</p><h2 id="第八步-安装（Installation）"><a href="#第八步-安装（Installation）" class="headerlink" title="第八步 安装（Installation）"></a>第八步 安装（Installation）</h2><p>上一步的连接是在内存中进行的，即编译器在内存中生成了可执行文件。下一步，必须将可执行文件保存到用户事先指定的安装目录。</p><p>表面上，这一步很简单，就是将可执行文件（连带相关的数据文件）拷贝过去就行了。但是实际上，这一步还必须完成创建目录、保存文件、设置权限等步骤。这整个的保存过程就称为”安装”（Installation）。</p><h2 id="第九步-操作系统连接"><a href="#第九步-操作系统连接" class="headerlink" title="第九步 操作系统连接"></a>第九步 操作系统连接</h2><p>可执行文件安装后，必须以某种方式通知操作系统，让其知道可以使用这个程序了。比如，我们安装了一个文本阅读程序，往往希望双击 txt 文件，该程序就会自动运行。</p><p>这就要求在操作系统中，登记这个程序的元数据：文件名、文件描述、关联后缀名等等。Linux 系统中，这些信息通常保存在/usr/share/applications 目录下的.desktop 文件中。另外，在 Windows 操作系统中，还需要在 Start 启动菜单中，建立一个快捷方式。</p><p>这些事情就叫做”操作系统连接”。make install 命令，就用来完成”安装”和”操作系统连接”这两步。</p><h2 id="第十步-生成安装包"><a href="#第十步-生成安装包" class="headerlink" title="第十步 生成安装包"></a>第十步 生成安装包</h2><p>写到这里，源码编译的整个过程就基本完成了。但是只有很少一部分用户，愿意耐着性子，从头到尾做一遍这个过程。事实上，如果你只有源码可以交给用户，他们会认定你是一个不友好的家伙。大部分用户要的是一个二进制的可执行程序，立刻就能运行。这就要求开发者，将上一步生成的可执行文件，做成可以分发的安装包。</p><p>所以，编译器还必须有生成安装包的功能。通常是将可执行文件（连带相关的数据文件），以某种目录结构，保存成压缩文件包，交给用户。</p><h2 id="第十一步-动态连接（Dynamic-linking）"><a href="#第十一步-动态连接（Dynamic-linking）" class="headerlink" title="第十一步 动态连接（Dynamic linking）"></a>第十一步 动态连接（Dynamic linking）</h2><p>正常情况下，到这一步，程序已经可以运行了。至于运行期间（runtime）发生的事情，与编译器一概无关。但是，开发者可以在编译阶段选择可执行文件连接外部函数库的方式，到底是静态连接（编译时连接），还是动态连接（运行时连接）。所以，最后还要提一下，什么叫做动态连接。</p><p>前面已经说过，静态连接就是把外部函数库，拷贝到可执行文件中。这样做的好处是，适用范围比较广，不用担心用户机器缺少某个库文件；缺点是安装包会比较大，而且多个应用程序之间，无法共享库文件。动态连接的做法正好相反，外部函数库不进入安装包，只在运行时动态引用。好处是安装包会比较小，多个应用程序可以共享库文件；缺点是用户必须事先安装好库文件，而且版本和安装位置都必须符合要求，否则就不能正常运行。</p><p>现实中，大部分软件采用动态连接，共享库文件。这种动态共享的库文件，Linux 平台是后缀名为.so 的文件，Windows 平台是.dll 文件，Mac 平台是.dylib 文件。</p><p>（文章完）</p><p>=====================================================</p><p>以下为广告部分。欢迎大家在我的网络日志<a href="http://www.ruanyifeng.com/ads.html">投放广告</a>，推广自己的产品。今天介绍的是<a href="https://100offer.com/join/ruanyifeng">100offer</a>。</p><p><strong>[赞助商广告]</strong></p><p>优秀的人才找到合适的归宿，是这个世界最幸福的事情之一。<a href="https://100offer.com/join/ruanyifeng">100offer 程序员拍卖网站</a>通过创新的拍卖方式，致力于帮助优秀程序员寻找归宿，给予求职者更多更好的职业选择。</p><p><a href="https://100offer.com/join/ruanyifeng"><img src="http://www.ruanyifeng.com/blogimg/asset/2014/ad2014110301.jpg" alt=""></a></p><p>过去三个月，100offer 中成功的求职者，平均薪资涨幅高于 30%，在 2 周内拿到 3-5 个 offer。100offer 与传统招聘网站存在极大差异，主要为下：</p><p>1、只接受部分候选人：100offer 目前仅仅接受年薪高于 15 万，有一二线知名互联网公司工作经验的优秀程序员申请者。</p><p>2、反向模式：传统招聘网站是写简历投递给多家公司，而这里程序员只需要提交一次简历给 offer，待审核通过后，100offer 会邀约平台企业来竞拍候选人，产生一次投递数百家互联网公司的效果。拍卖时程序员会接受到来自各公司新鲜热辣的面试邀请，体验与传统网站截然不同。</p><p>3、绝对隐私：担心自己的隐私被雇主看到是完全不必要的：1、候选人同意面试邀请前，公司是完全看不到候选人的姓名、联系方式等隐私信息。2、拍卖开始前，候选人可以手动屏蔽掉 3 家公司，他们将永远看不到你的简历！</p><p><a href="https://100offer.com/join/ruanyifeng"><img src="http://www.ruanyifeng.com/blogimg/asset/2014/ad2014110302.jpg" alt=""></a></p><p>已经有众多大牛程序员通过 100offer 找到心仪的工作，目前 11 月候选人在征集中，点击图片<a href="https://100offer.com/join/ruanyifeng">注册 100offer</a>并提交完整简历的程序员朋友，即可获赠 15 元亚马逊礼品卡！（活动截止期为 2014 年 12 月 30 日）</p><p>100offer 目前阶段对企业免费，欢迎极客型创业公司和有实力的互联网公司前来<a href="http://www.100offer.com/join/ruanyifenghr">注册招聘</a>！</p><p>（完）</p><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享 3.0 许可证</a>）</li><li>发表日期： 2014 年 11 月 11 日</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编译器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机是如何启动的？</title>
      <link href="/posts/392.html"/>
      <url>/posts/392.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计算机是如何启动的？"><a href="#计算机是如何启动的？" class="headerlink" title="计算机是如何启动的？"></a>计算机是如何启动的？</h1><p>作者： <a href="http://www.ruanyifeng.com">阮一峰</a></p><p>日期： <a href="http://www.ruanyifeng.com/blog/2013/02/">2013 年 2 月 16 日</a></p><p>从打开电源到开始操作，计算机的启动是一个非常复杂的过程。</p><p><img src="/http://www.ruanyifeng.com/blogimg/asset/201302/bg2013021501.jpg" alt=""></p><p>我一直搞不清楚，这个过程到底是怎么回事，只看见屏幕快速滚动各种提示…… 这几天，我查了一些资料，试图搞懂它。下面就是我整理的笔记。</p><p><strong>零、boot 的含义</strong></p><p>先问一个问题，”启动”用英语怎么说？</p><p>回答是 boot。可是，boot 原来的意思是靴子，”启动”与靴子有什么关系呢？ 原来，这里的 boot 是 bootstrap（鞋带）的缩写，它来自一句谚语：</p><blockquote><p>“pull oneself up by one’s bootstraps”</p></blockquote><p>字面意思是”拽着鞋带把自己拉起来”，这当然是不可能的事情。最早的时候，工程师们用它来比喻，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！</p><p>早期真的是这样，必须想尽各种办法，把一小段程序装进内存，然后计算机才能正常运行。所以，工程师们把这个过程叫做”拉鞋带”，久而久之就简称为 boot 了。</p><p>计算机的整个启动过程分成四个阶段。</p><p><strong>一、第一阶段：BIOS</strong></p><p>上个世纪 70 年代初，”只读内存”（read-only memory，缩写为 ROM）发明，开机程序被刷入 ROM 芯片，计算机通电后，第一件事就是读取它。</p><p><img src="/http://www.ruanyifeng.com/blogimg/asset/201302/bg2013021502.jpg" alt=""></p><p>这块芯片里的程序叫做”基本輸出輸入系統”（Basic Input/Output System），简称为<a href="http://en.wikipedia.org/wiki/BIOS">BIOS</a>。</p><p><strong>1.1 硬件自检</strong></p><p>BIOS 程序首先检查，计算机硬件能否满足运行的基本条件，这叫做”硬件自检”（Power-On Self-Test），缩写为<a href="http://en.wikipedia.org/wiki/Power-on_self-test">POST</a>。</p><p>如果硬件出现问题，主板会发出不同含义的<a href="http://en.wikipedia.org/wiki/Power-on_self-test#Original_IBM_POST_beep_codes">蜂鸣</a>，启动中止。如果没有问题，屏幕就会显示出 CPU、内存、硬盘等信息。</p><p><img src="/http://www.ruanyifeng.com/blogimg/asset/201302/bg2013021503.png" alt=""></p><p><strong>1.2 启动顺序</strong></p><p>硬件自检完成后，BIOS 把控制权转交给下一阶段的启动程序。</p><p>这时，BIOS 需要知道，”下一阶段的启动程序”具体存放在哪一个设备。也就是说，BIOS 需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot Sequence）。</p><p>打开 BIOS 的操作界面，里面有一项就是”设定启动顺序”。</p><p><img src="/http://www.ruanyifeng.com/blogimg/asset/201302/bg2013021504.jpg" alt=""></p><p><strong>二、第二阶段：主引导记录</strong></p><p>BIOS 按照”启动顺序”，把控制权转交给排在第一位的储存设备。</p><p>这时，计算机读取该设备的第一个扇区，也就是读取最前面的 512 个字节。如果这 512 个字节的最后两个字节是 0x55 和 0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。</p><p>这最前面的 512 个字节，就叫做<a href="http://en.wikipedia.org/wiki/Master_boot_record">“主引导记录”</a>（Master boot record，缩写为 MBR）。</p><p><strong>2.1 主引导记录的结构</strong></p><p>“主引导记录”只有 512 个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。</p><p>主引导记录由三个部分组成：</p><blockquote><p>（1） 第 1-446 字节：调用操作系统的机器码。</p><p>（2） 第 447-510 字节：分区表（Partition table）。</p><p>（3） 第 511-512 字节：主引导记录签名（0x55 和 0xAA）。</p></blockquote><p>其中，第二部分”分区表”的作用，是将硬盘分成若干个区。</p><p><strong>2.2 分区表</strong></p><p>硬盘分区有很多<a href="http://en.wikipedia.org/wiki/Disk_partitioning#Benefits_of_multiple_partitions">好处</a>。考虑到每个区可以安装不同的操作系统，”主引导记录”因此必须知道将控制权转交给哪个区。</p><p>分区表的长度只有 64 个字节，里面又分成四项，每项 16 个字节。所以，一个硬盘最多只能分四个一级分区，又叫做”主分区”。</p><p>每个主分区的 16 个字节，由 6 个部分组成：</p><blockquote><p>（1） 第 1 个字节：如果为 0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。</p><p>（2） 第 2-4 个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。</p><p>（3） 第 5 个字节：<a href="http://en.wikipedia.org/wiki/Partition_type">主分区类型</a>。</p><p>（4） 第 6-8 个字节：主分区最后一个扇区的物理位置。</p><p>（5） 第 9-12 字节：该主分区第一个扇区的逻辑地址。</p><p>（6） 第 13-16 字节：主分区的扇区总数。</p></blockquote><p>最后的四个字节（”主分区的扇区总数”），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过 2 的 32 次方。</p><p>如果每个扇区为 512 个字节，就意味着单个分区最大不超过 2TB。再考虑到扇区的逻辑地址也是 32 位，所以单个硬盘可利用的空间最大也不超过 2TB。如果想使用更大的硬盘，只有 2 个方法：一是提高每个扇区的字节数，二是<a href="http://en.wikipedia.org/wiki/GUID_Partition_Table">增加扇区总数</a>。</p><p><strong>三、第三阶段：硬盘启动</strong></p><p>这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。</p><p><strong>3.1 情况 A：卷引导记录</strong></p><p>上一节提到，四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做<a href="http://en.wikipedia.org/wiki/Volume_Boot_Record">“卷引导记录</a>“（Volume boot record，缩写为 VBR）。</p><p>“卷引导记录”的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。</p><p><strong>3.2 情况 B：扩展分区和逻辑分区</strong></p><p>随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成”扩展分区”（Extended partition）。</p><p>所谓”扩展分区”，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做”逻辑分区”（logical partition）。</p><p>计算机先读取扩展分区的第一个扇区，叫做<a href="http://en.wikipedia.org/wiki/Extended_partition">“扩展引导记录”</a>（Extended boot record，缩写为 EBR）。它里面也包含一张 64 字节的分区表，但是最多只有两项（也就是两个逻辑分区）。</p><p>计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。</p><p>但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。</p><p><strong>3.3 情况 C：启动管理器</strong></p><p>在这种情况下，计算机读取”主引导记录”前面 446 字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的<a href="http://en.wikipedia.org/wiki/Boot_loader#Modern_boot_loaders">“启动管理器”</a>（boot loader），由用户选择启动哪一个操作系统。</p><p>Linux 环境中，目前最流行的启动管理器是<a href="http://en.wikipedia.org/wiki/GNU_GRUB">Grub</a>。</p><p><img src="/http://www.ruanyifeng.com/blogimg/asset/201302/bg2013021505.png" alt=""></p><p><strong>四、第四阶段：操作系统</strong></p><p>控制权转交给操作系统后，操作系统的内核首先被载入内存。</p><p>以 Linux 系统为例，先载入/boot 目录下面的 kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian 系统是/etc/initab）产生 init 进程。这是 Linux 启动后的第一个进程，pid 进程编号为 1，其他进程都是它的后代。</p><p>然后，init 线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login 程序，跳出登录界面，等待用户输入用户名和密码。</p><p>至此，全部启动过程完成。</p><p>（完）</p><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享 3.0 许可证</a>）</li><li>发表日期： 2013 年 2 月 16 日</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程与线程的一个简单解释</title>
      <link href="/posts/62498.html"/>
      <url>/posts/62498.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="进程与线程的一个简单解释"><a href="#进程与线程的一个简单解释" class="headerlink" title="进程与线程的一个简单解释"></a>进程与线程的一个简单解释</h1><p>作者： <a href="http://www.ruanyifeng.com">阮一峰</a></p><p>日期： <a href="http://www.ruanyifeng.com/blog/2013/04/">2013 年 4 月 24 日</a></p><p><a href="https://zh.wikipedia.org/zh-cn/%E8%BF%9B%E7%A8%8B">进程</a>（process）和<a href="https://zh.wikipedia.org/zh-cn/%E7%BA%BF%E7%A8%8B">线程</a>（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。</p><p>最近，我读到一篇<a href="http://www.qnx.com/developers/docs/6.4.1/neutrino/getting_started/s1_procs.html">材料</a>，发现有一个很好的类比，可以把它们解释地清晰易懂。</p><p>1.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042401.jpg" alt=""></p><p>计算机的核心是 CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。</p><p>2.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042402.png" alt=""></p><p>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个 CPU 一次只能运行一个任务。</p><p>3.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042403.jpg" alt=""></p><p>进程就好比工厂的车间，它代表 CPU 所能处理的单个任务。任一时刻，CPU 总是运行一个进程，其他进程处于非运行状态。</p><p>4.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042404.jpg" alt=""></p><p>一个车间里，可以有很多工人。他们协同完成一个任务。</p><p>5.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042405.jpg" alt=""></p><p>线程就好比车间里的工人。一个进程可以包括多个线程。</p><p>6.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042406.png" alt=""></p><p>车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</p><p>7.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042407.jpg" alt=""></p><p>可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</p><p>8.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042408.jpg" alt=""></p><p>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫<a href="http://zh.wikipedia.org/wiki/%E4%BA%92%E6%96%A5%E9%94%81">“互斥锁”</a>（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</p><p>9.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042409.jpg" alt=""></p><p>还有些房间，可以同时容纳 n 个人，比如厨房。也就是说，如果人数大于 n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。</p><p>10.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042410.jpg" alt=""></p><p>这时的解决方法，就是在门口挂 n 把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做<a href="http://en.wikipedia.org/wiki/Semaphore_(programming">“信号量”</a>&gt;)（Semaphore），用来保证多个线程不会互相冲突。</p><p>不难看出，mutex 是 semaphore 的一种特殊情况（n=1 时）。也就是说，完全可以用后者替代前者。但是，因为 mutex 较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</p><p>11.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042411.png" alt=""></p><p>操作系统的设计，因此可以归结为三点：</p><p>（1）以多进程形式，允许多个任务同时运行；</p><p>（2）以多线程形式，允许单个任务分成不同的部分运行；</p><p>（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</p><p>（完）</p><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享 3.0 许可证</a>）</li><li>发表日期： 2013 年 4 月 24 日</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 协议简介</title>
      <link href="/posts/61430.html"/>
      <url>/posts/61430.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="TCP-协议简介"><a href="#TCP-协议简介" class="headerlink" title="TCP 协议简介"></a>TCP 协议简介</h1><p>作者： <a href="http://www.ruanyifeng.com">阮一峰</a></p><p>日期： <a href="http://www.ruanyifeng.com/blog/2017/06/">2017 年 6 月 8 日</a></p><p>TCP 是互联网核心协议之一，本文介绍它的基础知识。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060801.png" alt=""></p><h2 id="一、TCP-协议的作用"><a href="#一、TCP-协议的作用" class="headerlink" title="一、TCP 协议的作用"></a>一、TCP 协议的作用</h2><p>互联网由<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">一整套协议</a>构成。TCP 只是其中的一层，有着自己的分工。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060804.png" alt=""></p><p>（图片说明：TCP 是以太网协议和 IP 协议的上层协议，也是应用层协议的下层协议。）</p><p>最底层的以太网协议（Ethernet）规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060802.jpg" alt=""></p><p>（图片说明：以太网协议解决了局域网的点对点通信。）</p><p>但是，以太网协议不能解决多个局域网如何互通，这由 IP 协议解决。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060803.png" alt=""></p><p>（图片说明：IP 协议可以连接多个局域网。）</p><p>IP 协议定义了一套自己的地址规则，称为 IP 地址。它实现了路由功能，允许某个局域网的 A 主机，向另一个局域网的 B 主机发送消息。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060805.jpg" alt=""></p><p>（图片说明：路由器就是基于 IP 协议。局域网之间要靠路由器连接。）</p><p>路由的原理很简单。市场上所有的路由器，背后都有很多网口，要接入多根网线。路由器内部有一张路由表，规定了 A 段 IP 地址走出口一，B 段地址走出口二，……通过这套”指路牌”，实现了数据包的转发。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060806.jpg" alt=""></p><p>（图片说明：本机的路由表注明了不同 IP 目的地的数据包，要发送到哪一个网口（interface）。）</p><p>IP 协议只是一个地址协议，并不保证数据包的完整。如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要依靠 TCP 协议。</p><p>简单说，TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包。</p><h2 id="二、TCP-数据包的大小"><a href="#二、TCP-数据包的大小" class="headerlink" title="二、TCP 数据包的大小"></a>二、TCP 数据包的大小</h2><p>以太网数据包（packet）的大小是固定的，最初是 1518 字节，后来增加到 1522 字节。其中， 1500 字节是负载（payload），22 字节是头信息（head）。</p><p>IP 数据包在以太网数据包的负载里面，它也有自己的头信息，最少需要 20 字节，所以 IP 数据包的负载最多为 1480 字节。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052913.png" alt=""></p><p>（图片说明：IP 数据包在以太网数据包里面，TCP 数据包在 IP 数据包里面。）</p><p>TCP 数据包在 IP 数据包的负载里面。它的头信息最少也需要 20 字节，因此 TCP 数据包的最大负载是 1480 - 20 = 1460 字节。由于 IP 和 TCP 协议往往有额外的头信息，所以 TCP 负载实际为 1400 字节左右。</p><p>因此，一条 1500 字节的信息需要两个 TCP 数据包。HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg20170060810.png" alt=""></p><p>（图片说明：以太网数据包的负载是 1500 字节，TCP 数据包的负载在 1400 字节左右。）</p><h2 id="三、TCP-数据包的编号（SEQ）"><a href="#三、TCP-数据包的编号（SEQ）" class="headerlink" title="三、TCP 数据包的编号（SEQ）"></a>三、TCP 数据包的编号（SEQ）</h2><p>一个包 1400 字节，那么一次性发送大量数据，就必须分成多个包。比如，一个 10MB 的文件，需要发送 7100 多个包。</p><p>发送的时候，TCP 协议为每个包编号（sequence number，简称 SEQ），以便接收的一方按照顺序还原。万一发生丢包，也可以知道丢失的是哪一个包。</p><p>第一个包的编号是一个随机数。为了便于理解，这里就把它称为 1 号包。假定这个包的负载长度是 100 字节，那么可以推算出下一个包的编号应该是 101。这就是说，每个数据包都可以得到两个编号：自身的编号，以及下一个包的编号。接收方由此知道，应该按照什么顺序将它们还原成原始文件。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060807.png" alt=""></p><p>（图片说明：当前包的编号是 45943，下一个数据包的编号是 46183，由此可知，这个包的负载是 240 字节。）</p><h2 id="四、TCP-数据包的组装"><a href="#四、TCP-数据包的组装" class="headerlink" title="四、TCP 数据包的组装"></a>四、TCP 数据包的组装</h2><p>收到 TCP 数据包以后，组装还原是操作系统完成的。应用程序不会直接处理 TCP 数据包。</p><p>对于应用程序来说，不用关心数据通信的细节。除非线路异常，收到的总是完整的数据。应用程序需要的数据放在 TCP 数据包里面，有自己的格式（比如 HTTP 协议）。</p><p>TCP 并没有提供任何机制，表示原始文件的大小，这由应用层的协议来规定。比如，HTTP 协议就有一个头信息<code>Content-Length</code>，表示信息体的大小。对于操作系统来说，就是持续地接收 TCP 数据包，将它们按照顺序组装好，一个包都不少。</p><p>操作系统不会去处理 TCP 数据包里面的数据。一旦组装好 TCP 数据包，就把它们转交给应用程序。TCP 数据包里面有一个端口（port）参数，就是用来指定转交给监听该端口的应用程序。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060808.jpg" alt=""></p><p>（图片说明：系统根据 TCP 数据包里面的端口，将组装好的数据转交给相应的应用程序。上图中，21 端口是 FTP 服务器，25 端口是 SMTP 服务，80 端口是 Web 服务器。）</p><p>应用程序收到组装好的原始数据，以浏览器为例，就会根据 HTTP 协议的<code>Content-Length</code>字段正确读出一段段的数据。这也意味着，一次 TCP 通信可以包括多个 HTTP 通信。</p><h2 id="五、慢启动和-ACK"><a href="#五、慢启动和-ACK" class="headerlink" title="五、慢启动和 ACK"></a>五、慢启动和 ACK</h2><p>服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多因素都会导致丢包。线路不好的话，发得越快，丢得越多。</p><p>最理想的状态是，在线路允许的情况下，达到最高速率。但是我们怎么知道，对方线路的理想速率是多少呢？答案就是慢慢试。</p><p>TCP 协议为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。</p><p>Linux 内核里面<a href="http://elixir.free-electrons.com/linux/v4.5/source/include/net/tcp.h#L220">设定</a>了（常量<code>TCP_INIT_CWND</code>），刚开始通信的时候，发送方一次性发送 10 个数据包，即”发送窗口”的大小为 10。然后停下来，等待接收方的确认，再继续发送。</p><p>默认情况下，接收方每收到<a href="https://serverfault.com/questions/348666/when-the-tcp-engine-decides-to-send-an-ack">两个</a> TCP 数据包，就要<a href="https://stackoverflow.com/a/3604882/1194049">发送</a>一个确认消息。”确认”的英语是 acknowledgement，所以这个确认消息就简称 ACK。</p><p>ACK 携带两个信息。</p><blockquote><ul><li>期待要收到下一个数据包的编号</li><li>接收方的接收窗口的剩余容量</li></ul></blockquote><p>发送方有了这两个信息，再加上自己已经发出的数据包的最新编号，就会推测出接收方大概的接收速度，从而降低或增加发送速率。这被称为”发送窗口”，这个窗口的大小是可变的。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060809.png" alt=""></p><p>（图片说明：每个 ACK 都带有下一个数据包的编号，以及接收窗口的剩余容量。双方都会发送 ACK。）</p><p>注意，由于 TCP 通信是双向的，所以双方都需要发送 ACK。两方的窗口大小，很可能是不一样的。而且 ACK 只是很简单的几个字段，通常与数据合并在一个数据包里面发送。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060812.jpg" alt=""></p><p>（图片说明：上图一共 4 次通信。第一次通信，A 主机发给 B 主机的数据包编号是 1，长度是 100 字节，因此第二次通信 B 主机的 ACK 编号是 1 + 100 = 101，第三次通信 A 主机的数据包编号也是 101。同理，第二次通信 B 主机发给 A 主机的数据包编号是 1，长度是 200 字节，因此第三次通信 A 主机的 ACK 是 201，第四次通信 B 主机的数据包编号也是 201。）</p><p>即使对于带宽很大、线路很好的连接，TCP 也总是从 10 个数据包开始慢慢试，过了一段时间以后，才达到最高的传输速率。这就是 TCP 的慢启动。</p><h2 id="六、数据包的遗失处理"><a href="#六、数据包的遗失处理" class="headerlink" title="六、数据包的遗失处理"></a>六、数据包的遗失处理</h2><p>TCP 协议可以保证数据通信的完整性，这是怎么做到的？</p><p>前面说过，每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化。</p><p>举例来说，现在收到了 4 号包，但是没有收到 5 号包。ACK 就会记录，期待收到 5 号包。过了一段时间，5 号包收到了，那么下一轮 ACK 会更新编号。如果 5 号包还是没收到，但是收到了 6 号包或 7 号包，那么 ACK 里面的编号不会变化，总是显示 5 号包。这会导致大量重复内容的 ACK。</p><p>如果发送方发现收到<a href="https://stackoverflow.com/questions/4233851/why-does-tcp-wait-for-three-duplicate-ack-before-fast-retransmit">三个</a>连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，即 5 号包遗失了，从而再次发送这个包。通过这种机制，TCP 保证了不会有数据包丢失。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017060811.png" alt=""></p><p>（图片说明：Host B 没有收到 100 号数据包，会连续发出相同的 ACK，触发 Host A 重发 100 号数据包。）</p><h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><ul><li><a href="https://www.destroyallsoftware.com/compendium/network-protocols">Network protocols for programmers who know at least one programming language</a></li></ul><p>（完）</p><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享 3.0 许可证</a>）</li><li>发表日期： 2017 年 6 月 8 日</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言入门教程</title>
      <link href="/posts/50503.html"/>
      <url>/posts/50503.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="汇编语言入门教程"><a href="#汇编语言入门教程" class="headerlink" title="汇编语言入门教程"></a>汇编语言入门教程</h1><p>作者： <a href="http://www.ruanyifeng.com">阮一峰</a></p><p>日期： <a href="http://www.ruanyifeng.com/blog/2018/01/">2018 年 1 月 21 日</a></p><p>学习编程其实就是学高级语言，即那些为人类设计的计算机语言。</p><p>但是，计算机不理解高级语言，必须通过编译器转成二进制代码，才能运行。学会高级语言，并不等于理解计算机实际的运行步骤。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012204.png" alt=""></p><p>计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。</p><p>汇编语言不容易学习，就连简明扼要的介绍都很难找到。下面我尝试写一篇最好懂的汇编语言教程，解释 CPU 如何执行代码。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012202.jpg" alt=""></p><h2 id="一、汇编语言是什么？"><a href="#一、汇编语言是什么？" class="headerlink" title="一、汇编语言是什么？"></a>一、汇编语言是什么？</h2><p>我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。</p><p>这些指令都是二进制的，称为操作码（opcode），比如加法指令就是<code>00000011</code>。<a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html">编译器</a>的作用，就是将高级语言写好的程序，翻译成一条条操作码。</p><p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012203.jpg" alt=""></p><p><strong>汇编语言是二进制指令的文本形式</strong>，与指令是一一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。</p><h2 id="二、来历"><a href="#二、来历" class="headerlink" title="二、来历"></a>二、来历</h2><p>最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。</p><p>为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是用标签表示。</p><p>这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为汇编语言。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012205.jpg" alt=""></p><p>每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的 x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。</p><h2 id="三、寄存器"><a href="#三、寄存器" class="headerlink" title="三、寄存器"></a>三、寄存器</h2><p>学习汇编语言，首先必须了解两个知识点：寄存器和内存模型。</p><p>先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p><p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012206.png" alt=""></p><p>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。</p><h2 id="四、寄存器的种类"><a href="#四、寄存器的种类" class="headerlink" title="四、寄存器的种类"></a>四、寄存器的种类</h2><p>早期的 x86 CPU 只有 8 个寄存器，而且每个都有不同的用途。现在的寄存器已经有 100 多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。</p><blockquote><ul><li>EAX</li><li>EBX</li><li>ECX</li><li>EDX</li><li>EDI</li><li>ESI</li><li>EBP</li><li>ESP</li></ul></blockquote><p>上面这 8 个寄存器之中，前面七个都是通用的。ESP 寄存器有特定用途，保存当前 Stack 的地址（详见下一节）。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012207.png" alt=""></p><p>我们常常看到 32 位 CPU、64 位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是 4 个字节。</p><h2 id="五、内存模型：Heap"><a href="#五、内存模型：Heap" class="headerlink" title="五、内存模型：Heap"></a>五、内存模型：Heap</h2><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p><p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012208.png" alt=""></p><p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到 10 个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到 22 个字节，那么就分配到<code>0x1020</code>。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012209.png" alt=""></p><p>这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p><h2 id="六、内存模型：Stack"><a href="#六、内存模型：Stack" class="headerlink" title="六、内存模型：Stack"></a>六、内存模型：Stack</h2><p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012210.png" alt=""></p><p>请看下面的例子。</p><blockquote><pre><code>int main() &#123;   int a = 2;   int b = 3;&#125;</code></pre></blockquote><p>上面代码中，系统开始执行<code>main</code>函数时，会为它在内存里面建立一个帧（frame），所有<code>main</code>的内部变量（比如<code>a</code>和<code>b</code>）都保存在这个帧里面。<code>main</code>函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012211.png" alt=""></p><p>如果函数内部调用了其他函数，会发生什么情况？</p><blockquote><pre><code>int main() &#123;   int a = 2;   int b = 3;   return add_a_and_b(a, b);&#125;</code></pre></blockquote><p>上面代码中，<code>main</code>函数内部调用了<code>add_a_and_b</code>函数。执行到这一行的时候，系统也会为<code>add_a_and_b</code>新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：<code>main</code>和<code>add_a_and_b</code>。一般来说，调用栈有多少层，就有多少帧。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012212.png" alt=""></p><p>等到<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p><p>所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做”入栈”，英文是 push；栈的回收叫做”出栈”，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做”后进先出”的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012213.jpg" alt=""></p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012214.jpg" alt=""></p><p>Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是<code>0x8000</code>，第一帧假定是 16 字节，那么下一次分配的地址就会从<code>0x7FF0</code>开始；第二帧假定需要 64 字节，那么地址就会移动到<code>0x7FB0</code>。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012215.png" alt=""></p><h2 id="七、CPU-指令"><a href="#七、CPU-指令" class="headerlink" title="七、CPU 指令"></a>七、CPU 指令</h2><h3 id="7-1-一个实例"><a href="#7-1-一个实例" class="headerlink" title="7.1 一个实例"></a>7.1 一个实例</h3><p>了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序<code>example.c</code>。</p><blockquote><pre><code>int add_a_and_b(int a, int b) &#123;   return a + b;&#125;int main() &#123;   return add_a_and_b(2, 3);&#125;</code></pre></blockquote><p>gcc 将这个程序转成汇编语言。</p><blockquote><pre><code>$ gcc -S example.c</code></pre></blockquote><p>上面的命令执行以后，会生成一个文本文件<code>example.s</code>，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。</p><p><code>example.s</code>经过简化以后，大概是下面的样子。</p><blockquote><pre><code>_add_a_and_b:   push   %ebx   mov    %eax, [%esp+8]   mov    %ebx, [%esp+12]   add    %eax, %ebx   pop    %ebx   ret_main:   push   3   push   2   call   _add_a_and_b   add    %esp, 8   ret</code></pre></blockquote><p>可以看到，原程序的两个函数<code>add_a_and_b</code>和<code>main</code>，对应两个标签<code>_add_a_and_b</code>和<code>_main</code>。每个标签里面是该函数所转成的 CPU 运行流程。</p><p>每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。</p><blockquote><pre><code>push   %ebx</code></pre></blockquote><p>这一行里面，<code>push</code>是 CPU 指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p><p>下面我就一行一行讲解这个汇编程序，建议读者最好把这个程序，在另一个窗口拷贝一份，省得阅读的时候再把页面滚动上来。</p><h3 id="7-2-push-指令"><a href="#7-2-push-指令" class="headerlink" title="7.2 push 指令"></a>7.2 push 指令</h3><p>根据约定，程序从<code>_main</code>标签开始执行，这时会在 Stack 上为<code>main</code>建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入<code>main</code>这个帧，就会写在 ESP 寄存器所保存的地址。</p><p>然后，开始执行第一行代码。</p><blockquote><pre><code>push   3</code></pre></blockquote><p><code>push</code>指令用于将运算子放入 Stack，这里就是将<code>3</code>写入<code>main</code>这个帧。</p><p>虽然看上去很简单，<code>push</code>指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去 4 个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4 个字节则是因为<code>3</code>的类型是<code>int</code>，占用 4 个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。</p><blockquote><pre><code>push   2</code></pre></blockquote><p>第二行也是一样，<code>push</code>指令将<code>2</code>写入<code>main</code>这个帧，位置紧贴着前面写入的<code>3</code>。这时，ESP 寄存器会再减去 4 个字节（累计减去 8）。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012216.png" alt=""></p><h3 id="7-3-call-指令"><a href="#7-3-call-指令" class="headerlink" title="7.3 call 指令"></a>7.3 call 指令</h3><p>第三行的<code>call</code>指令用来调用函数。</p><blockquote><pre><code>call   _add_a_and_b</code></pre></blockquote><p>上面的代码表示调用<code>add_a_and_b</code>函数。这时，程序就会去找<code>_add_a_and_b</code>标签，并为该函数建立一个新的帧。</p><p>下面就开始执行<code>_add_a_and_b</code>的代码。</p><blockquote><pre><code>push   %ebx</code></pre></blockquote><p>这一行表示将 EBX 寄存器里面的值，写入<code>_add_a_and_b</code>这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。</p><p>这时，<code>push</code>指令会再将 ESP 寄存器里面的地址减去 4 个字节（累计减去 12）。</p><h3 id="7-4-mov-指令"><a href="#7-4-mov-指令" class="headerlink" title="7.4 mov 指令"></a>7.4 mov 指令</h3><p><code>mov</code>指令用于将一个值写入某个寄存器。</p><blockquote><pre><code>mov    %eax, [%esp+8]</code></pre></blockquote><p>这一行代码表示，先将 ESP 寄存器里面的地址加上 8 个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是<code>2</code>，再将<code>2</code>写入 EAX 寄存器。</p><p>下一行代码也是干同样的事情。</p><blockquote><pre><code>mov    %ebx, [%esp+12]</code></pre></blockquote><p>上面的代码将 ESP 寄存器的值加 12 个字节，再按照这个地址在 Stack 取出数据，这次取出的是<code>3</code>，将其写入 EBX 寄存器。</p><h3 id="7-5-add-指令"><a href="#7-5-add-指令" class="headerlink" title="7.5 add 指令"></a>7.5 add 指令</h3><p><code>add</code>指令用于将两个运算子相加，并将结果写入第一个运算子。</p><blockquote><pre><code>add    %eax, %ebx</code></pre></blockquote><p>上面的代码将 EAX 寄存器的值（即 2）加上 EBX 寄存器的值（即 3），得到结果 5，再将这个结果写入第一个运算子 EAX 寄存器。</p><h3 id="7-6-pop-指令"><a href="#7-6-pop-指令" class="headerlink" title="7.6 pop 指令"></a>7.6 pop 指令</h3><p><code>pop</code>指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。</p><blockquote><pre><code>pop    %ebx</code></pre></blockquote><p>上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。</p><p>注意，<code>pop</code>指令还会将 ESP 寄存器里面的地址加 4，即回收 4 个字节。</p><h3 id="7-7-ret-指令"><a href="#7-7-ret-指令" class="headerlink" title="7.7 ret 指令"></a>7.7 ret 指令</h3><p><code>ret</code>指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。</p><blockquote><pre><code>ret</code></pre></blockquote><p>可以看到，该指令没有运算子。</p><p>随着<code>add_a_and_b</code>函数终止执行，系统就回到刚才<code>main</code>函数中断的地方，继续往下执行。</p><blockquote><pre><code>add    %esp, 8</code></pre></blockquote><p>上面的代码表示，将 ESP 寄存器里面的地址，手动加上 8 个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的<code>pop</code>操作已经回收了 4 个字节，这里再回收 8 个字节，等于全部回收。</p><blockquote><pre><code>ret</code></pre></blockquote><p>最后，<code>main</code>函数运行结束，<code>ret</code>指令退出程序执行。</p><h2 id="八、参考链接"><a href="#八、参考链接" class="headerlink" title="八、参考链接"></a>八、参考链接</h2><ul><li><a href="http://kakaroto.homelinux.net/2017/11/introduction-to-reverse-engineering-and-assembly/">Introduction to reverse engineering and Assembly</a>, by Youness Alaoui</li><li><a href="http://www.cs.virginia.edu/~evans/cs216/guides/x86.html">x86 Assembly Guide</a>, by University of Virginia Computer Science</li></ul><p>（完）</p><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享 3.0 许可证</a>）</li><li>发表日期： 2018 年 1 月 21 日</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown学习笔记1</title>
      <link href="/posts/30815.html"/>
      <url>/posts/30815.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="markdown学习笔记1"><a href="#markdown学习笔记1" class="headerlink" title="markdown学习笔记1"></a>markdown学习笔记1</h1><h2 id="1、markdown是什么？"><a href="#1、markdown是什么？" class="headerlink" title="1、markdown是什么？"></a>1、markdown是什么？</h2><ul><li>Markdown是一种轻量级标记语言，2004 由约翰·格鲁伯（英语：John Gruber）创建，通过使用易读易写的纯文本格式编写文档，让作者把更多精力放在文章内容，不再为排版浪费时间。Markdown文档可以导出为HTML、Word、图像、PDF、Epub 等多种格式。</li></ul><h2 id="2、标题、换行、字体"><a href="#2、标题、换行、字体" class="headerlink" title="2、标题、换行、字体"></a>2、标题、换行、字体</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><ul><li>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</li></ul><blockquote><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><ul><li>段落的换行是使用两个以上空格再加上回车。</li><li>或者使用一个空行来表示新的段落段落。</li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><blockquote><p>* 斜体文本 <em><br>\</em>*粗体文本**<br>***粗斜体文本***  </p><p><em>斜体文本</em><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong>  </p></blockquote><h2 id="3、分割线、删除线、下划线"><a href="#3、分割线、删除线、下划线" class="headerlink" title="3、分割线、删除线、下划线"></a>3、分割线、删除线、下划线</h2><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><ul><li>在一行中用三个以上的星号、减号、底线来建立一个分隔线<blockquote><p>-—<br>分割线  </p></blockquote></li></ul><blockquote><hr><p>分割线  </p></blockquote><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><ul><li>在文字的两端加上两个波浪线表示删除线</li></ul><blockquote><p>~~删除线~~</p><p><del>删除线</del>  </p></blockquote><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><ul><li>通过 HTML 的 \<u> \</u>标签来表示下划线<blockquote><p>\<u> 下划线 \</u></p></blockquote></li></ul><blockquote><p><u> 下划线 </u></p></blockquote><h2 id="4、有序列表、无序列表、列表嵌套"><a href="#4、有序列表、无序列表、列表嵌套" class="headerlink" title="4、有序列表、无序列表、列表嵌套"></a>4、有序列表、无序列表、列表嵌套</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul><li>无序列表使用星号*、加号+或是减号-  </li></ul><blockquote><p>- 第一项<br>- 第二项<br>- 第三项  </p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ul><li>有序列表使用数字并加上点号 . <blockquote><p>1. 第一项<br>2. 第二项<br>3. 第三项  </p></blockquote></li></ul><blockquote><ol><li>第一项  </li><li>第二项  </li><li>第三项</li></ol></blockquote><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><ul><li>在子列表中的选项前面添加四个空格</li></ul><blockquote><p>1. 第一项：<br>&emsp;    - 第一项嵌套的第一个元素<br>&emsp;    - 第一项嵌套的第二个元素<br>2. 第二项：<br>&emsp;    - 第二项嵌套的第一个元素<br>&emsp;    - 第二项嵌套的第二个元素  </p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol></blockquote><h2 id="6、区块显示"><a href="#6、区块显示" class="headerlink" title="6、区块显示"></a>6、区块显示</h2><h3 id="普通区块"><a href="#普通区块" class="headerlink" title="普通区块"></a>普通区块</h3><ul><li>区块引用是在段落开头使用 &gt; 符号，后跟空格。<blockquote><p>> 第一行<br>> 第二行<br>> 第三行  </p></blockquote></li></ul><blockquote><p>第一行<br>第二行<br>第三行  </p></blockquote><h3 id="嵌套区块"><a href="#嵌套区块" class="headerlink" title="嵌套区块"></a>嵌套区块</h3><ul><li>区块可以嵌套，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推。<blockquote><p>> 第一行<br>>&gt; 第二行<br>>&gt;&gt; 第三行  </p></blockquote></li></ul><blockquote><p>第一行  </p><blockquote><p>第二行  </p><blockquote><p>第三行  </p></blockquote></blockquote></blockquote><h3 id="区块加入列表"><a href="#区块加入列表" class="headerlink" title="区块加入列表"></a>区块加入列表</h3><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h3 id="列表加入区块"><a href="#列表加入区块" class="headerlink" title="列表加入区块"></a>列表加入区块</h3><ul><li>在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。</li><li>第一项<blockquote><p>第一行<br>第二行</p></blockquote></li><li>第二项<blockquote><p>第一行<br>第二行</p></blockquote></li></ul><h2 id="7、代码显示"><a href="#7、代码显示" class="headerlink" title="7、代码显示"></a>7、代码显示</h2><ul><li>代码可以用反引号把它包起来 `<blockquote><p>`printf(“Hello World ! \n”);`  </p></blockquote></li></ul><blockquote><p><code>printf(&quot;Hello World ! \n&quot;);</code></p></blockquote><ul><li>以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）  </li></ul><blockquote><p>```c<br>printf(“Hello World ! \n”);<br>```</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World ! \n&quot;</span>);</span><br></pre></td></tr></table></figure></blockquote><ul><li>用区块显示代码，代码区块使用 4 个空格或者一个制表符（Tab 键）  <blockquote><p>for(int i=0;i&lt;100;i++)<br>  {<br>  &emsp; printf(“Hello World ! \n”);<br>  }</p></blockquote></li></ul><h2 id="8、添加链接"><a href="#8、添加链接" class="headerlink" title="8、添加链接"></a>8、添加链接</h2><ul><li>[链接名称](链接地址)</li></ul><blockquote><p>[跑跑的小屋](liupaopao.top)  </p><p><a href="liupaopao.top">跑跑的小屋</a></p></blockquote><ul><li>&lt;链接地址&gt;</li></ul><blockquote><p>\<a href="https://liupaopao.top">https://liupaopao.top</a> </p><p><a href="https://liupaopao.top">https://liupaopao.top</a> </p></blockquote><h2 id="9、添加图片"><a href="#9、添加图片" class="headerlink" title="9、添加图片"></a>9、添加图片</h2><ul><li>要添加图片，首先添加感叹号（!），然后紧跟着是方括号，方括号中可添加替代文本（alt text，即图片显示失败后显示此文本），最后跟着圆括号，圆括号中添加图片资源的路径或 URL。你可以选择在圆括号中的 URL 之后添加标题（即 title 属性）。</li></ul><blockquote><p>![alt 属性文本](图片地址)<br>![alt 属性文本](图片地址 “可选标题”)</p><p>![百度logo](<a href="https://dss2.bdstatic.com/5bVYsj_p_tVS5dKfpU_Y_D3/res/r/image/2021-3-4/hao123%20logo.png">https://dss2.bdstatic.com/5bVYsj_p_tVS5dKfpU_Y_D3/res/r/image/2021-3-4/hao123%20logo.png</a> “baidu”)</p><p><img src="https://dss2.bdstatic.com/5bVYsj_p_tVS5dKfpU_Y_D3/res/r/image/2021-3-4/hao123%20logo.png" alt="百度logo" title="baidu"></p></blockquote><h2 id="10、添加表格"><a href="#10、添加表格" class="headerlink" title="10、添加表格"></a>10、添加表格</h2><ul><li>使用三个或更多个连字符（—-）来为每个列创建表头，并使用管道符（|）来分隔每个列。</li></ul><blockquote><p>|  表头 | 表头  |<br>|  —-  | —-  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |  </p><div class="table-container"><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table></div></blockquote><ul><li>可以设置表格的对齐方式：</li></ul><blockquote><div class="table-container"><table><thead><tr><th>符号</th><th>对齐方式</th></tr></thead><tbody><tr><td>-:</td><td>设置内容和标题栏居右对齐</td></tr><tr><td>:-</td><td>设置内容和标题栏居左对齐</td></tr><tr><td>:-:</td><td>设置内容和标题栏居中对齐</td></tr></tbody></table></div></blockquote>]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim中可视模式下添加或取消多行注释</title>
      <link href="/posts/8377.html"/>
      <url>/posts/8377.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="vim中可视模式下多行添加注释和取消注释"><a href="#vim中可视模式下多行添加注释和取消注释" class="headerlink" title="vim中可视模式下多行添加注释和取消注释"></a>vim中可视模式下多行添加注释和取消注释</h2><p><strong>正常模式 —&gt; 可视模式：</strong></p><div class="table-container"><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>v</td><td>可视模式</td></tr><tr><td>ctrl+v</td><td>可视块模式</td></tr><tr><td>shift+v</td><td>可视行模式</td></tr></tbody></table></div><p>可视块模式有一个非常实用的作用：选多行进行注释</p><h2 id="多行添加注释："><a href="#多行添加注释：" class="headerlink" title="多行添加注释："></a>多行添加注释：</h2><p>- 光标置于行首<br>- <code>ctrl + v</code>，进入可视块模式<br>- 移动光标，选中的位置会有高亮显示<br>- <code>shift + i</code>，进入 insert 模式<br>- 输入<code>//</code><br>- <code>esc</code></p><h2 id="多行取消注释："><a href="#多行取消注释：" class="headerlink" title="多行取消注释："></a>多行取消注释：</h2><p>- 光标置于行首<br>- <code>ctrl + v</code>，进入可视块模式<br>- 移动光标，选中的位置会有高亮显示<br>- 按<code>d</code></p>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看gcc的宏定义</title>
      <link href="/posts/12403.html"/>
      <url>/posts/12403.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1、查看gcc默认的内置宏定义"><a href="#1、查看gcc默认的内置宏定义" class="headerlink" title="1、查看gcc默认的内置宏定义"></a>1、查看gcc默认的内置宏定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -dM -E - &lt; /dev/null</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -dM -E helloworld.c</span><br></pre></td></tr></table></figure><p> helloworld.c为用户随意编写的c测试用例，随意拿个c程序就行。</p><p>-E 预处理后即停止，不进行编译。预处理后的代码送往标准输出。GCC忽略任何不需要预处理的输入文件。</p><p>-dM 告诉预处理器输出有效的宏定义列表(预处理结束时仍然有效的宏定义)。该选项需结合`-E’选项使用。</p><h2 id="2、打开用户自行设置的宏定义"><a href="#2、打开用户自行设置的宏定义" class="headerlink" title="2、打开用户自行设置的宏定义"></a>2、打开用户自行设置的宏定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -DDEBUG helloworld.c</span><br></pre></td></tr></table></figure><p>helloworld.c文件中的宏定义DEBUG如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">    printf(&quot;DEBUG is defined ! &quot;);</span><br><span class="line">#else</span><br><span class="line">    printf(&quot;DEBUG is not defined ! &quot;);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h2 id="总结：gcc内部默认的宏定义-用户自行设置的宏定义-所有的宏定义"><a href="#总结：gcc内部默认的宏定义-用户自行设置的宏定义-所有的宏定义" class="headerlink" title="总结：gcc内部默认的宏定义+用户自行设置的宏定义=所有的宏定义"></a>总结：gcc内部默认的宏定义+用户自行设置的宏定义=所有的宏定义</h2>]]></content>
      
      
      <categories>
          
          <category> 编译器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记1：单片机最小系统设计</title>
      <link href="/posts/56027b49.html"/>
      <url>/posts/56027b49.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1、单片机概念"><a href="#1、单片机概念" class="headerlink" title="1、单片机概念"></a>1、单片机概念</h2><p>单片机：一种集成电路芯片，是单片微型计算机的简称。单片机由微处理器CPU、存储器ROM和RAM、输入输出IO接口电路组成，构成了一个既小巧又完善的计算机硬件系统。</p><h2 id="2、单片机用途"><a href="#2、单片机用途" class="headerlink" title="2、单片机用途"></a>2、单片机用途</h2><p>（1）智能仪器仪表，如示波器、万用表</p><p>（2）机电一体化产品，如机器人、数控机床、打印机</p><p>（3）实时工业控制，如电机转速控制</p><p>（4）家用电器，如冰箱、洗衣机</p><h2 id="3、单片机应用系统"><a href="#3、单片机应用系统" class="headerlink" title="3、单片机应用系统"></a>3、单片机应用系统</h2><p>单片机应用系统=软件+硬件（单片机+接口电路及外部设备）</p><p>单片机应用系统是以单片机为核心，配以输入、输出、显示、控制等外围电路和相应的控制、驱动软件，能完成一种或多种功能的使用系统。</p><h2 id="4、MCS-51系列单片机组成结构"><a href="#4、MCS-51系列单片机组成结构" class="headerlink" title="4、MCS-51系列单片机组成结构"></a>4、MCS-51系列单片机组成结构</h2><p>（1）中央处理器-CPU：8位数据宽度，能同时处理8位二进制数据或代码。</p><p>（2）数据存储器-RAM：8051单片机有128B数据存储器和21个专用寄存器，用户能使用的只有128B，专用寄存器通常用于存放控制指令数据，不能存放用户数据。</p><p>（3）程序存储器-ROM：8051单片机有4KB程序存储器，掉电后数据不会丢失。</p><p>（4）定时/计数器：8051单片机有2个16位的可编程定时/计数器。</p><p>（5）并行I/O口：8051单片机有4个8位的并行I/O口（P0/P1/P2/P3）。</p><p>（6）全双工串行口：8051单片机有一个全双工异步串行通信口。</p><p>（7）中断系统：8051单片机有5个中断源（2个外中断、2个定时/计数器中断和1个串行中断）。</p><p>（8）时钟电路：8051单片机有时钟电路，只需外接晶振和震荡电容，用于产生时序脉冲供整个单片机运行。</p><h2 id="5、MCS-51系列单片机引脚介绍"><a href="#5、MCS-51系列单片机引脚介绍" class="headerlink" title="5、MCS-51系列单片机引脚介绍"></a>5、MCS-51系列单片机引脚介绍</h2><p><img src="https://img2020.cnblogs.com/blog/1729775/202102/1729775-20210221184228988-605752706.png" alt="img"></p><p> （1）电源：40引脚Vcc接电源+5V，20引脚GND接地。</p><p>（2）时钟：19引脚XTAL1是内部振荡电路输入端。当采用外部振荡器时，此引脚接地。18引脚XTAL2是内部振荡电路输出端。当采用外部振荡器时，此引脚接外部振荡源。</p><p>（3）控制总线：</p><p>（4）I/O线：</p><p>P0口（32~39引脚）双向数据总线和低8位地址总线。</p><p>P1口（1~8引脚）准双向输入/输出口。</p><p>P2口（21~28引脚）准双向输入/输出口，访问外部存储器时用作高8位地址总线。</p><p>P3口（10~17引脚）准双向输入/输出口。P3口还具第二功能。</p><p><img src="https://img2020.cnblogs.com/blog/1729775/202102/1729775-20210221194123546-1287876210.png" alt="img"></p><h2 id="6、MCS-51系列单片机存储器结构"><a href="#6、MCS-51系列单片机存储器结构" class="headerlink" title="6、MCS-51系列单片机存储器结构"></a>6、MCS-51系列单片机存储器结构</h2><p>程序存储器：存放程序和表格常数。</p><p>数据存储器：存放程序运行所需要的参数和运行结果。</p><p>从物理存储介质来看，MCS-51系列单片机共有4种存储空间：片内程序存储器、片外程序存储器、片内数据存储器和片外数据存储器。</p><p>从逻辑地址空间来看，MCS-51系列单片机可分为3部分：程序存储器、片外数据存储器和片内数据存储器。</p><p>单片机复位后，程序计数器PC为0000H，系统从0000H单元开始取指令并执行。</p><h2 id="7、单片机最小系统电路"><a href="#7、单片机最小系统电路" class="headerlink" title="7、单片机最小系统电路"></a>7、单片机最小系统电路</h2><p>单片机最小系统电路是指单片机工作不可或缺的最基本连接电路。</p><p><strong>单片机最小系统电路包括单片机芯片、电源电路、时钟电路和复位电路四部分。</strong></p><p>（1）时钟电路。单片机内部有一个高增益反向放大器，其频率范围为1.2~12MHz，XTAL1和XTAL2分别为放大器的输入端和输出端。XTAL1和XTAL2外接定时元件就能构成自激振荡电路。定时元件通常采用石英晶体和电容组成的并联谐振电路。电容C1和C2主要起频率微调作用，电容取值30~40pF。</p><p><strong>振荡周期：振荡源的周期，若内部产生，则为石英晶体的振荡周期。</strong></p><p><strong>时钟周期：振荡周期的两倍。</strong></p><p><strong>机器周期：等于6个时钟周期，12个振荡周期。</strong></p><p><strong>指令周期：完成一条操作所需要的全部时间，每条指令的执行时间都是一个或几个机器周期组成。</strong></p><p>例题：单片机采用内部时钟，晶振频率f为6MHz，则：</p><p>振荡周期=1/6 MHz=1/6 us</p><p>时钟周期=1/3 us</p><p>机器周期=2 us</p><p>指令周期=机器周期的1~4倍=2~8us</p><p>（2）复位电路</p><p>主要分为两种：上电复位和按键复位电路。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在无锡必去的一些地标打卡点</title>
      <link href="/posts/9160d4e0.html"/>
      <url>/posts/9160d4e0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="灵山大佛"><a href="#灵山大佛" class="headerlink" title="灵山大佛"></a>灵山大佛</h2><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/灵山大佛.jpg" alt="灵山大佛"></p><h2 id="鼋头渚"><a href="#鼋头渚" class="headerlink" title="鼋头渚"></a>鼋头渚</h2><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/鼋头渚樱花1.jpg" alt="鼋头渚樱花1"></p><h2 id="惠山"><a href="#惠山" class="headerlink" title="惠山"></a>惠山</h2><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/无锡惠山寺秋景.jpg" alt="无锡惠山寺秋景"></p><h2 id="南长街、清明桥、古运河"><a href="#南长街、清明桥、古运河" class="headerlink" title="南长街、清明桥、古运河"></a>南长街、清明桥、古运河</h2><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/南长街清名桥古运河景区.jpg" alt="南长街清名桥古运河景区"></p><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/古运河1.jpg" alt="古运河1"></p><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/古运河2.jpg" alt="古运河2"></p><h2 id="蠡湖公园"><a href="#蠡湖公园" class="headerlink" title="蠡湖公园"></a>蠡湖公园</h2><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/无锡蠡园四季亭.jpg" alt="无锡蠡园四季亭"></p><h2 id="梅园"><a href="#梅园" class="headerlink" title="梅园"></a>梅园</h2><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/梅园.jpg" alt="梅园"></p><h2 id="蠡湖"><a href="#蠡湖" class="headerlink" title="蠡湖"></a>蠡湖</h2><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/蠡湖1.jpg" alt="蠡湖1"></p><h2 id="太湖"><a href="#太湖" class="headerlink" title="太湖"></a>太湖</h2><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/太湖1.png" alt="太湖1"></p><h2 id="梅里古都"><a href="#梅里古都" class="headerlink" title="梅里古都"></a>梅里古都</h2><p><img src="https://gitee.com/liuhanxu/images/raw/master/img/梅里古都.jpg" alt="梅里古都"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下Shadowsocks配置指南</title>
      <link href="/posts/56331.html"/>
      <url>/posts/56331.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Ubuntu下Shadowsocks安装及优化"><a href="#Ubuntu下Shadowsocks安装及优化" class="headerlink" title="Ubuntu下Shadowsocks安装及优化"></a>Ubuntu下Shadowsocks安装及优化</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本教程旨在提供简明的Ubuntu 16.04下安装服务器端Shadowsocks。不同于Ubuntu 16.04之前的教程，本文抛弃initd，转而使用Ubuntu 16.04支持的Systemd管理Shadowsocks的启动与停止，显得更为便捷。优化部分包括BBR、TCP Fast Open以及吞吐量优化。</p><p>本教程仅适用于Ubuntu 16.04及之后的版本，基于Python 3，支持IPv6。</p><h2 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装<code>pip</code></h2><p>本教程使用Python 3为载体，因Python 3对应的包管理器<code>pip3</code>并未预装，首先安装<code>pip3</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br></pre></td></tr></table></figure><h2 id="安装Shadowsocks"><a href="#安装Shadowsocks" class="headerlink" title="安装Shadowsocks"></a>安装Shadowsocks</h2><p>因Shadowsocks作者不再维护<code>pip</code>中的Shadowsocks（定格在了2.8.2），我们使用下面的命令来安装最新版的Shadowsocks：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install https://github.com/shadowsocks/shadowsocks/archive/master.zip</span><br></pre></td></tr></table></figure><p>安装完成后可以使用下面这个命令查看Shadowsocks版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssserver --version</span><br></pre></td></tr></table></figure><p>目前会显示“Shadowsocks 3.0.0”。</p><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><p>创建Shadowsocks配置文件所在文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /etc/shadowsocks</span><br></pre></td></tr></table></figure><p>然后创建配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure><p>复制粘贴如下内容（注意修改密码“password”）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;server&quot;</span>:<span class="string">&quot;::&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;server_port&quot;</span>:<span class="number">8388</span>,</span><br><span class="line">    <span class="attr">&quot;local_address&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;local_port&quot;</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">&quot;password&quot;</span>:<span class="string">&quot;mypassword&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">&quot;method&quot;</span>:<span class="string">&quot;chacha20-ietf-poly1305&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;fast_open&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加配置信息多用户</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多用户</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;server&quot;</span>:<span class="string">&quot;::&quot;</span>,</span><br><span class="line">    <span class="string">&quot;local_address&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;local_port&quot;</span>:<span class="number">1080</span>,</span><br><span class="line">  <span class="string">&quot;port_password&quot;</span>:&#123;</span><br><span class="line">         <span class="string">&quot;8888&quot;</span>:<span class="string">&quot;123456789&quot;</span>,</span><br><span class="line">         <span class="string">&quot;9999&quot;</span>:<span class="string">&quot;123456789&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="string">&quot;timeout&quot;</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="string">&quot;method&quot;</span>:<span class="string">&quot;aes-256-cfb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;fast_open&quot;</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加配置信息单用户</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单用户</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;server&quot;</span>:<span class="string">&quot;::&quot;</span>,</span><br><span class="line">    <span class="string">&quot;server_port&quot;</span>:<span class="number">8388</span>,</span><br><span class="line">    <span class="string">&quot;local_address&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;local_port&quot;</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>:<span class="string">&quot;123456789&quot;</span>,</span><br><span class="line">    <span class="string">&quot;timeout&quot;</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="string">&quot;method&quot;</span>:<span class="string">&quot;aes-256-cfb&quot;</span>,</span><br><span class="line">    <span class="string">&quot;fast_open&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server：Shadowsocks服务器地址 </span><br><span class="line">server_port：Shadowsocks服务器端口 </span><br><span class="line">local_address：   本地IP</span><br><span class="line">local_port：本地端口 </span><br><span class="line">password：Shadowsocks连接密码 </span><br><span class="line">timeout：等待超时时间 </span><br><span class="line">method：加密方式 </span><br><span class="line"><span class="attr">workers</span>:          工作线程数 </span><br><span class="line">fast_open：       <span class="literal">true</span>或<span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="测试Shadowsocks配置"><a href="#测试Shadowsocks配置" class="headerlink" title="测试Shadowsocks配置"></a>测试Shadowsocks配置</h2><p>首先记录下服务器的IP地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>找到IPv4地址（和IPv6地址），如我的<code>ifconfig</code>输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">eth0      Link encap:Ethernet  HWaddr 46:91:89:4e:c1:52</span><br><span class="line">          inet addr:138.68.51.55  Bcast:138.68.63.255  Mask:255.255.240.0</span><br><span class="line">          inet6 addr: fe80::4491:89ff:fe4e:c152/64 Scope:Link</span><br><span class="line">          inet6 addr: 2604:a880:2:d0::3727:7001/64 Scope:Global</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:102667 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:7869 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:151166937 (151.1 MB)  TX bytes:1151476 (1.1 MB)</span><br></pre></td></tr></table></figure><p>所以我的IPv4地址是<code>138.68.51.55</code>，IPv6地址是<code>2604:a880:2:d0::3727:7001</code>。</p><p>然后来测试下Shadowsocks能不能正常工作了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure><p>在Shadowsocks客户端添加服务器，如果你使用的是我提供的那个配置文件的话，地址填写你的<code>IPv4地址</code>或<code>IPv6地址</code>，端口号为<code>8388</code>，加密方法为<code>chacha20-ietf-poly1305</code>，密码为<code>你设置的密码</code>。然后设置客户端使用全局模式，浏览器登录Google试试应该能直接打开了。</p><h2 id="配置Systemd管理Shadowsocks"><a href="#配置Systemd管理Shadowsocks" class="headerlink" title="配置Systemd管理Shadowsocks"></a>配置Systemd管理Shadowsocks</h2><p>新建Shadowsocks管理文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/systemd/system/shadowsocks-server.service</span><br></pre></td></tr></table></figure><p>复制粘贴：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks Server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks/config.json</span><br><span class="line">Restart=on-abort</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p><code>Ctrl + O</code>保存文件，<code>Ctrl + X</code>退出。</p><p>启动Shadowsocks：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start shadowsocks-server</span><br></pre></td></tr></table></figure><p>设置开机启动Shadowsocks：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> shadowsocks-server</span><br></pre></td></tr></table></figure><p>至此，Shadowsock服务器端的基本配置已经全部完成了！</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>这部分属于进阶操作，在你使用Shadowsocks时感觉到延迟较大，或吞吐量较低时，可以考虑对服务器端进行优化。</p><h3 id="开启BBR"><a href="#开启BBR" class="headerlink" title="开启BBR"></a>开启BBR</h3><p>BBR系Google最新开发的TCP拥塞控制算法，目前有着较好的带宽提升效果，甚至不比老牌的锐速差。</p><h4 id="升级Linux内核"><a href="#升级Linux内核" class="headerlink" title="升级Linux内核"></a>升级Linux内核</h4><p>BBR在Linux kernel 4.9引入。首先检查服务器kernel版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><p>如果其显示版本在4.9.0之下，则需要升级Linux内核，否则请忽略下文。</p><h4 id="开启BBR-1"><a href="#开启BBR-1" class="headerlink" title="开启BBR"></a>开启BBR</h4><p>运行<code>lsmod | grep bbr</code>，如果结果中没有<code>tcp_bbr</code>，则先运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modprobe tcp_bbr</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;tcp_bbr&quot;</span> &gt;&gt; /etc/modules-load.d/modules.conf</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.core.default_qdisc=fq&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.tcp_congestion_control=bbr&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>保存生效。运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure><p>若均有<code>bbr</code>，则开启BBR成功。</p><h3 id="优化吞吐量"><a href="#优化吞吐量" class="headerlink" title="优化吞吐量"></a>优化吞吐量</h3><p>新建配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/sysctl.d/local.conf</span><br></pre></td></tr></table></figure><p>复制粘贴：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># max open files</span><br><span class="line">fs.file-max = 51200</span><br><span class="line"># max read buffer</span><br><span class="line">net.core.rmem_max = 67108864</span><br><span class="line"># max write buffer</span><br><span class="line">net.core.wmem_max = 67108864</span><br><span class="line"># default read buffer</span><br><span class="line">net.core.rmem_default = 65536</span><br><span class="line"># default write buffer</span><br><span class="line">net.core.wmem_default = 65536</span><br><span class="line"># max processor input queue</span><br><span class="line">net.core.netdev_max_backlog = 4096</span><br><span class="line"># max backlog</span><br><span class="line">net.core.somaxconn = 4096</span><br><span class="line"></span><br><span class="line"># resist SYN flood attacks</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"># reuse timewait sockets when safe</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"># turn off fast timewait sockets recycling</span><br><span class="line">net.ipv4.tcp_tw_recycle = 0</span><br><span class="line"># short FIN timeout</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line"># short keepalive time</span><br><span class="line">net.ipv4.tcp_keepalive_time = 1200</span><br><span class="line"># outbound port range</span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class="line"># max SYN backlog</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096</span><br><span class="line"># max timewait sockets held by system simultaneously</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line"># turn on TCP Fast Open on both client and server side</span><br><span class="line">net.ipv4.tcp_fastopen = 3</span><br><span class="line"># TCP receive buffer</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 67108864</span><br><span class="line"># TCP write buffer</span><br><span class="line">net.ipv4.tcp_wmem = 4096 65536 67108864</span><br><span class="line"># turn on path MTU discovery</span><br><span class="line">net.ipv4.tcp_mtu_probing = 1</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_congestion_control = bbr</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl --system</span><br></pre></td></tr></table></figure><p>编辑之前的shadowsocks-server.service文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/systemd/system/shadowsocks-server.service</span><br></pre></td></tr></table></figure><p>在<code>ExecStart</code>前插入一行，内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStartPre=/bin/sh -c &#x27;ulimit -n 51200&#x27;</span><br></pre></td></tr></table></figure><p>即修改后的shadowsocks-server.service内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks Server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStartPre=/bin/sh -c &#x27;ulimit -n 51200&#x27;</span><br><span class="line">ExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks/config.json</span><br><span class="line">Restart=on-abort</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p><code>Ctrl + O</code>保存文件，<code>Ctrl + X</code>退出。</p><p>重载shadowsocks-server.service：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>重启Shadowsocks：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart shadowsocks-server</span><br></pre></td></tr></table></figure><h3 id="开启TCP-Fast-Open"><a href="#开启TCP-Fast-Open" class="headerlink" title="开启TCP Fast Open"></a>开启TCP Fast Open</h3><p>TCP Fast Open可以降低Shadowsocks服务器和客户端的延迟。实际上在上一步已经开启了TCP Fast Open，现在只需要在Shadowsocks配置中启用TCP Fast Open。</p><p>编辑config.json：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure><p>将<code>fast_open</code>的值由<code>false</code>修改为<code>true</code>。<code>Ctrl + O</code>保存文件，<code>Ctrl + X</code>退出。</p><p>重启Shadowsocks：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart shadowsocks-server</span><br></pre></td></tr></table></figure><p>注意：TCP Fast Open同时需要客户端的支持，即客户端Linux内核版本为3.7.1及以上；你可以在Shadowsocks客户端中启用TCP Fast Open。</p><p>至此，Shadowsock服务器端的优化已经全部完成了！</p><h1 id="Ubuntu更新SS以支持新的加密方法"><a href="#Ubuntu更新SS以支持新的加密方法" class="headerlink" title="Ubuntu更新SS以支持新的加密方法"></a>Ubuntu更新SS以支持新的加密方法</h1><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>每次用 SSH 的方式登入服务器的时候，都会提示如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Welcome to Ubuntu *.*.* LTS (GNU/Linux *.*.*-*-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com/</span><br><span class="line"></span><br><span class="line"> ……</span><br><span class="line"></span><br><span class="line">13 packages can be updated.</span><br><span class="line">10 updates are security updates.</span><br></pre></td></tr></table></figure><p>字面提示是有 13 个包可以升级，其中 10 个是安全更新。</p><p>事实上 Ubuntu 更新还是挺容易的，因为有 <code>apt-get</code>，不过更新完之后，还是会提示一些安全更新没做完，所以找了一下解决方案。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br><span class="line">apt-get dist-upgrade</span><br></pre></td></tr></table></figure><h4 id="命令说明："><a href="#命令说明：" class="headerlink" title="命令说明："></a>命令说明：</h4><ul><li><code>apt-get update</code> 从服务器更新可用的软件包<strong>列表</strong>。</li><li><code>apt-get upgrade</code> 根据列表，更新已安装的软件包。这个命令<strong>不会</strong>删除在列表中已经没有的软件包，<strong>也不会</strong>安装有依赖需求但尚未安装的软件包。</li><li><code>apt-get dist-upgrade</code> 根据列表，更新已安装的软件包。这个命令可能会为了解决软件包冲突而删除一些已安装的软件包，也可能会为了解决软件包依赖问题安装新的软件包。</li></ul><p>所以使用上面三个命令完成更新之后，用 <code>reboot</code> 命令重启系统就行。<strong>需要注意的是，以上所有命令都需要在 root 权限下执行。</strong></p><p>更新完成之后，去启动 SS，然后就报错了，从没见过的错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load libsodium failed with path None</span><br></pre></td></tr></table></figure><p>不清楚是更新的系统造成的，还是其他原因，反正 SS 不能用了。搜索了一下，发现用这个 lib 的话，SS 可以支持新的高效率一点的加密方式 <code>chacha20</code> 等等这些。</p><p>于是乎，装一下 <code>libsodium</code> 吧~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install build-essential</span><br><span class="line">wget https://download.libsodium.org/libsodium/releases/LATEST.tar.gz</span><br><span class="line">tar xf LATEST.tar.gz &amp;&amp; cd libsodium-*.*.*</span><br><span class="line">./configure &amp;&amp; make -j4 &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装完毕之后，修改 SS 配置文件，把加密换成 <code>chacha20-ietf-poly1305</code>，启动 SS，没有任何报错，一切正常。</p><p>客户端也把加密方式修改成相应的，完成~~</p><h4 id="不用自己编译的安装方式（未验证）"><a href="#不用自己编译的安装方式（未验证）" class="headerlink" title="不用自己编译的安装方式（未验证）"></a>不用自己编译的安装方式（未验证）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add-apt-repository ppa:chris-lea/libsodium</span><br><span class="line">echo &quot;deb http://ppa.launchpad.net/chris-lea/libsodium/ubuntu trusty main&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">echo &quot;deb-src http://ppa.launchpad.net/chris-lea/libsodium/ubuntu trusty main&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">apt-get update &amp;&amp; apt-get install libsodium-dev</span><br></pre></td></tr></table></figure><h1 id="PAC模式和全局代理模式的区别"><a href="#PAC模式和全局代理模式的区别" class="headerlink" title="PAC模式和全局代理模式的区别"></a>PAC模式和全局代理模式的区别</h1><h2 id="PAC模式"><a href="#PAC模式" class="headerlink" title="PAC模式"></a>PAC模式</h2><p>PAC模式也就是智能分流模式，根据规则去匹配你访问的网站，国外网站走代理，国内网站不走代理，非常智能，增加访问速度。</p><ul><li>优点：节省流量，国内网站依旧走本地网络，速度快，绝大部分国外网站都走代理，速度也快。</li><li>缺点：少部分国外网站会不经过代理，不能起到加速效果，甚至无法访问（解决方案：自己编辑PAC规则列表，将不走代理的国外网址加入进去，或者直接选择全局模式）。</li></ul><h2 id="全局模式"><a href="#全局模式" class="headerlink" title="全局模式"></a>全局模式</h2><p>全局模式就是国内、国外所有网站都走代理。</p><ul><li>优点：可访问全球所有网站。</li><li>缺点：所有网站都走代理，访问国内网站速度变慢，且耗流量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> V2Ray </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown介绍和使用说明</title>
      <link href="/posts/31824.html"/>
      <url>/posts/31824.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://www.zhihu.com/people/chen-shu-yi-21"><img src="https://pic1.zhimg.com/v2-9d019104896d4a8c9b94ba1ea53eadc9_xs.jpg?source=172ae18b" alt="陈树义"></a></p><p><a href="https://www.zhihu.com/people/chen-shu-yi-21">陈树义</a><a href="https://www.zhihu.com/question/48510028"></a></p><p>广州唯品会信息科技有限公司 Java开发工程师</p><p>854 人赞同了该文章</p><p>写博客、写文章比较多的人都知道 Markdown 是什么。</p><blockquote><p>Markdown 是一种轻量级标记语言，创始人为 John Gruber。它允许人们「使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档」。——维基百科</p></blockquote><p>简单地说，Markdown 与 HTML 语言一样，使用一些符号就代替样式。但是它比 HTML 语言更加简单。例如我想要实现标题样式，那么我可以这么做：</p><p><img src="https://pic1.zhimg.com/80/v2-169597b288329de5b969b341c5fed180_720w.jpg" alt="img"></p><h2 id="Markdown的本质"><a href="#Markdown的本质" class="headerlink" title="Markdown的本质"></a><strong>Markdown的本质</strong></h2><p>有些朋友会觉得，我用 Word 也可以实现同样的效果，为什么要使用 Markdown 呢？这个问题提得非常好，直戳问题本质。</p><p>Word 等其他文本编辑工具虽然也能实现同样的效果，但是其功能太强大了。Word 还能改变字体颜色，还可以调节字体大小。这么强大的功能可以说是 Word 的优点，但也可以说是它的缺点。</p><p>当功能多了，我们的注意力就会分散，我们就会去纠结：这个字体大小到底是 14 还是 16 好？我想强调这一句话，是要加粗还是标红？</p><p>而 Markdown 的出现让我们不需要去纠结这些问题。<strong>Markdown 的本质是让我们回归到内容本身，注重文章本身的结构，而不是样式。</strong></p><p>例如我们想要强调一句话，那么我们直接使用两个星号为其加粗，而不需要考虑是加粗还是标红（Markdown中只有黑色字体，没有其他颜色字体）。</p><p><img src="https://pic2.zhimg.com/80/v2-51ce4ea5fbdf997b5137476c14c18135_720w.jpg" alt="img"></p><p>你也不需要关心字体大小问题，因为 Markdown 中字体大小都与结构有关，无法手动设置。一级标题字体大一些，二级标题小一些。我们只需要关注哪些是一级标题，哪些是二级标题。而不需要去纠结标题字体到底要设置多大。</p><p><strong>Markdown 的本质是让我们回归内容本身。</strong> 当你明白这个道理的时候，你会明白为什么许多功能 Markdown 没有。</p><h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a><strong>Markdown语法</strong></h2><p>原生的 Markdown 语法只包含了最基础的一些特性，例如：标题、加粗、斜体、段落、引用、超链接、图片、列表、代码块、水平分割线等。而一些自定义实现的编辑器，则有一些自定义的实现，例如：数学公式、TODO列表等。所以当你看到有一些语法在一个编辑可以用，但到另一个编辑器又用不了的时候，那么这个语法可能就不是通用的 Markdown 原生语法了。</p><p>Markdown 语法非常简单，基本上只要多用几次就会了。下面简单介绍一些常用的 Markdown 语法。</p><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a><strong>段落</strong></h3><p>Markdown 使用 <code>#</code> 号来表示段落。</p><p><img src="https://pic4.zhimg.com/80/v2-ddbecf1f0fa5a9a5e92ab996d8863d23_720w.jpg" alt="img"></p><h3 id="加粗、斜体、加粗斜体"><a href="#加粗、斜体、加粗斜体" class="headerlink" title="加粗、斜体、加粗斜体"></a><strong>加粗、斜体、加粗斜体</strong></h3><p>Markdown 使用一个星号表示斜体，两个星号表示加粗，三个星号表示加粗斜体。</p><p><img src="https://pic4.zhimg.com/80/v2-4b35d8ad9479b746fa9ea0f45c06a6c3_720w.jpg" alt="img"></p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a><strong>无序列表</strong></h3><p>使用星号或者中横线来表示无序列表，注意后面需要加个空格。</p><p><img src="https://pic4.zhimg.com/80/v2-dcc81e176f9d783776cc6adcd5098773_720w.jpg" alt="img"></p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a><strong>有序列表</strong></h3><p>使用<code>数字+.</code>来表示有序列表，后面同样需要价格空格。</p><p><img src="https://pic4.zhimg.com/80/v2-de41880f5807e6f9fdde99c2742038b7_720w.jpg" alt="img"></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a><strong>引用</strong></h3><p>Markdown 使用 <code>&gt;</code> 符号来表示引用。</p><p><img src="https://pic1.zhimg.com/80/v2-ade3a47093a0899a08074c7fc2c167c0_720w.jpg" alt="img"></p><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a><strong>超链接</strong></h3><p>Markdown 使用 <code>[]()</code> 来表示超链接，中括号表示链接文字，小括号表示链接地址。</p><p><img src="https://pic4.zhimg.com/80/v2-63cc3a2b007a0a449ac2d549d62c6277_720w.jpg" alt="img"></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a><strong>图片</strong></h3><p>图片的样式与超链接非常相似，只需在前面加个感叹号就可以了，即用<code>![]()</code>表示图片。其中中括号表示图片未加载时的提示文字，小括号表示图片地址。</p><p><img src="https://pic1.zhimg.com/80/v2-a059af56aadb832034c4057c0f136824_720w.jpg" alt="img"></p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a><strong>代码块</strong></h3><p>我们使用 ` 号来表示代码块引用。</p><p><img src="https://pic2.zhimg.com/80/v2-736e127b8d833dc85e0499f7f817c3a1_720w.jpg" alt="img"></p><h3 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a><strong>水平分割线</strong></h3><p>使用 <code>---</code> 来表示分割线</p><p><img src="https://pic1.zhimg.com/80/v2-dc4df419d95a4bd2c05d8b7ab920fed8_720w.jpg" alt="img"></p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a><strong>表格</strong></h3><p>使用一根竖线来分隔各个单元格，使用冒号来决定单元格的对齐方向。</p><p><img src="https://pic4.zhimg.com/80/v2-3222f96f11294e78f28bc1f949965557_720w.jpg" alt="img"></p><h2 id="Markdown使用场景"><a href="#Markdown使用场景" class="headerlink" title="Markdown使用场景"></a><strong>Markdown使用场景</strong></h2><p>目前越来越多的站点都支持了 Markdown 语法，例如：Github 等代码托管平台，简书、博客园等写作平台。因此，掌握好 Markdown 语法可以非常方便地在各个主流站点使用。</p><h2 id="编辑工具"><a href="#编辑工具" class="headerlink" title="编辑工具"></a><strong>编辑工具</strong></h2><p>因为 Markdown 本质上是一个纯文本，所以任何能打开纯文本的东西都可以来编辑 Markdown。但如果你想要有预览功能，那么一款顺手的编辑功能还是有必要的。</p><p>在 Windows 上比较不错的编辑器有：MarkdownPad、Typora。在 OSX 上比较不错的编辑器有：Mou、MacDown、MWeb。</p><p>而我之前使用 MouDown 和 sublime 做简单的编辑，但是笔记等的就使用印象笔记写，而要发表的文章则使用 MWeb 编写。</p><h2 id="兼容神器"><a href="#兼容神器" class="headerlink" title="兼容神器"></a><strong>兼容神器</strong></h2><p>使用了 Markdown 可以写出条理非常清晰的文章，文章结构特别清晰。但是对于一些老编辑器而言，例如：ATLASSIAN 的 WIKI 对于 Markdown 的支持就很弱。</p><p>那么怎么办呢？</p><p>其实很简单，因为老的编辑器基本都支持 HTML，所以我们可以将 Markdown 渲染后的 HTML 复制到老编辑器。</p><p>我一般是在本地写好 Markdown 文章，之后直接复制到一个 Markdown 编辑器，然后复制对应的 HTML 文本到老编辑器中。</p><p><img src="https://pic4.zhimg.com/80/v2-394d2ecadb292765ac1d810cbe5672b3_720w.jpg" alt="img"></p><p>之后点击一下蓝色的复制按钮，就可以复制渲染后的 HTML 文本，最后直接粘贴到老编辑器中就可以了。我用的 Markdown 编辑器是：<strong><a href="https://link.zhihu.com/?target=https%3A//mdnice.github.io/">https://mdnice.github.io/</a></strong>，样式非常漂亮。</p><h2 id="进阶应用"><a href="#进阶应用" class="headerlink" title="进阶应用"></a><strong>进阶应用</strong></h2><p>当你学会使用 Markdown 之后，你会发现 Markdown 还有更多好玩的地方。例如：开源的 gitbook 就可以教你把一个个 Markdown 文件组织起来，弄成一本电子书。</p><p><img src="https://pic2.zhimg.com/80/v2-cdc7ada790a4473145b3c1207a3f8495_720w.jpg" alt="img"></p><p>具体如何操作，可以参考这里：<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/chenyurong/gitbook-notebook">https://github.com/chenyurong/g</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora+Picgo+Gitee构建网络图床笔记</title>
      <link href="/posts/80f1815e.html"/>
      <url>/posts/80f1815e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>前言</strong></p><p>之前一直在Typora上记录自己的笔记，但是发现markdown格式的笔记在插入图片时，仅能采用两种方法：1）在线图床，2）本地路径，即图片并不是像Word那样集成在文档内的，因此经过一番研究，发现了最新版的Typora已经支持在线图床功能，遂写此篇教程帮助后人构建自己的在线图床markdown笔记。</p><h2 id="所需软件"><a href="#所需软件" class="headerlink" title="所需软件"></a><strong>所需软件</strong></h2><p>typora</p><p><a href="https://link.zhihu.com/?target=https%3A//typora.io/">https://typora.io/</a></p><p>picgo</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p><p>建议选择2.2.2正式版本，beta版本可能会存在不稳定的风险。</p><p><img src="https://pic3.zhimg.com/80/v2-be88c425ba401a71e9c91dca74f0d262_720w.jpg" alt="img"></p><p>Gitee</p><p>由于国内连接github时网络偶尔存在不稳定的情况，于是采用了gitee作为github图床的替代，但整体教程是一样的</p><p><a href="https://link.zhihu.com/?target=https%3A//gitee.com/">https://gitee.com/</a></p><p><img src="https://pic3.zhimg.com/80/v2-daba73811b87533f8f032169d3d11d9a_720w.png" alt="img"></p><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a><strong>具体操作</strong></h2><p>主要是分为两部分操作，第一部分是Typora的配置，第二部分是Picgo+Gitee的在线图床配置</p><h3 id="Typora配置"><a href="#Typora配置" class="headerlink" title="Typora配置"></a><strong>Typora配置</strong></h3><p>打开Typora后，点击菜单栏-文件-偏好设置</p><p>找到其中的“图像”设置，将其设置为如下内容</p><p><img src="https://pic3.zhimg.com/80/v2-f374bec8d90d87c2f7683c1133064166_720w.jpg" alt="img"></p><p>1）<strong>插入图片时…</strong>下边的选择框内选择<strong>上传图片</strong></p><p>2）勾选上“<strong>对本地位置的图片应用上述规则</strong>”</p><p>3）上传服务选择<strong>PicGo(app)</strong></p><p>4）将<strong>PicGo路径</strong>项设置为本地PicGo的安装路径</p><p>这样，我们就把Typora配置好了，下面我们进行PicGo+Gitee的网络图床构建</p><h3 id="网络图床配置"><a href="#网络图床配置" class="headerlink" title="网络图床配置"></a><strong>网络图床配置</strong></h3><p>首先，安装好PicGo之后，我们需要给PicGo配置插件以支持Gitee图床</p><p><strong>注意</strong>：你必须安装<a href="https://link.zhihu.com/?target=https%3A//nodejs.org/en/">Node.js</a>之后才能安装PicGo的插件，因为PicGo要使用<code>npm</code>来安装插件。</p><p>安装好Nodejs后，点开左边的<strong>插件设置</strong>一栏，在输入框内输入“github plus”，如下</p><p><img src="https://pic1.zhimg.com/80/v2-270b499aeadae15d014215b32b1204c8_720w.jpg" alt="img"></p><p>点击安装此插件，之后左侧选项栏<strong>图床设置</strong>会多一个<strong>githubplus</strong></p><p><img src="https://pic1.zhimg.com/80/v2-1fd1e0c2ef8c48f1d85a5a04b8566714_720w.png" alt="img"></p><p>接下来我们配置Gitee仓库以存储图片</p><p>1）进入<a href="https://link.zhihu.com/?target=https%3A//gitee.com/">https://gitee.com/</a>，没有账号的话，先注册账号，注册以后登录，新建一个<strong>公开仓库</strong>，名字为picgo（可以自己起其他名字）</p><p>2）点击右上角，进入<strong>设置</strong>，在左侧的<strong>安全设置-私人令牌</strong>处生成新令牌。（注意：生成的新令牌只会显示一次，一定要保存好！！！）</p><p>我们需要做的如下：</p><p>1）回到picgo，按照如下进行设置</p><p><img src="https://pic3.zhimg.com/80/v2-dceba8a3986c7df4dbc3f8cb1e8ca60e_720w.jpg" alt="img"></p><p>其中的repo为 <strong>UserName/仓库名称</strong> 格式</p><p>branch填入master</p><p>Token为刚才在Gitee生成的私人令牌，粘贴到这里就行</p><p>path为仓库下用于存储图片的路径，这个可以自行选择</p><p>最下边的origin部分选择gitee（默认是github）</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a><strong>结束</strong></h2><p>经过上述操作，我们就把typora+picgo+gitee成功配置好了，之后当我们将本地的图片粘贴到markdown文档内的时候，typora会自动将图片上传到刚才我们配置好的gitee仓库内，并自动把markdown文档内的本地路径转化为gitee的图片外链，便于我们以后进行多端访问文档内的图片。</p>]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
